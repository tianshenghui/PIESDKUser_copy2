<?xml version="1.0"?>
<doc>
    <assembly>
        "ControlsEx"
    </assembly>
    <members>
        <member name="M:PIE.Controls.MagicWandTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.MagicWandTool">
            <summary>
魔术棒
</summary>
        </member>
        <member name="M:PIE.Controls.FittoMarginsElementsCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.FittoMarginsElementsCommand">
            <summary>
调整到页边距大小
</summary>
        </member>
        <member name="M:PIE.Controls.BringForwardElementsCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.BringForwardElementsCommand">
            <summary>
上移一层
</summary>
        </member>
        <member name="M:PIE.Controls.ZoomToPreviousExtentCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.ZoomToPreviousExtentCommand">
            <summary>
前一视图
</summary>
        </member>
        <member name="M:PIE.Controls.RightAlignmentElementCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.RightAlignmentElementCommand">
            <summary>
右对齐
</summary>
        </member>
        <member name="M:PIE.Controls.GaoDeSatelliteCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.GaoDeSatelliteCommand">
            <summary>
高德卫星图
</summary>
        </member>
        <member name="M:PIE.Controls.MakeGroupCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.MakeGroupCommand">
            <summary>
组合
</summary>
        </member>
        <member name="M:PIE.Controls.MakeSameHeightElementsCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.MakeSameHeightElementsCommand">
            <summary>
设置相同高度
</summary>
        </member>
        <member name="M:PIE.Controls.ImportElementsCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.ImportElementsCommand">
            <summary>
导入标绘
</summary>
        </member>
        <member name="M:PIE.Controls.AddPageScaleBarCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.AddPageScaleBarCommand">
            <summary>
Page比例尺
</summary>
        </member>
        <member name="M:PIE.Controls.ElementSelectTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.ElementSelectTool">
            <summary>
绘制点元素
</summary>
        </member>
        <member name="M:PIE.Controls.GoogleTopographyCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.GoogleTopographyCommand">
            <summary>
谷歌地形图
</summary>
        </member>
        <member name="M:PIE.Controls.PageZoomToWhole.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.PageZoomToWhole">
            <summary>
Page缩放至全图
</summary>
        </member>
        <member name="M:PIE.Controls.MakeSameWidthElementsCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.MakeSameWidthElementsCommand">
            <summary>
设置相同宽度
</summary>
        </member>
        <member name="M:PIE.Controls.LeftAlignmentElementCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.LeftAlignmentElementCommand">
            <summary>
左对齐
</summary>
        </member>
        <member name="M:PIE.Controls.TopAlignmentElementCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.TopAlignmentElementCommand">
            <summary>
顶端对齐
</summary>
        </member>
        <member name="M:PIE.Controls.UnlockDataFrameCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.UnlockDataFrameCommand">
            <summary>
解锁
</summary>
        </member>
        <member name="M:PIE.Controls.AddPageLegendCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.AddPageLegendCommand">
            <summary>
Page图例
</summary>
        </member>
        <member name="M:ConvertImageToQImage(System.Drawing.Image)">
            <summary>
转换Image句柄为QImage
</summary>
            <param name="image">转换的Image</param>
            <returns>QImage对象</returns>
        </member>
        <member name="M:ConvertQImageToImage(QImage*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
转换QImage为Image句柄
</summary>
            <param name="image">转换的QImage</param>
            <returns>Image句柄</returns>
        </member>
        <member name="M:ConvertObjectToQVariant(System.Object)">
            <summary>
转换Object句柄为QVariant
</summary>
            <param name="object">转换的Object</param>
            <returns>QVariant</returns>
        </member>
        <member name="M:ConvertQVariantToObject(QVariant*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
转换QVariant为Object句柄
</summary>
            <param name="variant">转换的QVariant</param>
            <returns>Object句柄</returns>
        </member>
        <member name="M:ConvertColorToQColor(System.Drawing.Color)">
            <summary>
转换Color句柄为QColor
</summary>
            <param name="color">转换的Color</param>
            <returns>QColor</returns>
        </member>
        <member name="M:ConvertQColorToColor(QColor*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
转换QColor为Color
</summary>
            <param name="color">转换的QColor</param>
            <returns>Color</returns>
        </member>
        <member name="M:ConvertFontToQFont(System.Drawing.Font)">
            <summary>
转换Font句柄为QFont
</summary>
            <param name="font">转换的Font</param>
            <returns>QFont</returns>
        </member>
        <member name="M:ConvertQFontToFont(QFont*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
转换QFont为Font句柄
</summary>
            <param name="font">转换的QFont</param>
            <returns>Font句柄</returns>
        </member>
        <member name="M:ConvertQStringToString(QString*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
转换QString为String句柄
</summary>
            <param name="strValueSource">转换前的String句柄</param>
            <returns>转换后的String</returns>
        </member>
        <member name="M:ConvertQStringToString(QString*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.String@)">
            <summary>
转换QString为String句柄
</summary>
            <param name="strValueSource">转换前的String句柄</param>
            <param name="strValueTarget">转换后的String</param>
            <returns />
        </member>
        <member name="M:ConvertStringToQString(System.String)">
            <summary>
转换String句柄为QString
</summary>
            <param name="strValueSource">转换前的String句柄</param>
            <returns />
        </member>
        <member name="M:ConvertStringToQString(System.String,QString*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
转换String句柄为QString
</summary>
            <param name="strValueSource">转换前的String句柄</param>
            <param name="strValueTarget">转换后的String</param>
            <returns />
        </member>
        <member name="D:SysCarto.IPmdContentsPtr">
@brief  pmd文档内容 智能指针对象

</member>
        <member name="F:SysCarto.IPmdContents.m_ptrCurrentTool">
@brief 当前工具

</member>
        <member name="F:SysCarto.IPmdContents.m_customerProperty">
@brief 自定义属性

</member>
        <member name="M:SysCarto.IPmdContents.Dispose">
@brief 析构函数

</member>
        <member name="M:SysCarto.IPmdContents.#ctor">
@brief 构造函数

</member>
        <member name="M:SysCarto.IPmdContents.SetTrackerCancel(SysUtility._ptr_t&lt;SysUI.TrackerCancel&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置取消追踪
@param [in] ptrTrackerCancel 取消追踪对象
@return void

</member>
        <member name="M:SysCarto.IPmdContents.GetTrackerCancel">
@brief 获得取消追踪
@return SysUI::TrackerCancelPtr 取消追踪对象

</member>
        <member name="M:SysCarto.IPmdContents.SetCurrentTool(SysUtility._ptr_t&lt;SysUI.ITool&gt;)">
@brief 设置当前工具
@param [in] ptrTool 当前工具对象
@return void 

</member>
        <member name="M:SysCarto.IPmdContents.GetCurrentTool">
@brief 获得当前工具
@return SysUI::IToolPtr 当前工具对象

</member>
        <member name="M:SysCarto.IPmdContents.SetCustomerProperty(boost.any!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置自定义属性
@param [in] prop 自定义属性
@return  void

</member>
        <member name="M:SysCarto.IPmdContents.GetMaps(QList&lt;SysUtility._ptr_t&lt;SysCarto.Map&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  获取地图集合
@return listMap 地图集合对象

</member>
        <member name="M:SysCarto.IPmdContents.GetPageLayout">
@brief  获取制图对象
@return PageLayoutPtr 制图对象

</member>
        <member name="M:SysCarto.IPmdContents.GetMap">
@brief 获取焦点地图对象
@return MapPtr 焦点地图对象

</member>
        <member name="M:SysCarto.IPmdContents.GetActiveView">
@brief  获取视图对象
@return ActiveViewPtr 视图对象

</member>
        <member name="T:SysCarto.IPmdContents">
@class IPmdContents
@brief  pmd文档内容

</member>
        <member name="F:SysCarto.PageLayout.m_mutex">
@brief 互斥锁

</member>
        <member name="F:SysCarto.PageLayout.m_RenderTimer">
@brief 渲染计时器

</member>
        <member name="F:SysCarto.PageLayout.m_bRefreshFlag">
@brief 地图是否需要刷新

</member>
        <member name="F:SysCarto.PageLayout.m_bShowRulers">
@brief 是否显示标尺对象

</member>
        <member name="F:SysCarto.PageLayout.m_pRulerSettings">
@brief 标尺对象

</member>
        <member name="F:SysCarto.PageLayout.m_pPrinter">
@brief 打印对象

</member>
        <member name="F:SysCarto.PageLayout.m_pPage">
@brief 页面

</member>
        <member name="F:SysCarto.PageLayout.m_pSnapGuidesV">
@brief 捕捉网格垂直线

</member>
        <member name="F:SysCarto.PageLayout.m_pSnapGuidesH">
@brief 捕捉网格水平线

</member>
        <member name="F:SysCarto.PageLayout.m_pSnapGrid">
@brief 捕捉网格

</member>
        <member name="F:SysCarto.PageLayout.m_ptrFocusMapFrameElement">
@brief 焦点地图框元素

</member>
        <member name="F:SysCarto.PageLayout.m_bAlignToMargins">
@brief 是否匹配到边缘

</member>
        <member name="M:SysCarto.PageLayout.StopMapsRender">
@brief 停止地图集渲染
@return  void

</member>
        <member name="M:SysCarto.PageLayout.StartMapsRender">
@brief 开始地图集渲染
@return  void

</member>
        <member name="M:SysCarto.PageLayout.InitliazeMapViews">
@brief 初始化地图视图
@return  void

</member>
        <member name="M:SysCarto.PageLayout.RefreshGraphics">
@brief 刷新制图
@return  void

</member>
        <member name="M:SysCarto.PageLayout.OnNotifyUpdate">
@brief 通知更新槽函数
@return  void

</member>
        <member name="M:SysCarto.PageLayout.OnRenderCompleted">
@brief 重置完成槽函数
@return  void

</member>
        <member name="M:SysCarto.PageLayout.OnRenderBegin">
@brief 渲染开始槽函数
@return  void

</member>
        <member name="M:SysCarto.PageLayout.ResetContentImage">
@brief 重置包含图片
@return  void

</member>
        <member name="M:SysCarto.PageLayout.UnregisterEvents">
@brief 取消注册事件
@return  void

</member>
        <member name="M:SysCarto.PageLayout.RegisterEvents">
@brief 注册事件
@return  void

</member>
        <member name="M:SysCarto.PageLayout.MapFrameElementOutput(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,QRect!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysGeometry.Envelope&gt;!System.Runtime.CompilerServices.IsConst,SysUtility._ptr_t&lt;SysCarto.MapFrameElement&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysUI.TrackerCancel&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 地图框元素输出
@param [in] painter 绘图对象
@param [in] recMapBlockDevice  地图块设备
@param [in] ptrMapBlockEnv     地图块范围
@param [in] ptrMapFrameElement 地图框元素
@param [in out] ptrPageLayoutTrans  页面布局显示转换对象
@param [in] ptrTracker 取消追踪对象
@return  void

</member>
        <member name="M:SysCarto.PageLayout.ClearAnnotationElement(QVector&lt;SysUtility._ptr_t&lt;SysCarto.Map&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,QVector&lt;QList&lt;SysUtility._ptr_t&lt;SysCarto.Element&gt;&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 清空注释元素
@param [in] vecMap 地图集合
@param [in] veclistAnnoElements  注释元素集合
@return  void

</member>
        <member name="M:SysCarto.PageLayout.CreateAnnotationElement(QVector&lt;SysUtility._ptr_t&lt;SysCarto.Map&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,QVector&lt;QList&lt;SysUtility._ptr_t&lt;SysCarto.Element&gt;&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 创建注释元素
@param [in] vecMap 地图集合
@param [in] veclistAnnoElements  注释元素集合
@param [in out] ptrOutputTrans  显示转换大小
@return  void

</member>
        <member name="M:SysCarto.PageLayout.CreateMapSurroundFrameElement(SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 创建地图包围框元素
@param [in out] ptrOutputTrans 显示转换大小 
@return  void 

</member>
        <member name="M:SysCarto.PageLayout.FindMapFrameByMap(SysUtility._ptr_t&lt;SysCarto.Map&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 通过地图查找地图框
@param [in] ptrMap  地图
@return  MapFrameElementPtr  地图框元素

</member>
        <member name="M:SysCarto.PageLayout.CopyTo(SysCarto.PageLayout*)">
@brief 拷贝到PageLayout
@param[in] PageLayout* PageLayout对象

</member>
        <member name="M:SysCarto.PageLayout.Clone">
@brief 克隆
@return PageLayoutPtr 当前PageLayout的克隆对象

</member>
        <member name="M:SysCarto.PageLayout.OutputJPG(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,SysUtility._ptr_t&lt;SysUI.TrackerCancel&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,=FUNC:System.Int32(System.Double,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Void*),System.Void*)">
@brief 获取输出JPG格式文件
@param [in] strPath  文件路径
@param [in] nDPI     像素点数
@param [in] ptrTracker 取消追踪对象
@param [in] pProgressFunc  回调函数指针
@param [in] pArg  回调函数参数
@return  void

</member>
        <member name="M:SysCarto.PageLayout.OutputPNG(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,SysUtility._ptr_t&lt;SysUI.TrackerCancel&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,=FUNC:System.Int32(System.Double,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Void*),System.Void*)">
@brief 获取输出PNG格式文件
@param [in] strPath  文件路径
@param [in] nDPI     像素点数
@param [in] ptrTracker 取消追踪对象
@param [in] pProgressFunc  回调函数指针
@param [in] pArg  回调函数参数
@return  void

</member>
        <member name="M:SysCarto.PageLayout.OutputTIF(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,SysUtility._ptr_t&lt;SysUI.TrackerCancel&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,=FUNC:System.Int32(System.Double,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Void*),System.Void*)">
@brief 获取输出TIF格式文件
@param [in] strPath  文件路径
@param [in] nDPI     像素点数
@param [in] ptrTracker 取消追踪对象
@param [in] pProgressFunc  回调函数指针
@param [in] pArg  回调函数参数
@return  void

</member>
        <member name="M:SysCarto.PageLayout.QueryOutputSize(System.Int32,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 查询获取输出大小
@param [in] nOutputDPI 每英寸点数
@param [in out] nWid 宽度
@param [in out] nHei 高度
@return  void

</member>
        <member name="M:SysCarto.PageLayout.GetMaps(QList&lt;SysUtility._ptr_t&lt;SysCarto.Map&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 获取地图集合
@param [in] listMap 地图集合
@return  void

</member>
        <member name="M:SysCarto.PageLayout.GetFocusMapFrameElement">
@brief 获取焦点地图框元素
@return  SysCarto::MapFrameElementPtr  外接多边形

</member>
        <member name="M:SysCarto.PageLayout.GetDefaultScaleTextEnvelope">
@brief 获取默认比例文本外接多边形
@return  SysGeometry::EnvelopePtr  外接多边形

</member>
        <member name="M:SysCarto.PageLayout.GetDefaultLegendEnvelope">
@brief 获取默认图例外接多边形
@return  SysGeometry::EnvelopePtr  外接多边形

</member>
        <member name="M:SysCarto.PageLayout.GetDefaultNorthArrowEnvelope">
@brief 获取默认指北针外接多边形
@return  SysGeometry::EnvelopePtr  外接多边形

</member>
        <member name="M:SysCarto.PageLayout.GetDefaultScaleBarEnvelope">
@brief 获取比例尺外接多边形 
@return  SysGeometry::EnvelopePtr  外接多边形

</member>
        <member name="M:SysCarto.PageLayout.GetDefaultDataFrameEnvelope">
@brief 获取数据框默认外接多边形 
@return  SysGeometry::EnvelopePtr  外接多边形 

</member>
        <member name="M:SysCarto.PageLayout.RenderGraphicsContainerSelections(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 渲染选中的制图内容
@param [in] paiter 绘制对象
@return void

</member>
        <member name="M:SysCarto.PageLayout.Draw(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysUI.TrackerCancel&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制
@param [in] paiter 绘制对象
@param [in] ptrTracker 取消追踪对象
@return void

</member>
        <member name="M:SysCarto.PageLayout.WaitForRenderFinished">
@brief 等待渲染完成
@return void

</member>
        <member name="M:SysCarto.PageLayout.StopRender">
@brief 停止渲染
@return void

</member>
        <member name="M:SysCarto.PageLayout.PanRefresh(System.Boolean)">
@brief 漫游刷新
@param [in] bForceActive 是否强制刷新
@return void

</member>
        <member name="M:SysCarto.PageLayout.Refresh(System.Boolean,System.Boolean)">
@brief 刷新
@param [in] bClearCache  是否清空缓存
@param [in] bFroceRefresh  是否强制刷新
@return  void

</member>
        <member name="M:SysCarto.PageLayout.PartialRefresh(SysCarto.ViewDrawPhaseType,System.Boolean)">
@brief 部分刷新
@param [in] dpType 视图绘制相应类型
@param [in] bForce 是否强制刷新
@return void

</member>
        <member name="M:SysCarto.PageLayout.GetContentImage">
@brief 获取内含图片
@return QImage  图片

</member>
        <member name="M:SysCarto.PageLayout.SetFullExtent(SysUtility._ptr_t&lt;SysGeometry.Envelope&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置全局范围
@param [in] ptrEnv 包络线范围
@return void

</member>
        <member name="M:SysCarto.PageLayout.GetFullExtent">
@brief 获取全局范围
@return SysGeometry::EnvelopePtr 包络线范围

</member>
        <member name="M:SysCarto.PageLayout.SetExtent(SysUtility._ptr_t&lt;SysGeometry.Envelope&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置范围
@param [in] ptrEnv 包络线范围
@return void

</member>
        <member name="M:SysCarto.PageLayout.GetExtent">
@brief 获取范围 
@return SysGeometry::EnvelopePtr 包络线范围

</member>
        <member name="M:SysCarto.PageLayout.HitTestMap(SysUtility._ptr_t&lt;SysGeometry.Point&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 点击测试地图
@param [in] point 地图点
@return void

</member>
        <member name="M:SysCarto.PageLayout.SetFocusMap(SysUtility._ptr_t&lt;SysCarto.Map&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置焦点地图
@param [in] ptrMap 地图
@return void

</member>
        <member name="M:SysCarto.PageLayout.GetFocusMap">
@brief 获取焦点地图
@return MapPtr 焦点地图

</member>
        <member name="M:SysCarto.PageLayout.Activate(QPaintDevice*)">
@brief 激活视图
@param [in] pDevice 视图绘制设备对象
@return void

</member>
        <member name="M:SysCarto.PageLayout.DeleteAllElements">
@brief 删除所有元素
@return void

</member>
        <member name="M:SysCarto.PageLayout.DeleteElement(SysUtility._ptr_t&lt;SysCarto.Element&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 删除元素
@param [in] ptrElement 元素
@return void

</member>
        <member name="M:SysCarto.PageLayout.AddElements(QList&lt;SysUtility._ptr_t&lt;SysCarto.Element&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 添加元素集
@param [in] vecElems 元素集合
@return void

</member>
        <member name="M:SysCarto.PageLayout.AddElement(SysUtility._ptr_t&lt;SysCarto.Element&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 添加元素
@param [in] ptrElement 元素
@return void

</member>
        <member name="M:SysCarto.PageLayout.InsertElement(System.Int32,SysUtility._ptr_t&lt;SysCarto.Element&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 插入元素到容器
@param [in] ptrElement 元素对象
@return void

</member>
        <member name="M:SysCarto.PageLayout.FromMapPoint(SysUtility._ptr_t&lt;SysGeometry.Point&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 从指定地图坐标点转化为页面坐标点
@param [in] ptrPoint 地图点
@return QPoint 页面点

</member>
        <member name="M:SysCarto.PageLayout.FromMapPoint(SysUtility._ptr_t&lt;SysCarto.Map&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysGeometry.Point&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 从指定地图坐标点转化为页面坐标点
@param [in] ptrMap 指定地图对象
@param [in] ptrPoint 地图点
@return QPoint 页面点

</member>
        <member name="M:SysCarto.PageLayout.ToMapPoint(QPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 从页面坐标点转化为指定地图坐标点
@param [in] point  页面点
@return  SysGeometry::PointPtr 地图点

</member>
        <member name="M:SysCarto.PageLayout.ToMapPoint(SysUtility._ptr_t&lt;SysCarto.Map&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,QPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 从页面坐标点转化为指定地图坐标点
@param [in] ptrMap 指定地图对象
@param [in] point  页面点
@return  SysGeometry::PointPtr 地图点

</member>
        <member name="M:SysCarto.PageLayout.MapToPagePoint(SysUtility._ptr_t&lt;SysCarto.Map&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 从地图坐标点转化为页面点 
@param [in] ptrMap  地图
@param [in] dMapX   地图X轴坐标点
@param [in] dMapY   地图Y轴坐标点
@param [in] dPageX  页面X轴横坐标点
@param [in] dPageY  页面Y轴纵坐标点
@return   void

</member>
        <member name="M:SysCarto.PageLayout.PageToMapPoint(SysUtility._ptr_t&lt;SysCarto.Map&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 从页面点转化为地图坐标点 
@param [in] ptrMap  地图
@param [in] dPageX  页面X轴横坐标点
@param [in] dPageY  页面Y轴纵坐标点
@param [in] dMapX   地图X轴坐标点
@param [in] dMapY   地图Y轴坐标点
@return   void

</member>
        <member name="M:SysCarto.PageLayout.FromPagePoint(SysUtility._ptr_t&lt;SysGeometry.Point&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 从页面点转化为设备点
@param [in] SysGeometry::PointPtr ptrPoint 页面点
@return QPoint 设备点

</member>
        <member name="M:SysCarto.PageLayout.ToPagePoint(QPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 开始绘制
@return   void

@brief 从设备点转化为页面点
@param [in] QPoint point 设备点
@return PointPtr 页面点

</member>
        <member name="M:SysCarto.PageLayout.SetShowRulers(System.Boolean)">
@brief 设置是否显示标尺
@param [in] bShow  是否显示标尺
@return   void

</member>
        <member name="M:SysCarto.PageLayout.IsShowRulers">
@brief 获取是否显示标尺 
@return   bool 是否显示标尺

</member>
        <member name="M:SysCarto.PageLayout.ZoomToWidth">
@brief 缩放到页宽 
@return   void

</member>
        <member name="M:SysCarto.PageLayout.ZoomToWhole">
@brief 缩放到整个页面
@return   void

</member>
        <member name="M:SysCarto.PageLayout.ZoomToPercent(System.Double)">
@brief 缩放到百分比 
@param [in] percent  百分比
@return   void

</member>
        <member name="M:SysCarto.PageLayout.ZoomPercent">
@brief 获得制图比例（百分比）
@return   double 制图比例（百分比）

</member>
        <member name="M:SysCarto.PageLayout.FocusPreviousMapFrame">
@brief 把上一个地图设置为激活MapFrame 
@return   void

</member>
        <member name="M:SysCarto.PageLayout.FocusNextMapFrame">
@brief 把下一个地图设置为激活MapFrame 
@return   void

</member>
        <member name="M:SysCarto.PageLayout.ReplaceMaps(QList&lt;SysUtility._ptr_t&lt;SysCarto.Map&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 替换地图 
@param [in] listMap  地图集合
@return   void

</member>
        <member name="M:SysCarto.PageLayout.GetRulerSettings">
@brief 获取标尺对象 
@return   RulerSettings*  标尺对象 

</member>
        <member name="M:SysCarto.PageLayout.Printer">
@brief 获取打印对象
@return  IPrinter*  打印对象

</member>
        <member name="M:SysCarto.PageLayout.GetPage">
@brief 获取获取页面
@return  Page*   页面

</member>
        <member name="M:SysCarto.PageLayout.VerticalSnapGuides">
@brief 获取垂直捕捉参考线
@return  SnapGuides* 垂直捕捉参考线

</member>
        <member name="M:SysCarto.PageLayout.HorizontalSnapGuides">
@brief 获取水平捕捉参考线
@return  SnapGuides* 水平捕捉参考线

</member>
        <member name="M:SysCarto.PageLayout.GetSnapGrid">
@brief 获取捕捉网格
@return  SnapGrid*  捕捉网格

</member>
        <member name="M:SysCarto.PageLayout.ClearContent">
@brief 清空内容
@return  void

</member>
        <member name="M:SysCarto.PageLayout.GetAlignToMargins">
@brief 获取是否匹配到边缘
@return  bool 是 true,否 false

</member>
        <member name="M:SysCarto.PageLayout.SetAlignToMargins(System.Boolean)">
@brief 设置匹配到边缘
@param [in] bValue 是否设置
@return  void

</member>
        <member name="M:SysCarto.PageLayout.Dispose">
@brief 析构函数

</member>
        <member name="M:SysCarto.PageLayout.#ctor">
@brief 构造函数

</member>
        <member name="T:SysCarto.PageLayout">
@brief  类的前置声明和智能指针定义


@class PageLayout
@brief  页面布局

</member>
        <member name="D:SysGeometry.PolygonPtr">
@brief 面对象 智能指针对象

</member>
        <member name="F:SysGeometry.Polygon.m_ExteriorRing">
@brief 外环

</member>
        <member name="F:SysGeometry.Polygon.m_InteriorRings">
@brief 内环集合

</member>
        <member name="M:SysGeometry.Polygon.GetArea(SysUtility._ptr_t&lt;SysGeometry.PointCollection&gt;)">
@brief 获得面积
@param[in] PointCollectionPtr ptrPointCollection 要计算面积的对象
@return 面积

</member>
        <member name="M:SysGeometry.Polygon.Clone">
@brief 克隆
@return GeometryPtr 克隆成果

</member>
        <member name="M:SysGeometry.Polygon.Equals(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 是否相等
@param[in] const GeometryPtr ptrGeo 空间几何图形对象
@return bool 是否相等

</member>
        <member name="M:SysGeometry.Polygon.Scale(SysUtility._ptr_t&lt;SysGeometry.Point&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
@brief 缩放
@param[in] PointPtr originPoint 参照点
@param[in] double sx x方向缩放
@param[in] double sy y方向缩放
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Polygon.Rotate(SysUtility._ptr_t&lt;SysGeometry.Point&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
@brief 旋转
@param[in] PointPtr originPoint 参照点
@param[in] double rotationAngle 旋转角度
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Polygon.Move(System.Double,System.Double)">
@brief 移动
@param[in] double dx x方向的偏移
@param[in] double dy y方向的偏移
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Polygon.Transform(SysUtility._ptr_t&lt;SysGeometry.CoordinateTransformation&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 投影转换（会忽略原来的空间参考）
@param[in] CoordinateTransformationPtr ptrCT 坐标转换对象
@return bool 是否转换成功

</member>
        <member name="M:SysGeometry.Polygon.Centroid">
@brief 获得质点
@return GeometryPtr 质点

</member>
        <member name="M:SysGeometry.Polygon.GetEnvelope">
@brief 获得空间范围
@return GeometryPtr 空间范围

</member>
        <member name="M:SysGeometry.Polygon.IsValid">
@brief 是否是有效的
@return bool 是否是有效的

</member>
        <member name="M:SysGeometry.Polygon.IsSimple">
@brief 是否是简单几何形状
@return bool 是否是简单几何形状

</member>
        <member name="M:SysGeometry.Polygon.IsEmpty">
@brief 是否为空
@return bool 是否为空

</member>
        <member name="M:SysGeometry.Polygon.SetEmpty">
@brief 设置为空
@return bool

</member>
        <member name="M:SysGeometry.Polygon.IsPointOnSurface(SysUtility._ptr_t&lt;SysGeometry.Point&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 点是否在面上
@param[in] PointPtr ptrPoint 点
@return bool 点是否在面上

</member>
        <member name="M:SysGeometry.Polygon.GetArea">
@brief 获得面积
@returndouble

</member>
        <member name="M:SysGeometry.Polygon.GetLength">
@brief 获得长度
@return double 长度

</member>
        <member name="M:SysGeometry.Polygon.ClearPoints">
@brief 清除点
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Polygon.RemovePoint(System.Int32)">
@brief 通过索引删除点
@param[in] int index 编号
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Polygon.GetZ(System.Int32)">
@brief 通过索引获得点的Z值
@param[in] int index 编号
@return double 编号为index的点的Z值

</member>
        <member name="M:SysGeometry.Polygon.GetY(System.Int32)">
@brief 通过索引获得点的Y值
@param[in] int index 编号
@return double 编号为index的点的Y值

</member>
        <member name="M:SysGeometry.Polygon.GetX(System.Int32)">
@brief 通过索引获得点的X值
@param[in] int index 编号
@return double 编号为index的点的X值

</member>
        <member name="M:SysGeometry.Polygon.GetPoint(System.Int32)">
@brief 通过索引获得点
@param[in] int index 编号
@return PointPtr 点

</member>
        <member name="M:SysGeometry.Polygon.InsertPoint(System.Int32,SysUtility._ptr_t&lt;SysGeometry.Point&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 通过索引插入点
@param[in] int index 编号
@param[in] PointPtr point 点
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Polygon.GetPoints(System.Int32,System.Double*,System.Double*,System.Double*)">
@brief 获取点集数组
@param[in] int count 需要获取点集的数量
@param[in] double* px  X坐标点值的数组
@param[in] double* py  Y坐标点值的数组
@param[in] double* pz  Z坐标点值的数组
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Polygon.SetPoints(System.Int32,System.Double*,System.Double*,System.Double*)">
@brief 给PointCollection中点赋值
@param[in] int count 要赋值点的数量
@param[in] double* px  X坐标的数组中的值
@param[in] double* py  Y坐标的数组中的值
@param[in] double* pz = NULL   Z坐标的数组中的值  默认为空
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Polygon.AddPoint(System.Double,System.Double,System.Double)">
@brief 添加点
@param[in] double x X
@param[in] double y Y
@param[in] double z Z
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Polygon.AddPoint(System.Double,System.Double)">
@brief 添加点
@param[in] double x  X坐标
@param[in] double y  Y坐标
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Polygon.AddPoint(SysUtility._ptr_t&lt;SysGeometry.Point&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 添加点
@param[in] PointPtr point 点
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Polygon.GetPointCount">
@brief 获得点数目
@return int 点的数目

</member>
        <member name="M:SysGeometry.Polygon.GetExteriorRing">
@brief 获得外环
@return RingPtr 外环

</member>
        <member name="M:SysGeometry.Polygon.SetExteriorRing(SysUtility._ptr_t&lt;SysGeometry.Ring&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置外环
@param[in] RingPtr interiorRing 外环
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Polygon.GetInteriorRingCount">
@brief 得到内环个数
@return int 内环个数

</member>
        <member name="M:SysGeometry.Polygon.ClearInteriorRings">
@brief 清除内环
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Polygon.RemoveInteriorRing(System.Int32)">
@brief 移除内环
@param[in] int index 编号
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Polygon.GetInteriorRingByIndex(System.Int32)">
@brief 通过编号获得内环
@param[in] int index 编号
@return RingPtr 内环

</member>
        <member name="M:SysGeometry.Polygon.AddInteriorRing(SysUtility._ptr_t&lt;SysGeometry.Ring&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 添加内环
@param[in] RingPtr interiorRing 内环
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Polygon.CloseRings">
@brief 关闭所有的Ring
@return

</member>
        <member name="M:SysGeometry.Polygon.Dispose">
@brief 析构函数
@return

</member>
        <member name="M:SysGeometry.Polygon.#ctor">
@brief 构造函数
@return

</member>
        <member name="T:SysGeometry.Polygon">
@class Polygon
	* @brief 面对象

</member>
        <member name="D:SysGeometry.RingPtr">
@brief 闭合环 智能指针对象

</member>
        <member name="M:SysGeometry.Ring.GetPointByDistance(System.Double)">
@brief 通过距离获得点
@param[in] double distance
@return PointPtr  获得的点对象指针

</member>
        <member name="M:SysGeometry.Ring.IsClosed">
@brief 是否闭合
@return bool 是否闭合

</member>
        <member name="M:SysGeometry.Ring.GetEndPoint">
@brief 获得终止点
@return PointPtr 终止点

</member>
        <member name="M:SysGeometry.Ring.GetStartPoint">
@brief 获得起始点
@return PointPtr 起始点

</member>
        <member name="M:SysGeometry.Ring.GetLength">
@brief 获得长度
@return double 长度

</member>
        <member name="M:SysGeometry.Ring.Clone">
@brief 克隆
@return GeometryPtr 克隆成果

</member>
        <member name="M:SysGeometry.Ring.Equals(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 是否相等
@param[in] const GeometryPtr ptrGeo 空间几何图形对象
@return bool 是否相等

</member>
        <member name="M:SysGeometry.Ring.Scale(SysUtility._ptr_t&lt;SysGeometry.Point&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
@brief 缩放
@param[in] PointPtr originPoint 参照点
@param[in] double sx x方向缩放
@param[in] double sy y方向缩放
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Ring.Rotate(SysUtility._ptr_t&lt;SysGeometry.Point&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
@brief 旋转
@param[in] PointPtr originPoint 参照点
@param[in] double rotationAngle 旋转角度
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Ring.Move(System.Double,System.Double)">
@brief 移动
@param[in] double dx x方向的偏移
@param[in] double dy y方向的偏移
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Ring.Transform(SysUtility._ptr_t&lt;SysGeometry.CoordinateTransformation&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 投影转换（会忽略原来的空间参考）
@param[in] CoordinateTransformationPtr ptrCT 坐标转换对象
@return bool 是否转换成功

</member>
        <member name="M:SysGeometry.Ring.Centroid">
@brief 获得质点
@return GeometryPtr 质点

</member>
        <member name="M:SysGeometry.Ring.GetEnvelope">
@brief 获得空间范围
@return GeometryPtr 空间范围

</member>
        <member name="M:SysGeometry.Ring.IsValid">
@brief 是否是有效的
@return bool 是否是有效的

</member>
        <member name="M:SysGeometry.Ring.IsSimple">
@brief 是否是简单几何形状
@return bool 是否是简单几何形状

</member>
        <member name="M:SysGeometry.Ring.IsEmpty">
@brief 是否为空
@return bool 是否为空

</member>
        <member name="M:SysGeometry.Ring.SetEmpty">
@brief 设置为空
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Ring.IsPointInRing(SysUtility._ptr_t&lt;SysGeometry.Point&gt;)">
@brief 点是否在环里边
@param[in] SysGeometry::PointPtr ptrPoint 点
@return bool 是否在环里边

</member>
        <member name="M:SysGeometry.Ring.Close">
@brief 闭合
@return

</member>
        <member name="M:SysGeometry.Ring.Dispose">
@brief 析构函数
@return

</member>
        <member name="M:SysGeometry.Ring.#ctor">
@brief 构造函数
@return

</member>
        <member name="T:SysGeometry.Ring">
@class Ring
	* @brief 闭合环

</member>
        <member name="D:SysGeometry.SurfacePtr">
@brief  表面对象的智能指针对象

</member>
        <member name="M:SysGeometry.Surface.GetLength(SysUtility._ptr_t&lt;SysGeometry.PointCollection&gt;)">
@brief 获得面积
@param[in] PointCollectionPtr ptrPointCollection 要计算面积的对象
@return 面积

</member>
        <member name="M:SysGeometry.Surface.GetArea(SysUtility._ptr_t&lt;SysGeometry.PointCollection&gt;)">
@brief 获得面积
@param[in] PointCollectionPtr ptrPointCollection 要计算面积的对象
@return 面积

</member>
        <member name="M:SysGeometry.Surface.IsPointOnSurface(SysUtility._ptr_t&lt;SysGeometry.Point&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 点是否在面上
@param[in] PointPtr ptrPoint 点
@return bool 点是否在面上

</member>
        <member name="M:SysGeometry.Surface.GetArea">
@brief 获得面积
@returndouble

</member>
        <member name="M:SysGeometry.Surface.GetLength">
@brief 获得长度
@return double 长度

</member>
        <member name="M:SysGeometry.Surface.Dispose">
@brief 构造函数
@return

</member>
        <member name="M:SysGeometry.Surface.#ctor">
@brief 构造函数
@return

</member>
        <member name="T:SysGeometry.Surface">
@class Surface
	* @brief 表面对象

</member>
        <member name="D:SysCarto.MapFrameElementPtr">
@brief  地图框架元素类  智能指针

</member>
        <member name="M:SysCarto.MapFrameElement.CopyTo(SysCarto.Element*)">
@brief 拷贝到Element
@param [in] Element* ptrElement Element对象

</member>
        <member name="F:SysCarto.MapFrameElement.m_ptrMap">
@brief 地图对象

</member>
        <member name="F:SysCarto.MapFrameElement.m_vecMapGrid">
@brief 地图网格集合

</member>
        <member name="M:SysCarto.MapFrameElement.GetMap">
@brief 获取地图
@return  void

</member>
        <member name="M:SysCarto.MapFrameElement.SetMap(SysUtility._ptr_t&lt;SysCarto.Map&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置地图
@param [in] ptrMap  地图
@return  void

</member>
        <member name="M:SysCarto.MapFrameElement.PageToMapPoint(System.Double,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 从页面坐标点转化为地图点
@param [in] dPageX 页面点X
@param [in] dPageY 页面点Y
@param [in] dMapX  地图点X
@param [in] dMapY  地图点Y
@return  void

</member>
        <member name="M:SysCarto.MapFrameElement.MapToPagePoint(System.Double,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 从地图坐标点转化为页面点 
@param [in] dMapX  地图点X 
@param [in] dMapY  地图点Y
@param [in] dPageX 页面点X
@param [in] dPageY 页面点Y
@return  void

</member>
        <member name="M:SysCarto.MapFrameElement.GetMapGridCount">
@brief 获取地图网格数量
@return  int 地图网格数量

</member>
        <member name="M:SysCarto.MapFrameElement.GetMapGrid(System.Int32)">
@brief 获取地图网格
@param [in] nIndex  索引
@return  IMapGridPtr  地图网格

</member>
        <member name="M:SysCarto.MapFrameElement.SetMapGrid(System.Int32,SysUtility._ptr_t&lt;SysCarto.IMapGrid&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置地图网格
@param [in] ptrMapGrid  地图网格对象
@return  void

</member>
        <member name="M:SysCarto.MapFrameElement.DeleteMapGrid(SysUtility._ptr_t&lt;SysCarto.IMapGrid&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 删除地图网格
@param [in] ptrMapGrid  地图网格对象
@return  void

</member>
        <member name="M:SysCarto.MapFrameElement.ClearMapGrids">
@brief 清空地图网格
@return  void

</member>
        <member name="M:SysCarto.MapFrameElement.AddMapGrid(SysUtility._ptr_t&lt;SysCarto.IMapGrid&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 添加地图网格
@param [in] ptrMapGrid  地图网格对象
@return  void

</member>
        <member name="M:SysCarto.MapFrameElement.Clone">
@brief 克隆
@return ElementPtr  元素克隆对象

</member>
        <member name="M:SysCarto.MapFrameElement.QueryBounds(SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 查询外接多边形
@param [in] ptrTrasform 显示转换对象
@return  SysGeometry::EnvelopePtr  外接多边形

</member>
        <member name="M:SysCarto.MapFrameElement.Draw(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysUI.TrackerCancel&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制
@param [in] paiter 绘图面板
@param [in] ptrTrasform 显示转换对象
@param [in] ptrTracker 取消追踪对象
@return void

</member>
        <member name="M:SysCarto.MapFrameElement.Dispose">
@brief 析构函数

</member>
        <member name="M:SysCarto.MapFrameElement.#ctor">
@brief 构造函数

</member>
        <member name="T:SysCarto.MapFrameElement">
@class MapFrameElement
@brief 地图框架元素类

</member>
        <member name="F:SysCarto.IMapGrid.m_bOutSideSubTick">
@brief 是否为数据框外部子刻度
true-外部，false-内部

</member>
        <member name="F:SysCarto.IMapGrid.m_bOutSideTick">
@brief 是否为数据框外部刻度
true-外部，false-内部

</member>
        <member name="F:SysCarto.IMapGrid.m_dTickLength">
@brief 标记长度

</member>
        <member name="F:SysCarto.IMapGrid.m_dSubTickLength">
@brief 子标记长度

</member>
        <member name="F:SysCarto.IMapGrid.m_nSubTickCount">
@brief 子标记数量

</member>
        <member name="F:SysCarto.IMapGrid.m_tickVisibility">
@brief 标记可视化数组 

</member>
        <member name="F:SysCarto.IMapGrid.m_subTickVisibility">
@brief 子标记可视化数组 

</member>
        <member name="F:SysCarto.IMapGrid.m_labelVisibility">
@brief 标签可视化数组 （0 left 1 top 2 right 3 bottom）

</member>
        <member name="F:SysCarto.IMapGrid.m_strName">
@brief 名字

</member>
        <member name="F:SysCarto.IMapGrid.m_ptrTickMarkSymbol">
@brief 标记点符号

</member>
        <member name="F:SysCarto.IMapGrid.m_ptrTickLineSymbol">
@brief 标记线符号

</member>
        <member name="F:SysCarto.IMapGrid.m_ptrSubTickLineSymbol">
@brief 子标记线符号

</member>
        <member name="F:SysCarto.IMapGrid.m_ptrLineSymbol">
@brief 线符号

</member>
        <member name="F:SysCarto.IMapGrid.m_ptrGridLabel">
@brief 网格标签

</member>
        <member name="F:SysCarto.IMapGrid.m_bVisible">
@brief 是否可视化

</member>
        <member name="M:SysCarto.IMapGrid.DrawTickAndLabel(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysUI.TrackerCancel&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysCarto.MapFrameElement&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysGeometry.MultiPolyline&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制标记和标签
@param [in] painter   绘图设备
@param [in] ptrTracker   取消转换
@param [in] ptrTrans  显示转换对象
@param [in] ptrMapFrame  地图框架对象
@param [in] ptrGeometry   多线对象
@return void

</member>
        <member name="M:SysCarto.IMapGrid.CreateGridLine(SysUtility._ptr_t&lt;SysCarto.MapFrameElement&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 创建网格线
@param [in] ptrMapFrameElement     地图框架元素
@return SysGeometry::MultiPolylinePtr  多线对象

</member>
        <member name="M:SysCarto.IMapGrid.CopyTo(SysCarto.IMapGrid*)">
@brief 拷贝到IMapGrid
@param [in] IMapGrid* pMapGrid  地图网格
return void

</member>
        <member name="M:SysCarto.IMapGrid.Clone">
@brief 克隆
@return  IMapGridPtr  地图框架

</member>
        <member name="M:SysCarto.IMapGrid.SetDefaultInterval(SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysCarto.MapFrameElement&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置默认间距
@param [in] ptrTrans     显示转换
@param [in] ptrMapFrame  地图框架
@return void

</member>
        <member name="M:SysCarto.IMapGrid.GetOutSideSubTick">
@brief 获取是否为数据框外部子刻度
@return bool  是否为数据框外部子刻度

</member>
        <member name="M:SysCarto.IMapGrid.SetOutSideSubTick(System.Boolean)">
@brief 设置是否为数据框外部子刻度
@param [in] bValue   是否为数据框外部子刻度
@return void

</member>
        <member name="M:SysCarto.IMapGrid.GetOutSideTick">
@brief 获取是否为数据框外部刻度
@return bool  否为数据框外部刻度

</member>
        <member name="M:SysCarto.IMapGrid.SetOutSideTick(System.Boolean)">
@brief 设置是否为数据框外部刻度
@param [in] bValue   否为数据框外部刻度
@return void

</member>
        <member name="M:SysCarto.IMapGrid.GetVisible">
@brief 获取可视化
@return bool  是否可视化

</member>
        <member name="M:SysCarto.IMapGrid.SetVisible(System.Boolean)">
@brief 设置可视化
@param [in] bValue   是否可视化
@return void

</member>
        <member name="M:SysCarto.IMapGrid.GetTickMarkSymbol">
@brief 获取标记点符号
@return SysDisplay::MarkerSymbolPtr   点符号

</member>
        <member name="M:SysCarto.IMapGrid.SetTickMarkSymbol(SysUtility._ptr_t&lt;SysDisplay.MarkerSymbol&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置标记点符号
@param [in] ptrMarkerSymbol    点符号
@return void

</member>
        <member name="M:SysCarto.IMapGrid.GetTickLineSymbol">
@brief 获取标记线符号
@return SysDisplay::LineSymbolPtr   线符号

</member>
        <member name="M:SysCarto.IMapGrid.SetTickLineSymbol(SysUtility._ptr_t&lt;SysDisplay.LineSymbol&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置标记线符号
@param [in] ptrLineSymbol    线符号
@return void

</member>
        <member name="M:SysCarto.IMapGrid.GetTickLength">
@brief 获取标记长度
@return double  子标记长度

</member>
        <member name="M:SysCarto.IMapGrid.SetTickLength(System.Double)">
@brief 设置标记长度
@param [in] nValue    长度
@return void

</member>
        <member name="M:SysCarto.IMapGrid.GetSubTickLineSymbol">
@brief 获取子标记线符号
@return SysDisplay::LineSymbolPtr   线符号

</member>
        <member name="M:SysCarto.IMapGrid.SetSubTickLineSymbol(SysUtility._ptr_t&lt;SysDisplay.LineSymbol&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置子标记线符号
@param [in] ptrLineSymbol    线符号
@return void

</member>
        <member name="M:SysCarto.IMapGrid.GetSubTickLength">
@brief 获取子标记长度
@return double  子标记长度

</member>
        <member name="M:SysCarto.IMapGrid.SetSubTickLength(System.Double)">
@brief 设置子标记长度
@param [in] nValue    长度
@return void

</member>
        <member name="M:SysCarto.IMapGrid.GetSubTickCount">
@brief 获取子标记数量
@return int  子标记数量

</member>
        <member name="M:SysCarto.IMapGrid.SetSubTickCount(System.Int32)">
@brief 设置子标记数量
@param [in] nValue    子标记数量
@return void

</member>
        <member name="M:SysCarto.IMapGrid.SetTickVisibility(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
@brief 设置全部标记可视化
@param [in] leftVis    左侧是否可视化
@param [in] topVis     顶部是否可视化
@param [in] rightVis   右侧是否可视化
@param [in] bottomVis  底部是否可视化
@return void

</member>
        <member name="M:SysCarto.IMapGrid.SetSubTickVisibility(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
@brief 设置子标记可视化
@param [in] leftVis    左侧是否可视化
@param [in] topVis     顶部是否可视化
@param [in] rightVis   右侧是否可视化
@param [in] bottomVis  底部是否可视化
@return void

</member>
        <member name="M:SysCarto.IMapGrid.SetLabelVisibility(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
@brief 设置标签可视化
@param [in] leftVis    左侧是否可视化
@param [in] topVis     顶部是否可视化
@param [in] rightVis   右侧是否可视化
@param [in] bottomVis  底部是否可视化
@return void

</member>
        <member name="M:SysCarto.IMapGrid.SetDefaults(SysUtility._ptr_t&lt;SysCarto.MapFrameElement&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  设置默认属性值
@param [in] ptrMapFrame   地图框架对象
@return void

</member>
        <member name="M:SysCarto.IMapGrid.QueryTickVisibility(System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 查询获取全部标记可视化
@param [in] leftVis    左侧是否可视化
@param [in] topVis     顶部是否可视化
@param [in] rightVis   右侧是否可视化
@param [in] bottomVis  底部是否可视化
@return void

</member>
        <member name="M:SysCarto.IMapGrid.QuerySubTickVisibility(System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 查询获取子标记可视化
@param [in] leftVis    左侧是否可视化
@param [in] topVis     顶部是否可视化
@param [in] rightVis   右侧是否可视化
@param [in] bottomVis  底部是否可视化
@return void

</member>
        <member name="M:SysCarto.IMapGrid.QueryLabelVisibility(System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 查询获取标签可视化
@param [in] leftVis    左侧是否可视化
@param [in] topVis     顶部是否可视化
@param [in] rightVis   右侧是否可视化
@param [in] bottomVis  底部是否可视化
@return void

</member>
        <member name="M:SysCarto.IMapGrid.GetName">
@brief  获取名字
@return QString  名字

</member>
        <member name="M:SysCarto.IMapGrid.SetName(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置名字
@param [in] strName 名字
@return void

</member>
        <member name="M:SysCarto.IMapGrid.GetLineSymbol">
@brief  获取线样式
@return SysDisplay::LineSymbolPtr  线样式

</member>
        <member name="M:SysCarto.IMapGrid.SetLineSymbol(SysUtility._ptr_t&lt;SysDisplay.LineSymbol&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置线样式
@param [in] ptrLineSymbol 线样式
@return void

</member>
        <member name="M:SysCarto.IMapGrid.GetLabelFormat">
@brief  获取标签格式
@return IGridLabelPtr  标签格式

</member>
        <member name="M:SysCarto.IMapGrid.SetLabelFormat(SysUtility._ptr_t&lt;SysCarto.IGridLabel&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置标签格式
@param [in] ptrGridLabel 网格标签
@return void

</member>
        <member name="M:SysCarto.IMapGrid.Draw(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysUI.TrackerCancel&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysCarto.MapFrameElement&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制
@param [in] painter      绘图设备
@param [in] ptrTracker   取消转换
@param [in] ptrTrans     显示转换对象
@param [in] ptrMapFrame  地图框架指针
@return void

</member>
        <member name="M:SysCarto.IMapGrid.Dispose">
@brief 析构函数

</member>
        <member name="M:SysCarto.IMapGrid.#ctor">
@brief 构造函数

</member>
        <member name="T:SysCarto.MapGridSerializer">
@brief  声明矢量要素序列化渲染类为当前类的友元类

</member>
        <member name="T:SysCarto.IMapGrid">
@brief   类的前置声明和智能指针定义


@class IMapGrid
@brief  地图网格

</member>
        <member name="D:SysGeometry.MultiPolylinePtr">
@brief  多线对象 智能指针对象

</member>
        <member name="M:SysGeometry.MultiPolyline.Equals(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 是否相等
@param[in] const GeometryPtr ptrGeo 空间几何图形对象
@return bool 是否相等

</member>
        <member name="M:SysGeometry.MultiPolyline.GetPointByDistance(System.Double)">
@brief 通过距离获得点
@param[in] double distance 距离
@return PointPtr 点对象指针

</member>
        <member name="M:SysGeometry.MultiPolyline.IsClosed">
@brief 是否闭合
@return bool 是否闭合

</member>
        <member name="M:SysGeometry.MultiPolyline.GetEndPoint">
@brief 获得终止点
@return PointPtr 终止点

</member>
        <member name="M:SysGeometry.MultiPolyline.GetStartPoint">
@brief 获得起始点
@return PointPtr 起始点

</member>
        <member name="M:SysGeometry.MultiPolyline.GetLength">
@brief 获得长度
@return double 长度

</member>
        <member name="M:SysGeometry.MultiPolyline.Clone">
@brief 克隆
@return GeometryPtr 克隆成果

</member>
        <member name="M:SysGeometry.MultiPolyline.InsertGeometry(System.Int32,SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 插入Geometry对象
@param[in] int index 插入的编号
@param[in] GeometryPtr ptrGeo Geometry智能指针
@return bool 是否成功

</member>
        <member name="M:SysGeometry.MultiPolyline.AddGeometry(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 增加Geometry对象
@param[in] GeometryPtr ptrGeo Geometry智能指针
@return bool 是否成功

</member>
        <member name="M:SysGeometry.MultiPolyline.Dispose">
@brief 析构函数
@return

</member>
        <member name="M:SysGeometry.MultiPolyline.#ctor">
@brief 构造函数
@return

</member>
        <member name="T:SysGeometry.MultiPolyline">
@class MultiPolyline
	* @brief 多线对象

</member>
        <member name="D:SysGeometry.GeometryCollectionPtr">
@brief 图形集合 智能指针对象

</member>
        <member name="F:SysGeometry.GeometryCollection.m_QVectorGeometry">
@brief Geometry集合对象

</member>
        <member name="M:SysGeometry.GeometryCollection.Scale(SysUtility._ptr_t&lt;SysGeometry.Point&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
@brief 缩放
@param[in] PointPtr originPoint 参照点
@param[in] double sx x方向缩放
@param[in] double sy y方向缩放
@return bool 是否成功

</member>
        <member name="M:SysGeometry.GeometryCollection.Rotate(SysUtility._ptr_t&lt;SysGeometry.Point&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
@brief 旋转
@param[in] PointPtr originPoint 参照点
@param[in] double rotationAngle 旋转角度
@return bool 是否成功

</member>
        <member name="M:SysGeometry.GeometryCollection.Move(System.Double,System.Double)">
@brief 移动
@param[in] double dx x方向的偏移
@param[in] double dy y方向的偏移
@return bool 是否成功

</member>
        <member name="M:SysGeometry.GeometryCollection.Transform(SysUtility._ptr_t&lt;SysGeometry.CoordinateTransformation&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 投影转换（会忽略原来的空间参考）
@param[in] CoordinateTransformationPtr ptrCT 坐标转换对象
@return bool 是否转换成功

</member>
        <member name="M:SysGeometry.GeometryCollection.Centroid">
@brief 获得质点
@return GeometryPtr 质点指针

</member>
        <member name="M:SysGeometry.GeometryCollection.GetEnvelope">
@brief 获得空间范围
@return GeometryPtr 空间范围对象指针

</member>
        <member name="M:SysGeometry.GeometryCollection.IsValid">
@brief 是否是有效的
@return bool 是否是有效的

</member>
        <member name="M:SysGeometry.GeometryCollection.IsSimple">
@brief 是否是简单几何形状
@return bool 是否是简单几何形状

</member>
        <member name="M:SysGeometry.GeometryCollection.IsEmpty">
@brief 是否为空
@return bool 是否为空

</member>
        <member name="M:SysGeometry.GeometryCollection.SetEmpty">
@brief 设置为空
@return bool

</member>
        <member name="M:SysGeometry.GeometryCollection.ClearGeometries">
@brief 清除Geometry
@return bool 是否成功

</member>
        <member name="M:SysGeometry.GeometryCollection.GetGeometry(System.Int32)">
@brief 获得Geometry对象
@param[in] int index 移除的编号
@return GeometryPtr Geometry指针

</member>
        <member name="M:SysGeometry.GeometryCollection.RemoveGeometry(System.Int32)">
@brief 移除Geometry对象
@param[in] int index 移除的编号
@return bool 是否成功

</member>
        <member name="M:SysGeometry.GeometryCollection.InsertGeometry(System.Int32,SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 插入Geometry对象
@param[in] int index 插入的编号
@param[in] GeometryPtr ptrGeo Geometry智能指针
@return bool 是否成功

</member>
        <member name="M:SysGeometry.GeometryCollection.AddGeometry(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 增加Geometry对象
@param[in] GeometryPtr ptrGeo Geometry智能指针
@return bool 是否成功

</member>
        <member name="M:SysGeometry.GeometryCollection.GetGeometryCount">
@brief 获得Geometry的总个数
@return int 图形Geometry的总个数

</member>
        <member name="M:SysGeometry.GeometryCollection.Dispose">
@brief 析构函数
@return

</member>
        <member name="M:SysGeometry.GeometryCollection.#ctor">
@brief 构造函数
@return

</member>
        <member name="T:SysGeometry.GeometryCollection">
@class GeometryCollection
	* @brief 图形集合

</member>
        <member name="D:SysDisplay.MarkerSymbolPtr">
@brief 点符号样式 智能指针对象

</member>
        <member name="F:SysDisplay.MarkerSymbol.m_Brush">
@brief 画刷

</member>
        <member name="F:SysDisplay.MarkerSymbol.m_YOffset">
@brief Y方向偏移

</member>
        <member name="F:SysDisplay.MarkerSymbol.m_XOffset">
@brief X方向偏移

</member>
        <member name="F:SysDisplay.MarkerSymbol.m_Color">
@brief 点颜色

</member>
        <member name="F:SysDisplay.MarkerSymbol.m_Angle">
@brief 点角度

</member>
        <member name="F:SysDisplay.MarkerSymbol.m_Size">
@brief 点大小

</member>
        <member name="M:SysDisplay.MarkerSymbol.Dispose">
@brief 构造函数
@return

</member>
        <member name="M:SysDisplay.MarkerSymbol.#ctor">
@brief 构造函数
@return

</member>
        <member name="M:SysDisplay.MarkerSymbol.QueryBoundary(SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 查询外接多边形
@param [in] ptrDisplayTransformation
@param [in] ptrGeometry
@return 外接多边形对象

</member>
        <member name="M:SysDisplay.MarkerSymbol.SetYOffset(System.Double)">
@brief 设置点Y方向的偏移值
@param[in] double offset Y方向偏移值
@return void

</member>
        <member name="M:SysDisplay.MarkerSymbol.GetYOffset">
@brief 获得点Y方向的偏移值
@return double Y方向偏移值

</member>
        <member name="M:SysDisplay.MarkerSymbol.SetXOffset(System.Double)">
@brief 设置点X方向的偏移值
@param[in] double offset X方向偏移值
@return void

</member>
        <member name="M:SysDisplay.MarkerSymbol.GetXOffset">
@brief 获得点X方向偏移值
@return double X方向偏移值

</member>
        <member name="M:SysDisplay.MarkerSymbol.SetSize(System.Double)">
@brief 设置点大小
@param[in] double size 点大小
@return void

</member>
        <member name="M:SysDisplay.MarkerSymbol.GetSize">
@brief 获得点大小
@return double 点大小

</member>
        <member name="M:SysDisplay.MarkerSymbol.SetColor(QColor)">
@brief 设置点颜色
@param[in] QColor color 设置点颜色
@return void

</member>
        <member name="M:SysDisplay.MarkerSymbol.GetColor">
@brief 获得点颜色
@return QColor 点颜色

</member>
        <member name="M:SysDisplay.MarkerSymbol.SetAngle(System.Double)">
@brief 设置旋转角度值
@param[in] double angle 旋转角度值
@return void

</member>
        <member name="M:SysDisplay.MarkerSymbol.GetAngle">
@brief 获得旋转角度值
@return double 旋转角度值

</member>
        <member name="T:SysDisplay.MarkerSymbol">
@class MarkerSymbol
	* @brief  点符号样式

</member>
        <member name="F:SysCarto.IGridLabel.m_LabelAlignment">
@brief 标签准线数组

</member>
        <member name="F:SysCarto.IGridLabel.m_dLabelOffset">
@brief 标签偏移量  (单位：厘米)

</member>
        <member name="F:SysCarto.IGridLabel.m_ptrTextSymbol">
@brief 文本符号

</member>
        <member name="M:SysCarto.IGridLabel.GetValueDescription(System.Double,System.Boolean)">
@brief 获取值描述
@param [in] dLabelValue  标签值
@param [in] isLat  是否为纬度
@return QString 值描述

</member>
        <member name="M:SysCarto.IGridLabel.CopyTo(SysCarto.IGridLabel*)">
@brief 拷贝到IGridLabel
@param [in] IGridLabel* pGridLabel  网格标签对象
@return void

</member>
        <member name="M:SysCarto.IGridLabel.GetTextSymbol">
@brief 获取文本符号
@return 	SysDisplay::TextSymbolPtr 文本符号

</member>
        <member name="M:SysCarto.IGridLabel.SetTextSymbol(SysUtility._ptr_t&lt;SysDisplay.TextSymbol&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置文本符号
@param [in] ptrTextSymbol  文本符号
@return void

</member>
        <member name="M:SysCarto.IGridLabel.Clone">
@brief 克隆
@return  IGridLabelPtr  网格标签对象

</member>
        <member name="M:SysCarto.IGridLabel.GetLabelOffset">
@brief 获取标签偏移
@return double 标签偏移

</member>
        <member name="M:SysCarto.IGridLabel.SetLabelOffset(System.Double)">
@brief 设置标签偏移 （The offset of the grid label from the border in points.）
@param [in] dOffset  偏移量
@return void

</member>
        <member name="M:SysCarto.IGridLabel.GetLabelAlignment(SysCarto.pieGridAxisEnum)">
@brief 获取标签准线  
@param [in] enumAxis  网格轴心枚举量
@return bool 是否成功

</member>
        <member name="M:SysCarto.IGridLabel.SetLabelAlignment(SysCarto.pieGridAxisEnum,System.Boolean)">
@brief 设置标签准线  （Indicates if the grid label is horizontal (true) or vertical (false) on the specified axis. ）
@param [in] enumAxis  网格轴心枚举量
@param [in] bHorizontal  是否水平
@return void

</member>
        <member name="M:SysCarto.IGridLabel.GetFont">
@brief 获取字体
@return QFont 字体

</member>
        <member name="M:SysCarto.IGridLabel.SetFont(QFont!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置字体  （The font used by the grid label.）
@param [in] font 字体
@return void

</member>
        <member name="M:SysCarto.IGridLabel.Draw(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,SysUtility._ptr_t&lt;SysGeometry.Point&gt;!System.Runtime.CompilerServices.IsConst,SysCarto.pieGridAxisEnum,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
@brief  绘制
@param [in] painter     绘图设备
@param [in] dLabelValue 标签值
@param [in] ptrPoint    点对象
@param [in] enumAxis    pie网格轴心枚举量
@param [in] ptrTrans    显示转换对象
@param [in] isLat       是否为纬度
@return    void

</member>
        <member name="M:SysCarto.IGridLabel.GetColor">
@brief 获取颜色 
@return QColor 颜色

</member>
        <member name="M:SysCarto.IGridLabel.SetColor(QColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置颜色 （//The color of the grid label.）
@param [in] color 颜色
@return void

</member>
        <member name="M:SysCarto.IGridLabel.Dispose">
@brief 析构函数

</member>
        <member name="M:SysCarto.IGridLabel.#ctor">
@brief 构造函数

</member>
        <member name="T:SysCarto.GridlabelSerializer">
@brief 声明网格标签序列化类为当前类的友元类

</member>
        <member name="T:SysCarto.IGridLabel">
@brief 类的前置声明和智能指针定义


@class IGridLabel
@brief 网格标签

</member>
        <member name="T:SysCarto.pieGridAxisEnum">
@class pieGridAxisEnum
@brief pie网格轴心枚举

</member>
        <member name="F:pieGridAxisRight">
@brief 右侧轴心

</member>
        <member name="F:pieGridAxisLeft">
@brief 左侧轴心

</member>
        <member name="F:pieGridAxisBottom">
@brief 底部轴心

</member>
        <member name="F:pieGridAxisTop">
@brief 无轴心

@brief 顶部轴心

</member>
        <member name="D:SysDisplay.TextSymbolPtr">
@brief  文字符号类 智能指针对象

</member>
        <member name="F:SysDisplay.TextSymbol.m_Alignment">
@brief 文本对齐方式

</member>
        <member name="F:SysDisplay.TextSymbol.m_Text">
@brief 文字内容

</member>
        <member name="F:SysDisplay.TextSymbol.m_Size">
@brief 文字大小

</member>
        <member name="F:SysDisplay.TextSymbol.m_Font">
@brief 文字字体

</member>
        <member name="F:SysDisplay.TextSymbol.m_Color">
@brief 文字颜色

</member>
        <member name="F:SysDisplay.TextSymbol.m_Angle">
@brief 文字旋转角度

</member>
        <member name="M:SysDisplay.TextSymbol.QueryBoundary(SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 查询符号外接多边形
@param [in] ptrDisplayTransformation
@param [in] ptrGeometry
@return 符号外接多边形对象

</member>
        <member name="M:SysDisplay.TextSymbol.SetAlignment(SysDisplay.TextAlignment)">
@brief 设置文本对齐方式
@param[in] SysDisplay::TextAlignment alignment 文本对齐方式
@return void

</member>
        <member name="M:SysDisplay.TextSymbol.GetAlignment">
@brief 获得文本对齐方式
@return SysDisplay::TextAlignment 文本对齐方式

</member>
        <member name="M:SysDisplay.TextSymbol.SetText(QString)">
@brief 设置文字
@param[in] QString text 文字
@returnvoid

</member>
        <member name="M:SysDisplay.TextSymbol.GetText">
@brief 获得文字
@return QString 文字

</member>
        <member name="M:SysDisplay.TextSymbol.SetSize(System.Double)">
@brief 设置大小
@param[in] double size 大小
@return void

</member>
        <member name="M:SysDisplay.TextSymbol.GetSize">
@brief 获得大小
@return double

</member>
        <member name="M:SysDisplay.TextSymbol.SetFont(QFont)">
@brief 设置字体
@param[in] QFont font 字体
@return void

</member>
        <member name="M:SysDisplay.TextSymbol.GetFont">
@brief 获得字体
@return QFont 字体

</member>
        <member name="M:SysDisplay.TextSymbol.SetColor(QColor)">
@brief 设置颜色
@param[in] QColor color 颜色
@return void

</member>
        <member name="M:SysDisplay.TextSymbol.GetColor">
@brief 获得颜色
@return QColor 颜色

</member>
        <member name="M:SysDisplay.TextSymbol.SetAngle(System.Double)">
@brief 设置角度
@param[in] double angle 角度
@return void

</member>
        <member name="M:SysDisplay.TextSymbol.GetAngle">
@brief 获得角度
@return double 角度

</member>
        <member name="M:SysDisplay.TextSymbol.Dispose">
@brief 析构函数
@return

</member>
        <member name="M:SysDisplay.TextSymbol.#ctor">
@brief 构造函数
@return

</member>
        <member name="T:SysDisplay.TextSymbol">
@class TextSymbol
	* @brief 文本符号

</member>
        <member name="D:SysCarto.MapPtr">
@brief  地图 智能指针对象

</member>
        <member name="F:SysCarto.Map.m_pSelectionModel">
@brief 选择集处理模型

</member>
        <member name="F:SysCarto.Map.m_pLabelModel">
@brief 标签处理模型

</member>
        <member name="F:SysCarto.Map.m_pThreadModel">
@brief 处理线程

</member>
        <member name="F:SysCarto.Map.m_ptrProcessTrans">
@brief 处理转换

</member>
        <member name="F:SysCarto.Map.m_bPanWithoutDispatch">
@brief  是否显示标签

@brief  是否设置为拖屏的时候不再调度瓦片的加载

</member>
        <member name="F:SysCarto.Map.m_bFeatureSelectionChanged">
@brief  要素选择是否改变

</member>
        <member name="F:SysCarto.Map.m_ptrClipGeometry">
@brief  裁剪几何

</member>
        <member name="F:SysCarto.Map.m_dMapScale">
@brief  地图比例

</member>
        <member name="F:SysCarto.Map.m_dReferenceScale">
@brief   地图单元

@brief  参考比例

</member>
        <member name="F:SysCarto.Map.m_ptrSRef">
@brief  空间参考

</member>
        <member name="F:SysCarto.Map.m_vecLayers">
@brief  图层集合

</member>
        <member name="F:SysCarto.Map.m_strName">
@brief  名字

</member>
        <member name="F:SysCarto.Map.m_strID">
@brief  编号ID

</member>
        <member name="M:SysCarto.Map.GetLayerPositionInLayer(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysCarto.Layer&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  获得图层位置（上级图层下，递归函数）
@param [in] pInTopLyr  上级图层
@param [in] pInLyr     输入图层
@param [out] pParentLayer   输出图层（直接上级）
@param [out] nIndex   输出索引位置（组图层下、多图层下）
@return 是否成功

</member>
        <member name="M:SysCarto.Map.GetRenderTransformation">
@brief  获取主线程显示转换(布局中地图显示转换参数需要重新调整)
@return 是否成功

</member>
        <member name="M:SysCarto.Map.DeleteLayerInternal(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  删除图层
@param [in] ptrLayer  图层
@return 是否成功

</member>
        <member name="M:SysCarto.Map.AddLayerInternal(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief  添加图层
@param [in] ptrLayer  图层
@param [in] index     图层编号
@return 是否成功

</member>
        <member name="M:SysCarto.Map.OnSelectionChanged">
@brief  图层选择改变信号槽函数
@return void

</member>
        <member name="M:SysCarto.Map.GetRasterLayerNativeResExtent(SysUtility._ptr_t&lt;SysCarto.RasterLayer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  获取栅格图层本地资源范围
@param [in] ptrLayer  栅格图层
@return SysGeometry::EnvelopePtr  包络线范围

</member>
        <member name="M:SysCarto.Map.GetSpatialReferenceByLayer(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 通过图层获取空间参考
@param [in] ptrLayer 图层
@return  SysGeometry::SpatialReferencePtr  空间参考

</member>
        <member name="M:SysCarto.Map.DeleteLayerFromSubLayer(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 从子图层中删除图层
@param [in] ptrLayer 图层
@param [in] ptrSubLayer  子图层
@return  bool  是否成功

</member>
        <member name="M:SysCarto.Map.FindLayerByID(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 通过ID查找图层
@param [in] ptrLayer 图层
@param [in] layerID  图层ID
@return  LayerPtr    图层

</member>
        <member name="M:SysCarto.Map.SetProperty">
@brief 标签渲染完成
@return  void

@brief 激活标签渲染
@return  void

@brief 重置属性
@return  void

</member>
        <member name="M:SysCarto.Map.ResetContentImage">
@brief 重置内容图片
@return  void

</member>
        <member name="M:SysCarto.Map.OnNotifyUpdate">
@brief 通知更新槽函数
@return  void 

</member>
        <member name="M:SysCarto.Map.CopyTo(SysCarto.Map*)">
@brief 拷贝到Map
@param[in] Map* Map对象

</member>
        <member name="M:SysCarto.Map.TransformContainterElements(SysUtility._ptr_t&lt;SysGeometry.SpatialReference&gt;,SysUtility._ptr_t&lt;SysCarto.Layer&gt;)">
@brief 转换包含的元素集
@param [in] ptrSRef   空间参考
@param [in] ptrLayer  图层
@return void

</member>
        <member name="M:SysCarto.Map.SetPanWithoutDispatch(System.Boolean)">
@brief 设置为拖屏的时候不再调度瓦片的加载 （局部拉伸需要用到这个接口）
@param [in] bValue  是否调用
@return void

</member>
        <member name="M:SysCarto.Map.DeleteSelectionCache">
@brief 释放选择集缓存
@return void

</member>
        <member name="M:SysCarto.Map.IsRendering">
@brief  是否在渲染
@return bool  是 true, 否 false

</member>
        <member name="M:SysCarto.Map.ProcessTask(SysCarto.RenderTask*)">
@brief 
@param [in] pRenderTask 
@return 

</member>
        <member name="M:SysCarto.Map.Render(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysUI.TrackerCancel&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 底层渲染接口
@param [in] painter 
@param [in] ptrTracker 
@return 

</member>
        <member name="M:SysCarto.Map.Clone">
@brief 克隆
@return MapPtr 当前地图的克隆对象

</member>
        <member name="M:SysCarto.Map.ZoomAction(QPoint,System.Double,System.Double)">
@brief 缩放
@param [in] QPoint centerPos 缩放中心点
@param [in] double dScaleX X方向缩放率
@param [in] double dScaleY Y方向缩放率
@return 

</member>
        <member name="M:SysCarto.Map.StartDrawing">
@brief 开始绘制
@return void

</member>
        <member name="M:SysCarto.Map.Draw(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysUI.TrackerCancel&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制
@param [in] paiter 绘图面板
@param [in] ptrTracker 取消追踪对象
@return void

</member>
        <member name="M:SysCarto.Map.DeleteRenderCacheBlocks(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 删除渲染缓存块
@param [in] strLayerID   图层ID
@return  void

</member>
        <member name="M:SysCarto.Map.GetRenderedImageLayer(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 获取渲染图片图层
@param [in] strLayerID   图层ID
@return  QImage  图片

</member>
        <member name="M:SysCarto.Map.SwipeLayer(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,QPoint,QPoint,System.Int32)">
@brief 卷帘图层 
@param [in] ptrLayer   图层
@param [in] startPos   开始点
@param [in] currPoint  当前点
@param [in] direction  方向
@return  void

</member>
        <member name="M:SysCarto.Map.StopRender">
@brief 停止渲染
@return  void

</member>
        <member name="M:SysCarto.Map.PanRefresh(System.Boolean)">
@brief 漫游刷新
@param [in] bForceActive  是否强制激活
@return  void

</member>
        <member name="M:SysCarto.Map.InvalidLayerCache(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置无效的图层缓存
@param [in] ptrLayer  图层
@return  void

</member>
        <member name="M:SysCarto.Map.Refresh(System.Boolean,System.Boolean)">
@brief 刷新
@param [in] bClearCache  是否清空缓存
@param [in] bFroceRefresh  是否强制刷新
@return  void

</member>
        <member name="M:SysCarto.Map.PartialRefresh(SysCarto.ViewDrawPhaseType,System.Boolean)">
@brief 局部刷新
@param [in] dpType  刷新类型
@param [in] bMakeAllCacheDirty  是否强力刷新
@return  void

</member>
        <member name="M:SysCarto.Map.GetContentImage(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 获取内容图片
@param [in out] painter  绘图对象
@return  void 

</member>
        <member name="M:SysCarto.Map.GetContentImage">
@brief 获取内容图片
@return  QImage    图片对象

</member>
        <member name="M:SysCarto.Map.SetFullExtent(SysUtility._ptr_t&lt;SysGeometry.Envelope&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置全局范围
@param [in] ptrEnv  包络线范围
@return  void

</member>
        <member name="M:SysCarto.Map.GetFullExtent">
@brief 获取全局范围
@return  SysGeometry::EnvelopePtr    包络线范围

</member>
        <member name="M:SysCarto.Map.SetExtent(SysUtility._ptr_t&lt;SysGeometry.Envelope&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置范围
@param [in] ptrEnv  包络线范围
@return  void

</member>
        <member name="M:SysCarto.Map.GetExtent">
@brief 获取范围
@return  SysGeometry::EnvelopePtr    包络线范围

</member>
        <member name="M:SysCarto.Map.HitTestMap(SysUtility._ptr_t&lt;SysGeometry.Point&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 点击测试地图
@param [in] point  几何点
@return  MapPtr    地图对象

</member>
        <member name="M:SysCarto.Map.SetFocusMap(SysUtility._ptr_t&lt;SysCarto.Map&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置焦点地图
@param [in] ptrMap  焦点地图
@return  void

</member>
        <member name="M:SysCarto.Map.GetFocusMap">
@brief 获取焦点地图
@return  MapPtr  地图对象

</member>
        <member name="M:SysCarto.Map.Activate(QPaintDevice*)">
@brief 激活视图
@param [in] pDevice 视图绘制设备对象
@return  void

</member>
        <member name="M:SysCarto.Map.UnSelectFeatures(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,QList&lt;System.Int64&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief   取消选中的要素集
@param [in] strLayerID     图层ID
@param [in] lstFIDs        fid编号集合
@return    void

</member>
        <member name="M:SysCarto.Map.UnSelectFeature(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int64)">
@brief   取消选中的要素
@param [in] strLayerID     图层ID
@param [in] fid            fid编号
@return    void

</member>
        <member name="M:SysCarto.Map.UnSelectFeatures(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,QList&lt;SysUtility._ptr_t&lt;SysDataSource.Feature&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief   取消选中的要素集
@param [in] ptrLayer     图层
@param [in] ptrFeature   要素集合
@return    void

</member>
        <member name="M:SysCarto.Map.UnSlectFeature(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDataSource.Feature&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief   取消选中的要素
@param [in] ptrLayer     图层
@param [in] ptrFeature   要素
@return    void

</member>
        <member name="M:SysCarto.Map.ClearSelectionFeatures">
@brief   清空选中的要素集
@return    void

</member>
        <member name="M:SysCarto.Map.SelectionFeatureCount">
@brief   获取选中的要素数量
@return  int     要素数量

</member>
        <member name="M:SysCarto.Map.GetSelectionFeaturesCount">
@brief   获取选中的要素集数量
@return  int   要素集数量

</member>
        <member name="M:SysCarto.Map.SelectFeatures(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,QList&lt;System.Int64&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief   选择要素集
@param [in] strLayerID      图层ID
@param [in] lstFIDs         fid编号集合
@return    void

</member>
        <member name="M:SysCarto.Map.SelectFeature(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int64)">
@brief   选择要素
@param [in] strLayerID     图层ID
@param [in] fid    fid编号
@return    void

</member>
        <member name="M:SysCarto.Map.SelectFeatures(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,QList&lt;SysUtility._ptr_t&lt;SysDataSource.Feature&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief   选择要素集
@param [in] ptrLayer      图层
@param [in] lstFeatures   要素集合
@return    void

</member>
        <member name="M:SysCarto.Map.SelectFeature(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDataSource.Feature&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief   选择要素
@param [in] ptrLayer     图层
@param [in] ptrFeature   要素
@return    void

</member>
        <member name="M:SysCarto.Map.SelectFeatureByShape(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,QList&lt;SysUtility._ptr_t&lt;SysCarto.Layer&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
@brief   通过形状选择要素
@param [in] ptrGeo       几何对象
@param [in] queryLayers  查询的图层集合
@param [in] clearBefore  是否清除之前选择集 
@param [in] justOne      是否只选择一个 
@return    void

</member>
        <member name="M:SysCarto.Map.WaitForRenderFinished">
@brief 等待屏幕范围的瓦片缓存绘制完毕
@return  void

</member>
        <member name="M:SysCarto.Map.Output(SysUtility._ptr_t&lt;SysCarto.IExporter&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,QRect!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysGeometry.Envelope&gt;,SysUtility._ptr_t&lt;SysUI.TrackerCancel&gt;)">
@brief   输出
@param [in] exporter 输出对象
@param [in] nDpi     每英寸点数
@param [in] pixelBounds 像素点范围
@param [in] ptrVisBounds 可视边界范围
@param [in] ptrTracker   取消轨迹
@return    void

</member>
        <member name="M:SysCarto.Map.FromMapPoint(SysUtility._ptr_t&lt;SysGeometry.Point&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 从地图点转化为设备点
@param [in] SysGeometry::PointPtr ptrPoint 地图点
@return QPoint 设备点

</member>
        <member name="M:SysCarto.Map.ToMapPoint(QPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 从设备点转化为地图点
@param [in] QPoint point 设备点
@return  SysGeometry::PointPtr 地图点

</member>
        <member name="M:SysCarto.Map.SetClipGeometry(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  设置几何裁剪
@param  [in]  SysGeometry::GeometryPtr   几何对象
@return  void

</member>
        <member name="M:SysCarto.Map.GetClipGeometry">
@brief  获取几何裁剪
@return  SysGeometry::GeometryPtr   几何对象

</member>
        <member name="M:SysCarto.Map.SetMapScale(System.Double)">
@brief  设置地图比例
@param  [in]  scale  地图比例
@return  void

</member>
        <member name="M:SysCarto.Map.GetMapScale">
@brief  获取地图比例
@return  double   地图比例

</member>
        <member name="M:SysCarto.Map.SetMapUnits(SysUI.pieUnits)">
@brief  设置地图单元
@param  [in]  mapUnits  地图单元
@return  void

</member>
        <member name="M:SysCarto.Map.GetMapUnits">
@brief  获取地图单元
@return  SysUI::pieUnits  地图单元

</member>
        <member name="M:SysCarto.Map.SetSpatialReference(SysUtility._ptr_t&lt;SysGeometry.SpatialReference&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  设置空间参考
@param  [in]  ptrSRef  空间参考
@return  void

</member>
        <member name="M:SysCarto.Map.GetSpatialReference">
@brief  获取空间参考 （坐标系）
@return  SysGeometry::SpatialReferencePtr  空间参考

</member>
        <member name="M:SysCarto.Map.FindLayerByID(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  通过ID发现图层
@param  [in]  layerID   图层ID
@return  LayerPtr 图层

</member>
        <member name="M:SysCarto.Map.GetLayer(System.Int32)">
@brief  获取图层
@param [in]  index     索引
@return  LayerPtr 图层

</member>
        <member name="M:SysCarto.Map.GetLayerCount">
@brief   获取图层数量
@return  int  图层数量

</member>
        <member name="M:SysCarto.Map.MoveLayerEx(SysUtility._ptr_t&lt;SysCarto.GroupLayer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysCarto.GroupLayer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief  移动图层扩展
@param [in]  ptrFormGLayer   组图层源数据
@param [in]  ptrToGLayer     组图层目标数据
@param [in]  ptrLayer        图层
@param [in]  newPosition     新位置
@return  void

</member>
        <member name="M:SysCarto.Map.MoveLayer(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief  移动图层
@param [in]  ptrLayer   图层
@param [in]  toIndex    索引
@return  void

</member>
        <member name="M:SysCarto.Map.GetLayerPosition(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysCarto.Layer&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  获得图层位置
@param [in]  pInLyr   输入图层
@param [out] pParentLyr  输出父图层（组图层、多图层、NULL）
@param [out] nIndex   输出索引位置（组图层、多图层、Map）
@return  void

</member>
        <member name="M:SysCarto.Map.Contains(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  是否包含某图层
@param [in]  ptrLayer   图层
@return  bool 是否包含  是 true,否 false

</member>
        <member name="M:SysCarto.Map.ClearLayers">
@brief  清空图层集
@return  void

</member>
        <member name="M:SysCarto.Map.DeleteLayers(QList&lt;SysUtility._ptr_t&lt;SysCarto.Layer&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  删除图层集
@param [in]  vecLayers   图层集合
@return  void

</member>
        <member name="M:SysCarto.Map.DeleteLayer(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  删除图层
@param [in]  ptrLayer   图层
@return  void

</member>
        <member name="M:SysCarto.Map.DeleteLayer(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  删除图层
@param [in]  sLyrId    图层ID
@return  void

</member>
        <member name="M:SysCarto.Map.DeleteLayer(System.Int32)">
@brief  删除图层
@param [in]  index     索引
@return  void

</member>
        <member name="M:SysCarto.Map.AddLayers(QList&lt;SysUtility._ptr_t&lt;SysCarto.Layer&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief  添加图层集
@param [in]  vecLayers  图层集
@param [in]  index     索引
@return  void

</member>
        <member name="M:SysCarto.Map.AddLayer(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief  添加图层
@param [in]  ptrLayer  图层
@param [in]  index     索引
@return  void

</member>
        <member name="M:SysCarto.Map.AddLayers(QList&lt;SysUtility._ptr_t&lt;SysCarto.Layer&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  添加图层集
@param [in]  vecLayers  图层集
@return  void

</member>
        <member name="M:SysCarto.Map.AddLayer(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  添加图层
@param [in]  ptrLayer  图层
@return  void

</member>
        <member name="M:SysCarto.Map.SetName(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  设置名字
@param [in]  name  名字
@return  void

</member>
        <member name="M:SysCarto.Map.GetName">
@brief   获取名字
@return  QString  名字

</member>
        <member name="M:SysCarto.Map.SetID(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  设置地图ID
@param [in]  strID  地图ID
@return  void

</member>
        <member name="M:SysCarto.Map.GetID">
@brief   获取地图ID
@return  QString  地图ID

</member>
        <member name="M:SysCarto.Map.Dispose">
@brief 析构函数

</member>
        <member name="M:SysCarto.Map.#ctor(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 构造函数
@param [in] mapName 默认参数 地图名称

</member>
        <member name="T:SysCarto.CacheBlockManager">
@brief  声明友元类缓存块管理类 为当前类的友元类

</member>
        <member name="T:SysCarto.RenderTask">
@brief  类的前置声明 

</member>
        <member name="D:SysCarto.RasterLayerPtr">
@brief 栅格图层  智能指针对象

</member>
        <member name="F:SysCarto.RasterLayer.m_ptrRender">
@brief 栅格渲染

</member>
        <member name="F:SysCarto.RasterLayer.m_ptrDataset">
@brief 栅格数据

</member>
        <member name="M:SysCarto.RasterLayer.CopyTo(SysCarto.Layer*)">
@brief 拷贝到Layer
@param[in] Layer* Layer对象

</member>
        <member name="M:SysCarto.RasterLayer.Refresh">
@brief 刷新
@return void

</member>
        <member name="M:SysCarto.RasterLayer.IsValid">
@brief 是否是有效图层
@return  bool  是否是有效

</member>
        <member name="M:SysCarto.RasterLayer.Clone">
@brief 克隆
@return LayerPtr 克隆图层对象

</member>
        <member name="M:SysCarto.RasterLayer.RaiseRenderChanged">
@brief 提升渲染改变
@return void

</member>
        <member name="M:SysCarto.RasterLayer.Draw(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUI.LayerDrawPhaseType,SysUtility._ptr_t&lt;SysUI.TrackerCancel&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制
@param [in] paiter 绘图面板
@param [in] ptrTrasform 显示转换对象
@param [in] dpType 绘制图层相应类型对象
@param [in] ptrTracker 取消追踪对象
@return void

</member>
        <member name="M:SysCarto.RasterLayer.SetRenderer(SysUtility._ptr_t&lt;SysCarto.RasterRender&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置渲染
@param [in] ptrRender 栅格渲染
@return void

</member>
        <member name="M:SysCarto.RasterLayer.SetDataset(SysUtility._ptr_t&lt;SysDataSource.RasterDataset&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置数据集
@param [in] ptrDataset 栅格数据集
@return void

</member>
        <member name="M:SysCarto.RasterLayer.GetExtent">
@brief 获取范围
@return  SysGeometry::EnvelopePtr    包络线范围

</member>
        <member name="M:SysCarto.RasterLayer.Dispose">
@brief 析构函数

</member>
        <member name="M:SysCarto.RasterLayer.#ctor(SysCarto.LayerCacheModelType)">
@brief 构造函数

</member>
        <member name="T:SysCarto.RasterLayer">
@class RasterLayer
@brief  栅格图层

</member>
        <member name="F:SysCarto.RasterRender.m_bHaveNodate">
@brief 有Nodate数组

</member>
        <member name="F:SysCarto.RasterRender.m_pdNodata">
@brief Nodata数组

</member>
        <member name="F:SysCarto.RasterRender.m_bNeedUpdataLutInfo">
@brief 需要更新Lut的信息

</member>
        <member name="F:SysCarto.RasterRender.m_ppBufferLut">
@brief 像素点缓冲数组

</member>
        <member name="F:SysCarto.RasterRender.m_vecBands">
@brief 波段集合

</member>
        <member name="F:SysCarto.RasterRender.m_resampType">
@brief 栅格重采样类型 

</member>
        <member name="F:SysCarto.RasterRender.m_ResolutionFactor">
@brief 分辨率因子

</member>
        <member name="F:SysCarto.RasterRender.m_bCanRender">
@brief 是否可以渲染

</member>
        <member name="F:SysCarto.RasterRender.m_strDesc">
@brief 描述信息

</member>
        <member name="F:SysCarto.RasterRender.m_RRType">
@brief 栅格渲染类型

</member>
        <member name="F:SysCarto.RasterRender.m_strName">
@brief 名称

</member>
        <member name="M:SysCarto.RasterRender.#ctor">
@brief 构造函数

</member>
        <member name="M:SysCarto.RasterRender.UpdateBrightnessContrast">
@brief 更新亮度反转
@return  void

</member>
        <member name="M:SysCarto.RasterRender.RefreshRenderInfo(SysUtility._ptr_t&lt;SysDataSource.RasterDataset&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 刷新渲染信息
@param [in] ptrDataset 栅格数据集
@return  void

</member>
        <member name="M:SysCarto.RasterRender.GetTransParent">
@brief 获取透明度
@return  int 透明度

</member>
        <member name="M:SysCarto.RasterRender.SetTransParent(System.Int32)">
@brief 设置透明度
@param [in] nValue 透明度
@return  void

</member>
        <member name="M:SysCarto.RasterRender.GetBrightnessInverse">
@brief 获取亮度反转
@return  bool 是否设置亮度反转

</member>
        <member name="M:SysCarto.RasterRender.SetBrightnessInverse(System.Boolean)">
@brief 设置亮度反转
@param [in] bValue 是否设置亮度反转
@return  void

</member>
        <member name="M:SysCarto.RasterRender.GetContrast">
@brief 获取对比度
@return  int 对比度

</member>
        <member name="M:SysCarto.RasterRender.SetContrast(System.Int32)">
@brief 设置对比度
@param [in] nValue 对比度
@return  void

</member>
        <member name="M:SysCarto.RasterRender.GetBrightness">
@brief 获取亮度
@return  int 亮度值

</member>
        <member name="M:SysCarto.RasterRender.SetBrightness(System.Int32)">
@brief 设置亮度
@param [in] nValue 亮度值
@return  void

</member>
        <member name="M:SysCarto.RasterRender.Clone">
@brief 克隆
@return RasterRenderPtr 克隆栅格渲染对象

</member>
        <member name="M:SysCarto.RasterRender.DoColorMap(SysUtility._ptr_t&lt;SysDataSource.PixelBuffer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Byte*,System.Byte*,System.Int32,System.Int32)">
@brief 为地图着色
@param [in]  ptrPixelBufferIn   像素缓冲
@param [in]  pRenderBlock       渲染数据块
@param [in]  pDataMask       数据模板
@param [in]  nWidth       宽
@param [in]  nHeight      高
@return  void

</member>
        <member name="M:SysCarto.RasterRender.GetRenderBytes(SysUtility._ptr_t&lt;SysDataSource.RasterDataset&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysGeometry.Envelope&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,SysUtility._ptr_t&lt;SysUI.TrackerCancel&gt;)">
@brief 获取渲染字节集
@param [in]  ptrDataset  栅格数据集
@param [in]  ptrEnvelope 包络线范围
@param [in]  nWidth       宽
@param [in]  nHeight      高
@param [in]  ptrTrack     取消追踪对象
@return  uchar*  渲染字节集

</member>
        <member name="M:SysCarto.RasterRender.PrepareRender(SysUtility._ptr_t&lt;SysDataSource.RasterDataset&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysGeometry.Envelope&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 准备渲染
@param [in]  ptrDataset   栅格数据集
@param [in]  ptrVisEnv    可视包络线范围
@return  void

</member>
        <member name="M:SysCarto.RasterRender.Draw(SysUtility._ptr_t&lt;SysDataSource.RasterDataset&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUI.LayerDrawPhaseType,SysUtility._ptr_t&lt;SysUI.TrackerCancel&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制
@param [in] ptrDataset 栅格数据集
@param [in] paiter 绘图面板
@param [in] ptrTrasform 显示转换对象
@param [in] dpType 绘制图层相应类型对象
@param [in] tracker 取消追踪对象
@return void

</member>
        <member name="M:SysCarto.RasterRender.SetResamplingType(SysCarto.RasterResamplingType)">
@brief 设置栅格重采样类型 
@param [in] RasterResamplingType resampType  栅格重采样类型
@return  void

</member>
        <member name="M:SysCarto.RasterRender.GetResamplingType">
@brief 获取栅格重采样类型 
@return  RasterResamplingType  栅格重采样类型

</member>
        <member name="M:SysCarto.RasterRender.SetDisplayResolutionFactor(System.Int32)">
@brief 设置分辨率因子 
@param [in] factor 分辨率因子
@return  void

</member>
        <member name="M:SysCarto.RasterRender.GetDisplayResolutionFactor">
@brief 获取分辨率因子 
@return  int  分辨率因子 

</member>
        <member name="M:SysCarto.RasterRender.CanRender">
@brief 是否可以渲染
@return  bool  是否可以

</member>
        <member name="M:SysCarto.RasterRender.GetDescription">
@brief 获取描述信息
@return  QString  描述信息

</member>
        <member name="M:SysCarto.RasterRender.GetName">
@brief 获取名字
@return  QString  名字

</member>
        <member name="M:SysCarto.RasterRender.Dispose">
@brief 析构函数

</member>
        <member name="T:SysCarto.RasterRender">
@brief  类的前置声明 和智能指针定义


@class RasterRender
@brief  栅格渲染

</member>
        <member name="T:SysCarto.RasterRenderType">
@class RasterRenderType
@brief 矢量渲染器类型 枚举

</member>
        <member name="F:RRT_RasterDiscreteColorRender">
@brief 点密度渲染

</member>
        <member name="F:RRT_RasterColormapRender">
@brief 颜色对照表渲染

</member>
        <member name="F:RRT_RasterUniqueValueRender">
@brief 唯一值渲染

</member>
        <member name="F:RRT_RasterClassifyColorRampRender">
@brief 分级渲染

</member>
        <member name="F:RRT_RasterStretchColorRampRender">
@brief 拉伸颜色带渲染

</member>
        <member name="F:RRT_RasterRGBRender">
@brief RGB渲染

</member>
        <member name="F:RRT_Unknown">
@brief 未知渲染类型

</member>
        <member name="F:SysCarto.IRasterFilterProps.m_lstAfterFilter">
@brief   后置栅格过滤器集合

</member>
        <member name="F:SysCarto.IRasterFilterProps.m_lstPreFilter">
@brief   前置栅格过滤器集合

</member>
        <member name="M:SysCarto.IRasterFilterProps.AddAfterRasterFilter(SysUtility._ptr_t&lt;SysCarto.AfterRasterFilter&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  添加后置栅格过滤器
@param  [in] ptrFilter    后置栅格过滤器
@return  void

</member>
        <member name="M:SysCarto.IRasterFilterProps.AddPreRasterFilter(SysUtility._ptr_t&lt;SysCarto.PreRasterFilter&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief   添加前置栅格过滤器
@param [in] ptrFilter    前置栅格过滤器
@return  void

</member>
        <member name="T:SysCarto.IRasterFilterProps">
@class IRasterFilterProps
@brief  栅格过滤器支持

</member>
        <member name="D:SysCarto.AfterRasterFilterPtr">
@brief  后置过滤器 智能指针对象

</member>
        <member name="M:SysCarto.AfterRasterFilter.#ctor">
@brief  构造函数

</member>
        <member name="M:SysCarto.AfterRasterFilter.Filter(SysUtility._ptr_t&lt;SysDataSource.PixelBuffer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Byte*,SysUtility._ptr_t&lt;SysGeometry.Envelope&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  过滤器
@param [in] memData 像素点缓冲数据
@param [in] pRenderData 渲染数据 
@param [in] ptrEnvelope 包络线范围
@return void

</member>
        <member name="M:SysCarto.AfterRasterFilter.Dispose">
@brief  析构函数

</member>
        <member name="T:SysCarto.AfterRasterFilter">
@class AfterRasterFilter
@brief  后置过滤器

</member>
        <member name="D:SysCarto.PreRasterFilterPtr">
@brief 栅格前置过滤器  智能指针

</member>
        <member name="M:SysCarto.PreRasterFilter.#ctor">
@brief 构造函数

</member>
        <member name="M:SysCarto.PreRasterFilter.Filter(SysUtility._ptr_t&lt;SysDataSource.PixelBuffer&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Byte*,SysUtility._ptr_t&lt;SysGeometry.Envelope&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 过滤器
@param [in] memData   像素缓冲元数据
@param [in] pDataMask 数据模型
@param [in] ptrEnvelope 包络线范围
@return void

</member>
        <member name="M:SysCarto.PreRasterFilter.FilterExtent(SysUtility._ptr_t&lt;SysDataSource.RasterDataset&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysGeometry.Envelope&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)">
@brief 过滤器扩展
@param [in] ptrDataset 数据集
@param [in] ptrEnvelope 包络线对象
@param [in] nWidth 宽度
@param [in] nHeight 高度
@return void

</member>
        <member name="M:SysCarto.PreRasterFilter.Dispose">
@brief 析构函数

</member>
        <member name="T:SysCarto.PreRasterFilter">
@class  PreRasterFilter
@brief  栅格前置过滤器

</member>
        <member name="F:SysCarto.RasterFilter.m_bUse">
@brief 栅格过滤器是否可用

</member>
        <member name="F:SysCarto.RasterFilter.m_FilterType">
@brief 栅格过滤器类型

</member>
        <member name="F:SysCarto.RasterFilter.m_strDesc">
@brief 描述

</member>
        <member name="F:SysCarto.RasterFilter.m_strName">
@brief 名称

</member>
        <member name="M:SysCarto.RasterFilter.#ctor">
@brief 构造函数

</member>
        <member name="M:SysCarto.RasterFilter.SetUsing(System.Boolean)">
@brief 设置栅格过滤器是否可用
@param [in]  bUse  是否可用
@return  void

</member>
        <member name="M:SysCarto.RasterFilter.IsUsing">
@brief 获取栅格过滤器是否可用 
@return  bool 栅格过滤器是否可用

</member>
        <member name="M:SysCarto.RasterFilter.GetFilterType">
@brief 获取过滤器类型
@return  RasterFilterType 栅格过滤器类型

</member>
        <member name="M:SysCarto.RasterFilter.SetDescription(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置描述
@param [in]  strDesc  描述信息
@return  void

</member>
        <member name="M:SysCarto.RasterFilter.GetDescription">
@brief 获取描述
@return  QString   描述

</member>
        <member name="M:SysCarto.RasterFilter.SetName(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置名字
@param [in]  strName  名字
@return  void

</member>
        <member name="M:SysCarto.RasterFilter.GetName">
@brief 获取名字
@return  QString   名字

</member>
        <member name="M:SysCarto.RasterFilter.Dispose">
@brief 析构函数

</member>
        <member name="T:SysCarto.RasterFilter">
@class  RasterFilter
@brief  栅格过滤器

</member>
        <member name="T:SysCarto.RasterFilterType">
@class  RasterFilterType
@brief  栅格过滤器类型 枚举

</member>
        <member name="F:RasterFilterType_After">
@brief 后置

</member>
        <member name="F:RasterFilterType_Pre">
@brief 前置

</member>
        <member name="F:RasterFilterType_UnKnown">
@brief 未知类型

</member>
        <member name="T:SysCarto.RasterStretchType">
@class  RasterStretchType
@brief  栅格拉伸类型 枚举

</member>
        <member name="F:RasterStretch_Count">
@brief  数量

</member>
        <member name="F:RasterStretch_PercentMinimumMaximum">
@brief  最小最大百分比

</member>
        <member name="F:RasterStretch_HistogramSpecification">
@brief  直方图均衡化

</member>
        <member name="F:RasterStretch_MinimumMaximum">
@brief  最小最大值

</member>
        <member name="F:RasterStretch_HistogramEqualize">
@brief  直方图相等

</member>
        <member name="F:RasterStretch_StandardDeviations">
@brief  标准差拉伸

</member>
        <member name="F:RasterStretch_Custom">
@brief  自定义拉伸

</member>
        <member name="F:RasterStretch_DefaultFromSource">
@brief  默认从源数据

</member>
        <member name="F:RasterStretch_NONE">
@brief  无类型

</member>
        <member name="F:SysCarto.IRasterDisplayProps.NoDataColor">
@brief 无效数据颜色

</member>
        <member name="F:SysCarto.IRasterDisplayProps.m_nInvertBrightness">
@brief 是否亮度反转

</member>
        <member name="F:SysCarto.IRasterDisplayProps.m_nTransparent">
@brief 透明度

</member>
        <member name="F:SysCarto.IRasterDisplayProps.m_nBrightness">
@brief 亮度

</member>
        <member name="F:SysCarto.IRasterDisplayProps.m_nContrast">
@brief 对比度

</member>
        <member name="T:SysCarto.IRasterDisplayProps">
@class IRasterDisplayProps
@brief  栅格显示支持

</member>
        <member name="T:SysCarto.RasterResamplingType">
@class  RasterResamplingType
@brief  栅格重采样类型  枚举

</member>
        <member name="F:RSP_BilinearGaussBlurPlus">
@brief 通过双线性高斯模糊增强法重采样

</member>
        <member name="F:RSP_BilinearGaussBlur">
@brief 通过双线性高斯模糊法重采样

</member>
        <member name="F:RSP_BilinearInterpolationPlus">
@brief 通过双线性内插增强法重采样

</member>
        <member name="F:RSP_Majority">
@brief 通过多值法重采样

</member>
        <member name="F:RSP_CubicConvolution">
@brief 通过立方卷积法重采样

</member>
        <member name="F:RSP_BilinearInterpolation">
@brief 通过双线性内插法重采样

</member>
        <member name="F:RSP_NearestNeighbor">
@brief 通过邻近值法重采样

</member>
        <member name="D:SysDataSource.RasterDatasetPtr">
@brief 栅格数据集 智能指针

</member>
        <member name="F:SysDataSource.RasterDataset.m_ptrEnvelope">
@brief  包络线对象

</member>
        <member name="F:SysDataSource.RasterDataset.m_strGCPProj">
@brief  控制点项目

</member>
        <member name="F:SysDataSource.RasterDataset.m_nGCPCount">
@brief  控制点数量

</member>
        <member name="F:SysDataSource.RasterDataset.m_pGCPs">
@brief  控制点数组

</member>
        <member name="F:SysDataSource.RasterDataset.m_nBandCount">
@brief  波段数量

</member>
        <member name="F:SysDataSource.RasterDataset.m_nRasterHeight">
@brief  栅格高度

</member>
        <member name="F:SysDataSource.RasterDataset.m_nRasterWidth">
@brief  栅格宽度

</member>
        <member name="F:SysDataSource.RasterDataset.m_pGeoInvTransform">
@brief  反向纺射变换参数数组   ----

</member>
        <member name="F:SysDataSource.RasterDataset.m_pGeoTransform">
@brief  纺射变换参数数组

</member>
        <member name="F:SysDataSource.RasterDataset.m_vecRasterBandPtr">
@brief  栅格波段集合

</member>
        <member name="M:SysDataSource.RasterDataset.GetBandCount">
@brief 获取波段数
@return  int 波段数

</member>
        <member name="M:SysDataSource.RasterDataset.GetRasterYSize">
@brief 获取栅格高度
@return int 栅格高度

</member>
        <member name="M:SysDataSource.RasterDataset.GetRasterXSize">
@brief 获取栅格宽度
@return int 栅格宽度

</member>
        <member name="M:SysDataSource.RasterDataset.SetGeoTransform(System.Double*)">
@brief 设置纺射变换参数
@param [in] pTrans 参数
@return void

</member>
        <member name="M:SysDataSource.RasterDataset.GetGeoTransform(System.Double*)">
@brief 获取纺射变换参数
@param [in] pTrans 参数
@return void

</member>
        <member name="M:SysDataSource.RasterDataset.AddRasterBand(SysUtility._ptr_t&lt;SysDataSource.RasterBand&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  添加波段
@param  [in] rasterBand 栅格波段
@return bool 是否成功 

</member>
        <member name="M:SysDataSource.RasterDataset.GetRasterBand(System.Int32)">
@brief 获取波段类
@param [in] nIndex 波段索引号。从0开始
@return RasterBandPtr 波段类

</member>
        <member name="M:SysDataSource.RasterDataset.WriteHistInfo">
@brief 统计信息写入到.HistInfo.XML文件
@return bool 是否成功

</member>
        <member name="M:SysDataSource.RasterDataset.CalculateHistInfo">
@brief 计算统计信息。重新计算
@return bool 是否成功

</member>
        <member name="M:SysDataSource.RasterDataset.ReadHistInfo">
@brief 从.HistInfo.XML中读取统计信息
@return 是否读取成功

</member>
        <member name="M:SysDataSource.RasterDataset.GetGCPSpatialRef(QString*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 获取控制点的投影
@param[out] strProj 控制点的投影WKT字符串
@return void 

</member>
        <member name="M:SysDataSource.RasterDataset.GetGCPs">
@brief 获取控制点数组
@return const GDAL_GCP*  控制点数组

</member>
        <member name="M:SysDataSource.RasterDataset.WorldToPixel_Ex(System.Double,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 地理坐标转为栅格坐标
@param [in] dblX 地理坐标x
@param [in] dblY 地理坐标y
@param [in] lCol 栅格坐标x
@param [in] lRow 栅格坐标y
@return void

</member>
        <member name="M:SysDataSource.RasterDataset.PixelToWorld_Ex(System.Double,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 栅格坐标转地理坐标
@param [in] lCol 栅格坐标
@param [in] lRow 栅格坐标
@param [in] dblX 地理坐标
@param [in] dblY 地理坐标
@return void

</member>
        <member name="M:SysDataSource.RasterDataset.GetMetadataItem(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@brief 获取元数据信息
@param [in] pszName   名字
@param [in] pszDomain 区域
@return char * 元数据信息描述

</member>
        <member name="M:SysDataSource.RasterDataset.GetExtent">
@brief 获取范围
@return SysGeometry::EnvelopePtr 范围

</member>
        <member name="M:SysDataSource.RasterDataset.GetGCPCount">
@brief  获取控制点的个数
@return 控制点的个数

</member>
        <member name="M:SysDataSource.RasterDataset.GetPyramidLevel">
@brief 返回金字塔层数
@return int 返回金字塔层数，如果没有金字塔则返回0

</member>
        <member name="M:SysDataSource.RasterDataset.BuildPyramid(System.Single,SysDataSource.DadaSampleType,=FUNC:System.Int32(System.Double,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Void*),System.Void*)">
@brief 建立金字塔
@param[in] float fSampleRate 重采样比率
@param[in] DadaSampleType sample_type 采样方式："NEAREST", "AVERAGE" or "MODE"等
@param[in] ProgressFunc pProgressFunc 进度回调函数
@param[in] void* pProgressArg 进度回调函数参数
@return bool 若创建成功则返回true，否则为false

</member>
        <member name="M:SysDataSource.RasterDataset.Read(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,QVector&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 读取数据，保存在PixelBuffer中
@param [in] nx 栅格x坐标
@param [in] ny 栅格y坐标
@param [in] nWid 读取的宽度
@param [in] nHei 读取的高度
@param [in] nBufXSize 缓冲宽度
@param [in] nBufYSize 缓冲高度
@param [in] bandMap 波段映射集合
@return SysDataSource::PixelBufferPtr  图片渲染缓冲对象

</member>
        <member name="M:SysDataSource.RasterDataset.Write(System.Int32,System.Int32,System.Int32,System.Int32,System.Void*,System.Int32,System.Int32,SysDataSource.PixelDataType,System.Int32,System.Int32*,System.Int32,System.Int32,System.Int32)">
@brief 写入数据块
@param [in] nx 栅格x坐标
@param [in] ny 栅格y坐标
@param [in] nWid 写入的宽度
@param [in] nHei 写入的高度
@param [in] pData 数据缓冲
@param [in] nBufXSize 缓冲宽度
@param [in] nBufYSize 缓冲高度
@param [in] eBufType 写入类型
@param [in] nBandCount 波段数
@param [in] pBandMap 波段映射
@param [in] nPixelSpace 像素间距
@param [in] nLineSpace 行间距
@param [in] nBandSpace 波段间距
@return 是否成功

</member>
        <member name="M:SysDataSource.RasterDataset.Read(System.Int32,System.Int32,System.Int32,System.Int32,System.Void*,System.Int32,System.Int32,SysDataSource.PixelDataType,System.Int32,System.Int32*,System.Int32,System.Int32,System.Int32)">
@brief 读取数据块
@param [in] nx 栅格x坐标
@param [in] ny 栅格y坐标
@param [in] nWid 读取的宽度
@param [in] nHei 读取的高度
@param [in] pData 数据缓冲
@param [in] nBufXSize 目标宽度
@param [in] nBufYSize 目标高度
@param [in] eBufType 读取类型
@param [in] nBandCount 波段数
@param [in] pBandMap 波段映射
@param [in] nPixelSpace 像素间距
@param [in] nLineSpace 行间距
@param [in] nBandSpace 波段间距
@return 是否成功

</member>
        <member name="M:SysDataSource.RasterDataset.UseRPC(System.Boolean)">
@brief 是否使用RPC
@param [in] bUse 是否使用RPC 
@return void

</member>
        <member name="M:SysDataSource.RasterDataset.IsUsingRPC">
@brief 是否使用RPC投影
@return bool 是否使用

</member>
        <member name="M:SysDataSource.RasterDataset.UseRasterCoords">
@brief 设置为使用栅格坐标
@return  void

</member>
        <member name="M:SysDataSource.RasterDataset.Open(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysDataSource.OpenMode)">
@brief 打开
@param [in] strPath 路径
@param [in] mode 打开模式
@return 是否成功

</member>
        <member name="M:SysDataSource.RasterDataset.Dispose">
@brief 析构函数

</member>
        <member name="M:SysDataSource.RasterDataset.#ctor">
@brief 构造函数

</member>
        <member name="F:SysDataSource.RasterBand.m_ptrHistogram">
@brief 直方图对象

</member>
        <member name="F:SysDataSource.RasterBand.m_nBandID">
@brief 波段的ID编号  从1开始

</member>
        <member name="F:SysDataSource.RasterBand.m_bHaveNoDataValue">
@brief 是否具有波段的无效值

</member>
        <member name="F:SysDataSource.RasterBand.m_dNodataValue">
@brief 波段的无效值

</member>
        <member name="F:SysDataSource.RasterBand.m_nBlockSizeY">
@brief 数据存储分块的高度

</member>
        <member name="F:SysDataSource.RasterBand.m_nBlockSizeX">
@brief 数据存储分块的宽度

</member>
        <member name="F:SysDataSource.RasterBand.m_nSizeY">
@brief 波段高度

</member>
        <member name="F:SysDataSource.RasterBand.m_nSizeX">
@brief 波段宽度

</member>
        <member name="F:SysDataSource.RasterBand.m_ePixelDataType">
@brief 波段数据类型

</member>
        <member name="F:SysDataSource.RasterBand.m_vecCategoryName">
@brief 分类信息

</member>
        <member name="F:SysDataSource.RasterBand.m_ptrColorTable">
@brief 颜色表信息

</member>
        <member name="M:SysDataSource.RasterBand.ComputerHistogram">
@brief 统计直方图信息
@return void 

</member>
        <member name="M:SysDataSource.RasterBand.GetBandID">
@brief  获取当前波段在数据集中的序号，如果返回0，则表示当前波段没有数据集。
@return int 当前波段在数据集中的序号

</member>
        <member name="M:SysDataSource.RasterBand.GetYSize">
@brief  获取波段高度
@return int 高度

</member>
        <member name="M:SysDataSource.RasterBand.GetXSize">
@brief  获取波段宽度
@return int 宽度

</member>
        <member name="M:SysDataSource.RasterBand.GetRasterDataType">
@brief  获取波段数据类型
@return PixelDataType 波段数据类型

</member>
        <member name="M:SysDataSource.RasterBand.SetHistogramInfo(SysUtility._ptr_t&lt;SysDataSource.StatsHistogram&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  设置直方图信息
@param[in] ptrHistogram 直方图对象
@return void

</member>
        <member name="M:SysDataSource.RasterBand.IsHistogramInfoCalculated">
@brief  是否计算直方图信息
@return bool  是 true，否 false 

</member>
        <member name="M:SysDataSource.RasterBand.GetHistogramInfo">
@brief  获取直方图信息
@return StatsHistogramPtr  直方图对象 

</member>
        <member name="M:SysDataSource.RasterBand.GetMetadataItem(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@brief 获取元数据信息
@param [in] pszName   名字
@return char * 元数据信息描述

</member>
        <member name="M:SysDataSource.RasterBand.SetColorTable(SysUtility._ptr_t&lt;SysDataSource.ColorTable&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  设置颜色表信息
@param[in] ColorTablePtr ptrColorTable 颜色表信息
@return void

</member>
        <member name="M:SysDataSource.RasterBand.GetColorTable">
@brief  获取颜色表信息
@return ColorTablePtr 颜色表信息

</member>
        <member name="M:SysDataSource.RasterBand.SetNoDataValue(System.Double)">
@brief 设置当前波段中的无效数据值
@param[in] double 当前波段的无效值
@return void

</member>
        <member name="M:SysDataSource.RasterBand.Write(System.Int32,System.Int32,System.Int32,System.Int32,System.Void*,System.Int32,System.Int32,SysDataSource.PixelDataType,System.Int32,System.Int32)">
@brief 写入数据块
@param [in] nx 栅格x坐标
@param [in] ny 栅格y坐标
@param [in] nWid 写入宽度
@param [in] nHei 写入高度
@param [in] pData 数据缓冲
@param [in] nBufXSize 数据缓冲宽度
@param [in] nBufYSize 数据缓冲高度
@param [in] eBufType 写入数据类型
@param [in] nPixelSpace 像素间距
@param [in] nLineSpace 行间距
@param [in] nBandSpace 波段间距  ---
@return

</member>
        <member name="M:SysDataSource.RasterBand.Read(System.Int32,System.Int32,System.Int32,System.Int32,System.Void*,System.Int32,System.Int32,SysDataSource.PixelDataType,System.Int32,System.Int32)">
@brief 读取数据块
@param [in] nx 栅格x坐标
@param [in] ny 栅格y坐标
@param [in] nWid 读取宽度
@param [in] nHei 读取高度
@param [in] pData 数据缓冲
@param [in] nBufXSize 数据缓冲宽度
@param [in] nBufYSize 数据缓冲高度
@param [in] eBufType 读取数据类型
@param [in] nPixelSpace 像素间距
@param [in] nLineSpace 行间距
@return 是否成功

</member>
        <member name="M:SysDataSource.RasterBand.Dispose">
@brief 析构函数

</member>
        <member name="M:SysDataSource.RasterBand.#ctor">
@brief 构造函数

</member>
        <member name="T:SysDataSource.RasterBand">
@brief 类的前置声明 和 智能指针定义


@class RasterBand
	* @brief 栅格波段类

</member>
        <member name="T:SysDataSource.RasterDataset">
@brief 类的前置声明 和 智能指针定义


@class RasterDataset
	* @brief  栅格数据集


@brief  类的前置声明 和智能指针定义

</member>
        <member name="D:SysDataSource.StatsHistogramPtr">
@brief 直方图对象类 智能指针

</member>
        <member name="F:SysDataSource.StatsHistogram.m_dStep">
@brief 梯度

</member>
        <member name="F:SysDataSource.StatsHistogram.m_dStretchMax">
@brief ENVI方式%拉伸的对应范围最大值

</member>
        <member name="F:SysDataSource.StatsHistogram.m_dStretchMin">
@brief ENVI方式%拉伸的对应范围最小值

</member>
        <member name="F:SysDataSource.StatsHistogram.m_iMatchBandIndex">
@brief 匹配的波段序号

</member>
        <member name="F:SysDataSource.StatsHistogram.m_bStats">
@brief 是否具有统计信息

</member>
        <member name="F:SysDataSource.StatsHistogram.m_bHistogram">
@brief 是否有直方图

</member>
        <member name="F:SysDataSource.StatsHistogram.m_ppOutStatsHistogram">
@brief 输出直方图

</member>
        <member name="F:SysDataSource.StatsHistogram.m_ppHistogram">
@brief 直方图

</member>
        <member name="F:SysDataSource.StatsHistogram.m_dHistMax">
@brief 直方图最大值

</member>
        <member name="F:SysDataSource.StatsHistogram.m_dHistMin">
@brief 直方图最小值

</member>
        <member name="F:SysDataSource.StatsHistogram.m_dStdDev">
@brief 方差

</member>
        <member name="F:SysDataSource.StatsHistogram.m_dMean">
@brief 均值

</member>
        <member name="F:SysDataSource.StatsHistogram.m_dMax">
@brief 统计最大值

</member>
        <member name="F:SysDataSource.StatsHistogram.m_dMin">
@brief 统计最小值

</member>
        <member name="M:SysDataSource.StatsHistogram.GetStep">
@brief 获取梯度
@return  double 梯度

</member>
        <member name="M:SysDataSource.StatsHistogram.SetStep(System.Double)">
@brief 设置梯度
@param [in] dStep 梯度
@return  void

</member>
        <member name="M:SysDataSource.StatsHistogram.GetLinearStretch(System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 获取线性拉伸参数
@param [in out] dStretchMin 拉伸最小值
@param [in out] dStretchMax 拉伸最大值
@return  void

</member>
        <member name="M:SysDataSource.StatsHistogram.SetLinearStretch(System.Double,System.Double)">
@brief 设置线性拉伸参数
@param [in] dStretchMin 拉伸最小值
@param [in] dStretchMax 拉伸最大值
@return  void

</member>
        <member name="M:SysDataSource.StatsHistogram.SetMatchBandIndex(System.Int32)">
@brief 设置匹配的波段索引
@param [in] iBandIndex 波段索引
@return  void

</member>
        <member name="M:SysDataSource.StatsHistogram.GetMatchBandIndex">
@brief 获取匹配的波段索引
@return  int 波段索引

</member>
        <member name="M:SysDataSource.StatsHistogram.GetOutStatsHistogram(System.Double***!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 获取输出直方图
@param [in out] ppdHistogram 直方图信息 
@return  void

</member>
        <member name="M:SysDataSource.StatsHistogram.GetHistogram">
@brief 获取直方图信息
@return  double**  直方图信息

</member>
        <member name="M:SysDataSource.StatsHistogram.GetHistogram(System.Double***!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 获取直方图 
@param [in out] ppdHistogram 直方图
@return  void

</member>
        <member name="M:SysDataSource.StatsHistogram.SetOutStatsHistogram(System.Double**)">
@brief 设置输出直方图信息 
@param [in out] ppdHistogram   直方图信息
@return  void

</member>
        <member name="M:SysDataSource.StatsHistogram.SetHistogram(System.Double**)">
@brief 设置直方图信息 
@param [in] ppdHistogram 直方图
@return  void

</member>
        <member name="M:SysDataSource.StatsHistogram.Update">
@brief 刷新直方图(重新赋值后均需调Update)
@return  void

</member>
        <member name="M:SysDataSource.StatsHistogram.QueryStats(System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 获取统计信息
@param [in out] dMin    最小值
@param [in out] dMax    最大值
@param [in out] dMean   均值 
@param [in out] dStdDev 方差 
@return  void

</member>
        <member name="M:SysDataSource.StatsHistogram.QueryHistogramMinmax(System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 获取直方图最小最大值
@param [in out] dMin    最小值
@param [in out] dMax    最大值
@return  void

</member>
        <member name="M:SysDataSource.StatsHistogram.SetHistogramMinMax(System.Double,System.Double)">
@brief 设置直方图最小最大值
@param [in] dMin    最小值
@param [in] dMax    最大值
@return  void

</member>
        <member name="M:SysDataSource.StatsHistogram.SetStats(System.Double,System.Double,System.Double,System.Double)">
@brief 设置统计信息 
@param [in] dMin    最小值 
@param [in] dMax    最大值 
@param [in] dMean   均值 
@param [in] dStdDev 方差 
@return  void

</member>
        <member name="M:SysDataSource.StatsHistogram.HasStats">
@brief 判断StatsHistogram类是否具有统计信息 
@return  bool 是否具有统计信息

</member>
        <member name="M:SysDataSource.StatsHistogram.HasHistogram">
@brief 判断StatsHistogram类是否具有直方图 
@return  bool 是否具有直方图

</member>
        <member name="M:SysDataSource.StatsHistogram.Empty">
@brief 清空直方图信息使其失效
@return  void

</member>
        <member name="M:SysDataSource.StatsHistogram.Accumulate(System.Double,System.Int32)">
@brief 赋于直方图dValue值的个数 
@param [in] dValue 值
@param [in] nCount 统计个数
@return  void 

</member>
        <member name="M:SysDataSource.StatsHistogram.Dispose">
@brief 析构函数

</member>
        <member name="M:SysDataSource.StatsHistogram.#ctor">
@brief 构造函数

</member>
        <member name="T:SysDataSource.StatsHistogram">
@class StatsHistogram
	* @brief  直方图对象类

</member>
        <member name="D:SysDataSource.PixelBufferPtr">
@brief 图片渲染缓冲类 智能指针

</member>
        <member name="F:SysDataSource.PixelBuffer.m_ePixelDataType">
@brief 图片渲染数据类型

</member>
        <member name="F:SysDataSource.PixelBuffer.m_vecBandMap">
@brief 地图波段BandMap集合

</member>
        <member name="F:SysDataSource.PixelBuffer.m_nHei">
@brief 高度

</member>
        <member name="F:SysDataSource.PixelBuffer.m_nWid">
@brief 宽度

</member>
        <member name="F:SysDataSource.PixelBuffer.m_pData">
@brief  数据指针

</member>
        <member name="M:SysDataSource.PixelBuffer.GetHeight">
@brief 获取高
@return int 高度

</member>
        <member name="M:SysDataSource.PixelBuffer.GetWidth">
@brief 获取宽
@return int 宽度

</member>
        <member name="M:SysDataSource.PixelBuffer.SetData(SysDataSource.PixelDataType,System.Void*)">
@brief 设置数据指针
@param [in] eType 图片渲染数据类型
@param [in] pData 数据
@return

</member>
        <member name="M:SysDataSource.PixelBuffer.GetData">
@brief 获取数据指针
@return void* 数据内存指针

</member>
        <member name="M:SysDataSource.PixelBuffer.GetDataType">
@brief 获取类型
@return PixelDataType 类型

</member>
        <member name="M:SysDataSource.PixelBuffer.GetBandMap">
@brief 获取BandMap
@return 地图波段BandMap的集合

</member>
        <member name="M:SysDataSource.PixelBuffer.Dispose">
@brief 析构函数

</member>
        <member name="M:SysDataSource.PixelBuffer.#ctor(System.Int32,System.Int32,QVector&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysDataSource.PixelDataType,System.Void*)">
@brief 有参构造函数
@param [in] nWid 宽度
@param [in] nHei 高度
@param [in] bandMap 地图波段集合
@param [in] eType 图片渲染数据类型
@param [in] pData 数据

</member>
        <member name="M:SysDataSource.PixelBuffer.#ctor(System.Int32,System.Int32,QVector&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysDataSource.PixelDataType)">
@brief 有参构造函数
@param [in] nWid 宽度
@param [in] nHei 高度
@param [in] bandMap 地图波段集合
@param [in] eType 图片渲染数据类型

</member>
        <member name="T:SysDataSource.PixelBuffer">
@class  PixelBuffer 
@brief  图片渲染缓冲类

</member>
        <member name="F:SysDataSource.ColorTable.m_vecColorEntry">
@brief 颜色表项集合

</member>
        <member name="M:SysDataSource.ColorTable.Clone">
@brief 克隆
@return ColorTablePtr  克隆对象

</member>
        <member name="M:SysDataSource.ColorTable.ClearColorEntry">
@brief  清空颜色表
@return void

</member>
        <member name="M:SysDataSource.ColorTable.AddColorEntry(SysUtility._ptr_t&lt;SysDataSource.ColorEntry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 添加颜色表项
@param [in] ptrColorEntry 颜色表项
@return void

</member>
        <member name="M:SysDataSource.ColorTable.SetColorEntry(System.Int32,SysUtility._ptr_t&lt;SysDataSource.ColorEntry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置颜色表项
@param [in] nIndex 颜色表项编号
@param [in] ptrColorEntry 颜色表项
@return bool 是否成功

</member>
        <member name="M:SysDataSource.ColorTable.GetColorEntry(System.Int32)">
@brief 获取颜色表项
@param [in] nIndex 颜色表项编号
@return ColorEntryPtr 颜色表项

</member>
        <member name="M:SysDataSource.ColorTable.GetColorEntryCount">
@brief 获取颜色表项个数
@return int 颜色表项个数

</member>
        <member name="M:SysDataSource.ColorTable.Dispose">
@brief 析构函数

</member>
        <member name="M:SysDataSource.ColorTable.#ctor">
@brief 构造函数

</member>
        <member name="T:SysDataSource.ColorTable">
@brief 类的前置声明和智能指针定义


@class ColorTable
	* @brief 颜色表ColorTable对象类

</member>
        <member name="M:SysDataSource.ColorEntry.Clone">
@brief 克隆
@return ColorEntryPtr 克隆对象

</member>
        <member name="M:SysDataSource.ColorEntry.Dispose">
@brief 析构函数

</member>
        <member name="M:SysDataSource.ColorEntry.#ctor(System.Int16,System.Int16,System.Int16,System.Int16)">
@brief 有参构造函数

</member>
        <member name="M:SysDataSource.ColorEntry.#ctor">
@brief 构造函数

</member>
        <member name="T:SysDataSource.ColorEntry">
@brief 类的前置声明和智能指针定义


@class ColorEntry
	* @brief 颜色表项ColorEntry对象类

</member>
        <member name="D:SysCarto.ActiveViewPtr">
@brief  活动视图 智能指针对象

</member>
        <member name="F:SysCarto.ActiveView.m_bZooming">
@brief  是否正在缩放，从滚轮第一次滚动开始，到屏幕范围内瓦片缓存准备完毕结束

</member>
        <member name="F:SysCarto.ActiveView.m_ptrZoomImgEnv">
@brief  缩放时图像范围

</member>
        <member name="F:SysCarto.ActiveView.m_pTempImage">
@brief  临时图片对象指针

</member>
        <member name="F:SysCarto.ActiveView.m_Image">
@brief  图片

</member>
        <member name="F:SysCarto.ActiveView.m_ptrTrackerCancel">
@brief  取消追踪

</member>
        <member name="F:SysCarto.ActiveView.m_bShowSelection">
@brief  是否显示选择

</member>
        <member name="F:SysCarto.ActiveView.m_ptrExtentStack">
@brief  范围栈

</member>
        <member name="F:SysCarto.ActiveView.m_ptrTempDisplayTrans">
@brief 临时信息转换

</member>
        <member name="F:SysCarto.ActiveView.m_ptrDisplayTrans">
@brief 显示转换

</member>
        <member name="F:SysCarto.ActiveView.m_ptrDefaultTempLayer">
@brief 临时制图

</member>
        <member name="F:SysCarto.ActiveView.m_ptrCurrLayer">
@brief 当前图层

</member>
        <member name="F:SysCarto.ActiveView.m_bActivate">
@brief 是否是激活的

</member>
        <member name="F:SysCarto.ActiveView.m_pPaintDevice">
@brief 绘图设备

</member>
        <member name="M:SysCarto.ActiveView.#ctor">
@brief 构造函数

</member>
        <member name="M:SysCarto.ActiveView.Output(SysUtility._ptr_t&lt;SysCarto.IExporter&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,QRect!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysGeometry.Envelope&gt;,SysUtility._ptr_t&lt;SysUI.TrackerCancel&gt;)">
@brief 输出
@param [in] exporter 导出标会
@param [in] nDpi 每英寸点数
@param [in] pixelBounds  像素点边界
@param [in] ptrVisBounds  包络范围
@param [in] ptrTracker 取消追踪
@return void

</member>
        <member name="M:SysCarto.ActiveView.PanTo(SysUtility._ptr_t&lt;SysGeometry.Point&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 视图平移到以指定点未中心
@param [in] ptrPoint 点对象
@return void

</member>
        <member name="M:SysCarto.ActiveView.ZoomTo(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 视图缩放到几何对象范围
@param [in] ptrGeo 几何对象
@return void

</member>
        <member name="M:SysCarto.ActiveView.Draw(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysUI.TrackerCancel&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制
@param [in] paiter 绘图面板
@param [in] ptrTracker 取消追踪对象
@return void

</member>
        <member name="M:SysCarto.ActiveView.WaitForRenderFinished">
@brief 延时渲染完成
@return void

</member>
        <member name="M:SysCarto.ActiveView.StopRender">
@brief 停止渲染
@return void

</member>
        <member name="M:SysCarto.ActiveView.PanRefresh(System.Boolean)">
@brief 漫游刷新
@param [in] bForceActive  是否强制刷新
@return void

</member>
        <member name="M:SysCarto.ActiveView.Refresh(System.Boolean,System.Boolean)">
@brief 刷新
@param [in] bClearCache  是否清空缓存
@param [in] bFroceRefresh  是否强制刷新
@return  void

</member>
        <member name="M:SysCarto.ActiveView.PartialRefresh(SysCarto.ViewDrawPhaseType,System.Boolean)">
@brief 局部刷新
@param [in] dpType  视图刷新类型
@param [in] bForce  是否强制刷新
@return void

</member>
        <member name="M:SysCarto.ActiveView.DrawElement(SysUtility._ptr_t&lt;SysCarto.Element&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制元素
@param [in] ptrElemnt  元素对象
@return void

</member>
        <member name="M:SysCarto.ActiveView.DrawGeometry(SysUtility._ptr_t&lt;SysDisplay.Symbol&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制几何图形
@param [in] ptrSymbol  符号对象
@param [in] ptrGeo     几何对象
@return void

</member>
        <member name="M:SysCarto.ActiveView.ZoomAction(QPoint,System.Double,System.Double)">
@brief 缩放行为
@param [in] deltaX  X轴漫游大小
@param [in] deltaY  Y轴漫游大小
@return void

</member>
        <member name="M:SysCarto.ActiveView.PanAction(System.Double,System.Double)">
@brief  漫游行为
@param [in] deltaX  X轴漫游大小
@param [in] deltaY  Y轴漫游大小
@return void

</member>
        <member name="M:SysCarto.ActiveView.FinishDrawing">
@brief 完成绘制
@return void

</member>
        <member name="M:SysCarto.ActiveView.StartDrawing">
@brief 开始绘制
@return void

</member>
        <member name="M:SysCarto.ActiveView.ZoomByFactor(SysUtility._ptr_t&lt;SysGeometry.Point&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
@brief 通过因素缩放
@param [in]  ptrCenter  几何中心点
@param [in]   dScaleX    X轴方向缩放
@param [in]  dScaleY    Y轴方向缩放
@return void

</member>
        <member name="M:SysCarto.ActiveView.GetTrackerCancel">
@brief 获取取消追踪
@return  SysDisplay::DisplayTransformationPtr  显示转换

</member>
        <member name="M:SysCarto.ActiveView.SetShowSelection(System.Boolean)">
@brief 设置显示选择
@param [in]  bool bShow 是否设置
@return void

</member>
        <member name="M:SysCarto.ActiveView.IsShowSelection">
@brief 是否显示选择
@return bool 是否显示

</member>
        <member name="M:SysCarto.ActiveView.GetDisplayTransformation">
@brief 获取显示转换
@return  SysDisplay::DisplayTransformationPtr  显示转换

</member>
        <member name="M:SysCarto.ActiveView.SetCurrentLayer(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置当前图层
@param [in]  ptrLayer 图层
@return void

</member>
        <member name="M:SysCarto.ActiveView.GetCurrentLayer">
@brief 获取当前图层
@return  LayerPtr  当前图层

</member>
        <member name="M:SysCarto.ActiveView.GetGraphicsContainer">
@brief 获取制图容器
@return  IGraphicsContainer*  制图容器

</member>
        <member name="M:SysCarto.ActiveView.GetDefaultTempLayer">
@brief 获取临时图层
@return  GraphicsLayerPtr  临时图层

</member>
        <member name="M:SysCarto.ActiveView.HitTestMap(SysUtility._ptr_t&lt;SysGeometry.Point&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 点击地图测试
@param [in]  point 几何点
@return MapPtr 地图

</member>
        <member name="M:SysCarto.ActiveView.SetFocusMap(SysUtility._ptr_t&lt;SysCarto.Map&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置焦点地图
@param [in]  ptrMap 地图
@return void

</member>
        <member name="M:SysCarto.ActiveView.GetFocusMap">
@brief 获取焦点地图
@return  MapPtr  地图

</member>
        <member name="M:SysCarto.ActiveView.GetExtentStack">
@brief 获取范围栈
@return  ExtentStackPtr  范围栈

</member>
        <member name="M:SysCarto.ActiveView.SetFullExtent(SysUtility._ptr_t&lt;SysGeometry.Envelope&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置地图范围
@param [in]  SysGeometry::EnvelopePtr ptrEnv 地图范围
@return void

</member>
        <member name="M:SysCarto.ActiveView.GetFullExtent">
@brief 获取地图范围
@return  SysGeometry::EnvelopePtr  地图范围

</member>
        <member name="M:SysCarto.ActiveView.SetExtent(SysUtility._ptr_t&lt;SysGeometry.Envelope&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置范围
@param [in] SysGeometry::EnvelopePtr  范围
@return void 

</member>
        <member name="M:SysCarto.ActiveView.GetExtent">
@brief 获取范围
@return SysGeometry::EnvelopePtr  范围

</member>
        <member name="M:SysCarto.ActiveView.GetExportFrame">
@brief 获取输出框架
@return QRect 矩形框

</member>
        <member name="M:SysCarto.ActiveView.IsActived">
@brief 视图是否激活状态
@return bool 是否为激活状态

</member>
        <member name="M:SysCarto.ActiveView.DeActivate">
@brief 取消视图激活状态
@return void

</member>
        <member name="M:SysCarto.ActiveView.Activate(QPaintDevice*)">
@brief 激活视图
@param [in] pDevice 视图绘制设备对象
@return  void

</member>
        <member name="M:SysCarto.ActiveView.Dispose">
@brief 析构函数

</member>
        <member name="D:SysCarto.IExporterPtr">
@brief  输出接口 智能指针对象

</member>
        <member name="F:SysCarto.IExporter.m_ptrTracker">
@brief  取消追踪

</member>
        <member name="F:SysCarto.IExporter.m_BGColor">
@brief  背景颜色

</member>
        <member name="F:SysCarto.IExporter.m_nHeight">
@brief  高度

</member>
        <member name="F:SysCarto.IExporter.m_nWidth">
@brief  宽度

</member>
        <member name="F:SysCarto.IExporter.m_dpi">
@brief  每英寸点数

</member>
        <member name="M:SysCarto.IExporter.#ctor">
@brief 构造函数

</member>
        <member name="M:SysCarto.IExporter.FinishExporting">
@brief 完成导出
@return void

</member>
        <member name="M:SysCarto.IExporter.StartExporting">
@brief 开始导出
@return void

</member>
        <member name="M:SysCarto.IExporter.SetTrackerCancel(SysUtility._ptr_t&lt;SysUI.TrackerCancel&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置取消追踪
@param [in] ptrTracker  取消追踪
@return void

</member>
        <member name="M:SysCarto.IExporter.GetTrackerCancel">
@brief 获取取消追踪
@return   SysUI::TrackerCancelPtr  取消追踪

</member>
        <member name="M:SysCarto.IExporter.GetDevice">
@brief 获取绘图设备
@return   QPaintDevice*  绘图设备

</member>
        <member name="M:SysCarto.IExporter.SetBackgroundColor(QColor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置背景颜色
@param [in] color  背景颜色
@return void

</member>
        <member name="M:SysCarto.IExporter.GetBackgroundColor">
@brief 获取背景颜色
@return  QColor  背景颜色

</member>
        <member name="M:SysCarto.IExporter.SetHeight(System.Int32)">
@brief 设置高度
@param [in] nHeight  高度
@return void

</member>
        <member name="M:SysCarto.IExporter.GetHeight">
@brief 获取高度
@return  int  获取高度

</member>
        <member name="M:SysCarto.IExporter.SetWidth(System.Int32)">
@brief 设置宽度
@param [in] nWidth  宽度
@return void

</member>
        <member name="M:SysCarto.IExporter.GetWidth">
@brief 获取宽度
@return  int  获取宽度

</member>
        <member name="M:SysCarto.IExporter.SetDpi(System.Double)">
@brief 设置dpi（ 每英寸点数）
@param [in] dpi  每英寸点数
@return void

</member>
        <member name="M:SysCarto.IExporter.GetDpi">
@brief 获取dpi（ 每英寸点数）
@return double  输出文件名字

</member>
        <member name="M:SysCarto.IExporter.Dispose">
@brief 析构函数

</member>
        <member name="T:SysCarto.IExporter">
@class IExporter
@brief  输出接口

</member>
        <member name="F:SysCarto.IActiveViewEvents.NotifyUpdate">
@brief 通知更新信号

</member>
        <member name="F:SysCarto.IActiveViewEvents.CurrentLayerChanged">
@brief 当前图层改变信号

</member>
        <member name="F:SysCarto.IActiveViewEvents.BeforeCurrentLayerChanging">
@brief 当前图层改变之前信号

</member>
        <member name="F:SysCarto.IActiveViewEvents.AfterDraw">
@brief 绘制之后信号

</member>
        <member name="F:SysCarto.IActiveViewEvents.BeginDraw">
@brief 开始绘制信号

</member>
        <member name="F:SysCarto.IActiveViewEvents.ViewRefreshed">
@brief 视图刷新信号

</member>
        <member name="F:SysCarto.IActiveViewEvents.SpatialReferenceChanged">
@brief 空间参考改变信号

</member>
        <member name="F:SysCarto.IActiveViewEvents.FeaturesSelectionChanged">
@brief 选中要素集改变 信号

</member>
        <member name="F:SysCarto.IActiveViewEvents.ContentsCleared">
@brief 内容清空信号

</member>
        <member name="F:SysCarto.IActiveViewEvents.ContentsChanged">
@brief 内容改变信号

</member>
        <member name="F:SysCarto.IActiveViewEvents.FocusMapChanged">
@brief 焦点地图改变信号

</member>
        <member name="F:SysCarto.IActiveViewEvents.LayersDeleted">
@brief 删除图层集信号

</member>
        <member name="F:SysCarto.IActiveViewEvents.LayersAdded">
@brief 添加图层集信号

</member>
        <member name="F:SysCarto.IActiveViewEvents.LayerReordered">
@brief 图层重构信号

</member>
        <member name="F:SysCarto.IActiveViewEvents.LayerDeleted">
@brief 删除图层信号

</member>
        <member name="F:SysCarto.IActiveViewEvents.LayerAdded">
@brief 添加图层信号

</member>
        <member name="F:SysCarto.IActiveViewEvents.BeforeLayersDeleting">
@brief 删除图层集之前的信号

</member>
        <member name="F:SysCarto.IActiveViewEvents.BeforeLayersAdding">
@brief 添加图层集之前的信号

</member>
        <member name="F:SysCarto.IActiveViewEvents.BeforeLayerDeleting">
@brief 删除图层之前的信号

</member>
        <member name="F:SysCarto.IActiveViewEvents.BeforeLayerAdding">
@brief 添加图层之前的信号

</member>
        <member name="T:SysCarto.IActiveViewEvents.ActiveView">
@brief 类的前置声明和智能指针定义

</member>
        <member name="T:SysCarto.IActiveViewEvents">
@class IActiveViewEvents
@brief 活动视图事件

</member>
        <member name="T:SysCarto.ViewDrawPhaseType">
@class  ViewDrawPhaseType
@brief  视图绘制相应类型  枚举

</member>
        <member name="F:ViewAll">
@brief  所有视图

</member>
        <member name="F:ViewInitialized">
@brief  初始化

</member>
        <member name="F:ViewForeground">
@brief  前景

</member>
        <member name="F:ViewGraphicSelection">
@brief  制图选择

</member>
        <member name="F:ViewGraphics">
@brief  制图

</member>
        <member name="F:ViewGeoSelection">
@brief  地理选择

</member>
        <member name="F:ViewGeography">
@brief  地理

</member>
        <member name="F:ViewBackground">
@brief  背景

</member>
        <member name="F:ViewNone">
@brief  无

</member>
        <member name="D:SysCarto.GraphicsLayerPtr">
@brief   图形图层  智能指针对象

</member>
        <member name="M:SysCarto.GraphicsLayer.CopyTo(SysCarto.Layer*)">
@brief 拷贝到Layer
@param [in] Layer* Layer对象

</member>
        <member name="M:SysCarto.GraphicsLayer.Clone">
@brief 克隆
@return LayerPtr 克隆对象

</member>
        <member name="M:SysCarto.GraphicsLayer.Draw(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUI.LayerDrawPhaseType,SysUtility._ptr_t&lt;SysUI.TrackerCancel&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  绘制
@param [in] painter  绘图设备
@param [in] ptrTrasform  显示转换对象
@param [in] dpType  类型
@param [in] ptrTracker   取消转换
@return  void

</member>
        <member name="M:SysCarto.GraphicsLayer.GetExtent">
@brief 获取范围
@return SysGeometry::EnvelopePtr 范围

</member>
        <member name="M:SysCarto.GraphicsLayer.Dispose">
@brief 析构函数

</member>
        <member name="M:SysCarto.GraphicsLayer.#ctor">
@brief 构造函数

</member>
        <member name="T:SysCarto.GraphicsLayer">
@class GraphicsLayer
	* @brief  图形图层

</member>
        <member name="F:SysCarto.IGraphicsContainer.m_ptrNodeEditElem">
@brief  当前编辑的元素

</member>
        <member name="F:SysCarto.IGraphicsContainer.m_lstSelIDs">
@brief  ID集合

</member>
        <member name="F:SysCarto.IGraphicsContainer.m_vecElems">
@brief 元素集合

</member>
        <member name="M:SysCarto.IGraphicsContainer.Draw(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUI.LayerDrawPhaseType,SysUtility._ptr_t&lt;SysUI.TrackerCancel&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制
@param [in] painter   绘图设备
@param [in] ptrTrans  显示转换对象
@param [in] dpType       图层绘制阶段类型
@param [in] ptrTracker   取消转换
@return void

</member>
        <member name="M:SysCarto.IGraphicsContainer.SendToBack(QList&lt;SysUtility._ptr_t&lt;SysCarto.Element&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 向后一层 
@param [in]  listElems  element元素集合
@return  void

</member>
        <member name="M:SysCarto.IGraphicsContainer.SendBackward(QList&lt;SysUtility._ptr_t&lt;SysCarto.Element&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 低端显示 
@param [in]  listElems  element元素集合
@return  void

</member>
        <member name="M:SysCarto.IGraphicsContainer.BringToFront(QList&lt;SysUtility._ptr_t&lt;SysCarto.Element&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 顶端显示 
@param [in]  listElems  element元素集合
@return  void

</member>
        <member name="M:SysCarto.IGraphicsContainer.BringForward(QList&lt;SysUtility._ptr_t&lt;SysCarto.Element&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 向前一层 
@param [in]  listElems  element元素集合
@return  void

</member>
        <member name="M:SysCarto.IGraphicsContainer.UpdateElement(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysCarto.Element&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 更新Element
@param [in]  strID ID标号
@param [in]  ptrNewElem 新元素
@return  void

</member>
        <member name="M:SysCarto.IGraphicsContainer.SetNodeEditElement(SysUtility._ptr_t&lt;SysCarto.Element&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置当前编辑的Element 
@param [in]  ptrElem 元素
@return  void 

</member>
        <member name="M:SysCarto.IGraphicsContainer.GetNodeEditElement">
@brief 获得当前编辑的Element 
@return  ElementPtr 元素

</member>
        <member name="M:SysCarto.IGraphicsContainer.FindElementByName(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 通过name查找Element
@param [in]  strName 名称
@return  ElementPtr 元素

</member>
        <member name="M:SysCarto.IGraphicsContainer.FindElementByID(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 通过ID查找Element 
@param [in]  strID ID编号
@return  ElementPtr 元素 

</member>
        <member name="M:SysCarto.IGraphicsContainer.UnSelectElements(QList&lt;SysUtility._ptr_t&lt;SysCarto.Element&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 反向选择Elements
@param [in] listElems 元素集合
@return  void

</member>
        <member name="M:SysCarto.IGraphicsContainer.UnSelectElement(SysUtility._ptr_t&lt;SysCarto.Element&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 反向选择Element 
@param [in] ptrElem 元素
@return  void

</member>
        <member name="M:SysCarto.IGraphicsContainer.UnSelectAllElements">
@brief 取消所有Element的选择 
@return  void 

</member>
        <member name="M:SysCarto.IGraphicsContainer.SelectionBounds">
@brief 获取选中的边界
@return  SysGeometry::EnvelopePtr  选中的边界

</member>
        <member name="M:SysCarto.IGraphicsContainer.SelectElementsByGeometry(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
@brief 通过几何范围选择元素
@param [in] ptrFilterGeo 几何范围
@param [in] clearSrc 是否清除之前选择 
@return  void

</member>
        <member name="M:SysCarto.IGraphicsContainer.SelectElements(QList&lt;SysUtility._ptr_t&lt;SysCarto.Element&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 获得所有选中的元素
@param [in] listElems 元素集合
@return  void

</member>
        <member name="M:SysCarto.IGraphicsContainer.SelectElement(SysUtility._ptr_t&lt;SysCarto.Element&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 获得选中的元素
@param [in] ptrElem 元素
@return  void 

</member>
        <member name="M:SysCarto.IGraphicsContainer.SelectedElement(System.Int32)">
@brief 获得选中的元素
@param [in] index 索引编号 
@return  ElementPtr 选中的元素

</member>
        <member name="M:SysCarto.IGraphicsContainer.SelectAllElements">
@brief 选中所有元素
@return  void

</member>
        <member name="M:SysCarto.IGraphicsContainer.ElementSelectionCount">
@brief 获得选中元素数量
@return  int  选中元素数量

</member>
        <member name="M:SysCarto.IGraphicsContainer.IsElementSelected(SysUtility._ptr_t&lt;SysCarto.Element&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 元素是否选中
@param [in] ptrElem 元素对象
@return  bool 是否选中

</member>
        <member name="M:SysCarto.IGraphicsContainer.DeleteAllElements">
@brief 删除所有的元素
@return void

</member>
        <member name="M:SysCarto.IGraphicsContainer.DeleteElement(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 删除元素
@param [in] strID 元素ID
@return void

</member>
        <member name="M:SysCarto.IGraphicsContainer.DeleteElement(SysUtility._ptr_t&lt;SysCarto.Element&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 删除元素
@param [in] ptrElement 元素
@return void

</member>
        <member name="M:SysCarto.IGraphicsContainer.InsertElement(System.Int32,SysUtility._ptr_t&lt;SysCarto.Element&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 插入元素到容器
@param [in] ptrElement 元素对象
@return void

</member>
        <member name="M:SysCarto.IGraphicsContainer.AddElements(QList&lt;SysUtility._ptr_t&lt;SysCarto.Element&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 添加元素集到容器
@param [in] vecElems 元素对象集合
@return void

</member>
        <member name="M:SysCarto.IGraphicsContainer.AddElement(SysUtility._ptr_t&lt;SysCarto.Element&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 添加元素到容器
@param [in] ptrElement 元素对象
@return void

</member>
        <member name="M:SysCarto.IGraphicsContainer.GetElementCount">
@brief 获取元素数量
@return  int 元素数量

</member>
        <member name="M:SysCarto.IGraphicsContainer.Dispose">
@brief 析构函数

</member>
        <member name="M:SysCarto.IGraphicsContainer.#ctor">
@brief 构造函数

</member>
        <member name="T:SysCarto.ElementOrderOperation">
@brief 声明友元类

</member>
        <member name="F:SysCarto.IGraphicsContainerEvents.ElementsReordered">
@brief 元素集重排序信号

</member>
        <member name="F:SysCarto.IGraphicsContainerEvents.ElementUpdated">
@brief 更新元素信号

</member>
        <member name="F:SysCarto.IGraphicsContainerEvents.AllElementsDeleted">
@brief 删除所有元素集信号

</member>
        <member name="F:SysCarto.IGraphicsContainerEvents.ElementsDeleted">
@brief 删除元素集信号

</member>
        <member name="F:SysCarto.IGraphicsContainerEvents.ElementDeleted">
@brief 删除元素信号

</member>
        <member name="F:SysCarto.IGraphicsContainerEvents.ElementsAdded">
@brief 添加元素集信号

</member>
        <member name="F:SysCarto.IGraphicsContainerEvents.ElementAdded">
@brief 添加元素信号

</member>
        <member name="F:SysCarto.IGraphicsContainerEvents.ElementsSelectionChanged">
@brief 选中元素集变化信号

</member>
        <member name="T:SysCarto.IGraphicsContainerEvents">
@class IGraphicsContainerEvents
@brief 图元容器事件接口

</member>
        <member name="D:SysCarto.ExtentStackPtr">
@brief 范围栈 智能指针对象

</member>
        <member name="F:SysCarto.ExtentStack.m_listEnvs">
@brief  范围栈

</member>
        <member name="F:SysCarto.ExtentStack.m_pActiveView">
@brief 活跃视图

</member>
        <member name="F:SysCarto.ExtentStack.m_nCurrIndex">
@brief 当前索引

</member>
        <member name="M:SysCarto.ExtentStack.ResetExtent(SysUtility._ptr_t&lt;SysGeometry.Envelope&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 重置范围
@param [in] ptrEnv 包络线范围
@return void

</member>
        <member name="M:SysCarto.ExtentStack.Reset">
@brief 重置
@return void

</member>
        <member name="M:SysCarto.ExtentStack.Undo">
@brief 撤销重做
@return void

</member>
        <member name="M:SysCarto.ExtentStack.Redo">
@brief 重做
@return void

</member>
        <member name="M:SysCarto.ExtentStack.GetItem(System.Int32)">
@brief 获取条目
@param [in] index 索引
@return SysGeometry::EnvelopePtr  包络线对象

</member>
        <member name="M:SysCarto.ExtentStack.Do(SysUtility._ptr_t&lt;SysGeometry.Envelope&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 执行
@param [in] ptrEnv 包络线对象
@return void

</member>
        <member name="M:SysCarto.ExtentStack.Count">
@brief 获取数量
@return int 数量

</member>
        <member name="M:SysCarto.ExtentStack.CanUndo">
@brief 是否撤销
@return bool 是否成功

</member>
        <member name="M:SysCarto.ExtentStack.CanRedo">
@brief 是否重做
@return bool 是否成功

</member>
        <member name="M:SysCarto.ExtentStack.Dispose">
@brief 析构函数

</member>
        <member name="M:SysCarto.ExtentStack.#ctor(SysCarto.ActiveView*)">
@brief 构造函数
@param [in] pActiveView 活动视图

</member>
        <member name="T:SysCarto.ExtentStack">
@class ExtentStack
@brief  范围栈

</member>
        <member name="T:SysCarto.ActiveView">
@brief 类的前置声明


@class ActiveView
@brief  活动视图

</member>
        <member name="D:SysCarto.MultiLayerPtr">
@brief  多图层  智能指针对象

</member>
        <member name="F:SysCarto.MultiLayer.m_ptrDataset">
@brief 多数据集

</member>
        <member name="F:SysCarto.MultiLayer.m_bExpanded">
@brief 是否展开

</member>
        <member name="F:SysCarto.MultiLayer.m_vecLayers">
@brief 图层集合

</member>
        <member name="M:SysCarto.MultiLayer.CopyTo(SysCarto.Layer*)">
@brief 拷贝到Layer
@param[in] Layer* Layer对象

</member>
        <member name="M:SysCarto.MultiLayer.Draw(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUI.LayerDrawPhaseType,SysUtility._ptr_t&lt;SysUI.TrackerCancel&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制
@param [in] paiter 绘图面板
@param [in] ptrTransform 显示转换对象
@param [in] dpType 图层绘制阶段类型
@param [in] ptrTrackerCancel 取消追踪对象
@return void

</member>
        <member name="M:SysCarto.MultiLayer.Clone">
@brief 克隆
@return LayerPtr 克隆图层对象

</member>
        <member name="M:SysCarto.MultiLayer.Clear">
@brief 清空图层
@return void

</member>
        <member name="M:SysCarto.MultiLayer.SetExpanded(System.Boolean)">
@brief 设置是否展开图层
@param [in] bExpanded  是否展开
@return void

</member>
        <member name="M:SysCarto.MultiLayer.GetExpanded">
@brief 获取是否展开图层 
@return  bool  是否成功

</member>
        <member name="M:SysCarto.MultiLayer.GetLayerCount">
@brief 获取图层数量
@return  int  图层数量

</member>
        <member name="M:SysCarto.MultiLayer.GetLayer(System.Int32)">
@brief 获取图层
@param [in] index    索引
@return  LayerPtr    图层

</member>
        <member name="M:SysCarto.MultiLayer.MoveLayer(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief 移动图层
@param [in] ptrLayer 图层
@param [in] index    索引
@return void

</member>
        <member name="M:SysCarto.MultiLayer.Delete(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 删除图层
@param [in] ptrLayer 图层
@return bool 是否成功

</member>
        <member name="M:SysCarto.MultiLayer.DeleteLayer(System.Int32)">
@brief 删除图层
@param [in] index    索引
@return void

</member>
        <member name="M:SysCarto.MultiLayer.AddLayer(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief 添加图层
@param [in] ptrLayer 图层
@param [in] index    索引
@return void

</member>
        <member name="M:SysCarto.MultiLayer.AddLayer(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 添加图层
@param [in] ptrLayer 图层
@return void

</member>
        <member name="M:SysCarto.MultiLayer.SetDataset(SysUtility._ptr_t&lt;SysDataSource.MultiDataset&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置数据集
@param [in] ptrDataset 多数据集
@return void

</member>
        <member name="M:SysCarto.MultiLayer.GetExtent">
@brief 获取范围
@return  SysGeometry::EnvelopePtr 包络线范围

</member>
        <member name="M:SysCarto.MultiLayer.Dispose">
@brief 析构函数

</member>
        <member name="M:SysCarto.MultiLayer.#ctor">
@brief 构造函数

</member>
        <member name="D:SysDataSource.MultiDatasetPtr">
@brief 多数据集 智能指针

</member>
        <member name="F:SysDataSource.MultiDataset.m_vecDataset">
@brief 数据集集合

</member>
        <member name="M:SysDataSource.MultiDataset.DeleteDataset(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 删除数据集
@param [in] strName 数据集名称
@return bool 是否成功

</member>
        <member name="M:SysDataSource.MultiDataset.DeleteDataset(System.Int32)">
@brief 删除数据集
@param [in] nIndex 数据集索引号
@return bool 是否成功

</member>
        <member name="M:SysDataSource.MultiDataset.GetDataset(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 根据名称查找数据集
@param [in] strName 名称
@return  SysDataSource::DatasetPtr 数据集

</member>
        <member name="M:SysDataSource.MultiDataset.GetDataset(System.Int32)">
@brief 根据索引查找数据集
@param [in] nIndex  索引
@return  SysDataSource::DatasetPtr 数据集

</member>
        <member name="M:SysDataSource.MultiDataset.GetDatasetCount">
@brief 获取数据集个数
@return int 数据集个数

</member>
        <member name="M:SysDataSource.MultiDataset.AddDataset(SysUtility._ptr_t&lt;SysDataSource.Dataset&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 添加数据集
@param [in] ptrDatset  数据集
@return void

</member>
        <member name="M:SysDataSource.MultiDataset.Open(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 打开
@param [in] strPath 
@return 

</member>
        <member name="M:SysDataSource.MultiDataset.Dispose">
@brief 析构函数

</member>
        <member name="M:SysDataSource.MultiDataset.#ctor">
@brief 构造函数

</member>
        <member name="T:SysDataSource.MultiDataset">
@class MultiDataset
	* @brief 多数据集

</member>
        <member name="F:SysDataSource.Dataset.m_bCanWrite">
@brief 是否可以写入 布尔变量

</member>
        <member name="F:SysDataSource.Dataset.m_bCanCopy">
@brief 是否可以拷贝 布尔变量

</member>
        <member name="F:SysDataSource.Dataset.m_ptrSpatialReference">
@brief 控件参考

</member>
        <member name="F:SysDataSource.Dataset.m_eDatasetType">
@brief 数据集类型

</member>
        <member name="F:SysDataSource.Dataset.m_strFullName">
@brief 全名

</member>
        <member name="F:SysDataSource.Dataset.m_strName">
@brief 名称

</member>
        <member name="M:SysDataSource.Dataset.Dispose">
@brief 析构函数

</member>
        <member name="M:SysDataSource.Dataset.#ctor">
@brief 构造函数

</member>
        <member name="M:SysDataSource.Dataset.CloneMemDataset">
@brief 对内存数据集进行Clone. 如果不是内存数据集，返回空
@return

</member>
        <member name="M:SysDataSource.Dataset.ClearInternalData">
@brief 清除内部缓存
@return bool 是否成功

</member>
        <member name="M:SysDataSource.Dataset.GetMetadata(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 获取元数据
@param [in] const QString 输入信息
@return  char** 元数据指针

</member>
        <member name="M:SysDataSource.Dataset.GetMetadataDomainList">
@brief 获取数据域列表
@return

</member>
        <member name="M:SysDataSource.Dataset.SetMetadataItem(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@brief 设置元数据信息
@param [in] pszName   名字
@param [in] pszDomain 区域
@return

</member>
        <member name="M:SysDataSource.Dataset.GetMetadataItem(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@brief 获取元数据信息
@param [in] pszName   名字
@param [in] pszDomain 区域
@return char * 元数据信息描述

</member>
        <member name="M:SysDataSource.Dataset.SetMetadata(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@brief 设置元数据
@param [in] papszMetadata ** 输入信息
@para  [in] const char * pszDomain 域

</member>
        <member name="M:SysDataSource.Dataset.GetMetadata(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@brief 获取元数据
@param [in] const char * 输入信息
@return  char** 元数据指针

</member>
        <member name="M:SysDataSource.Dataset.GetInternalHandle">
@brief 获取内部句柄
@return void* 内部句柄指针

</member>
        <member name="M:SysDataSource.Dataset.CanCopy">
@brief 是否可以进行文件级复制
@return  bool 是否成功

</member>
        <member name="M:SysDataSource.Dataset.CanWrite">
@brief 是否可写
@return bool 是否成功

</member>
        <member name="M:SysDataSource.Dataset.Copy(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 复制为指定路径下
@param [in] strFullName 文件路径名称
@return bool 是否成功

</member>
        <member name="M:SysDataSource.Dataset.SetSpatialReference(SysUtility._ptr_t&lt;SysGeometry.SpatialReference&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置空间参考
@param ptrSpatialRef  空间参考对象指针
@return void 

</member>
        <member name="M:SysDataSource.Dataset.GetSpatialReference">
@brief 获取空间参考
@return SysGeometry::SpatialReferencePtr 空间参考

</member>
        <member name="M:SysDataSource.Dataset.GetDataSourceType">
@brief 获取数据源类型
@return QString 数据源类型

</member>
        <member name="M:SysDataSource.Dataset.GetType">
@brief 获取数据集类型 
@return DatasetType 数据集类型

</member>
        <member name="M:SysDataSource.Dataset.SetName(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置名称
@param [in] strName 名称 
@return void

</member>
        <member name="M:SysDataSource.Dataset.GetName">
@brief 获取名称
@return QString 名称

</member>
        <member name="M:SysDataSource.Dataset.GetFullName">
@brief 获取全路径名
@return QString 全路径名

</member>
        <member name="T:SysDataSource.Dataset">
@brief 类的前置声明和智能指针定义


@class Dataset
@brief 数据集基类

</member>
        <member name="D:SysCarto.GroupLayerPtr">
@brief   组图层  智能指针对象

</member>
        <member name="F:SysCarto.GroupLayer.m_bExpanded">
@brief 是否展开

</member>
        <member name="F:SysCarto.GroupLayer.m_vecLayers">
@brief 图层集合

</member>
        <member name="M:SysCarto.GroupLayer.CopyTo(SysCarto.Layer*)">
@brief 拷贝到Layer
@param [in] Layer* Layer对象

</member>
        <member name="M:SysCarto.GroupLayer.Refresh">
@brief 刷新
@return void

</member>
        <member name="M:SysCarto.GroupLayer.Clone">
@brief 克隆
@return LayerPtr 克隆图层对象

</member>
        <member name="M:SysCarto.GroupLayer.Draw(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUI.LayerDrawPhaseType,SysUtility._ptr_t&lt;SysUI.TrackerCancel&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制
@param [in] painter   绘图设备
@param [in] ptrTrans  显示转换对象
@param [in] dpType    类型
@param [in] ptrTracker   取消转换
@return void

</member>
        <member name="M:SysCarto.GroupLayer.Clear">
@brief  清空
@return void

</member>
        <member name="M:SysCarto.GroupLayer.SetExpanded(System.Boolean)">
@brief  设置是否展开图层 
@param  [in] bExpanded  是否展开
@return void

</member>
        <member name="M:SysCarto.GroupLayer.GetExpanded">
@brief  获取是否展开图层 
@return bool 是 true,否 false

</member>
        <member name="M:SysCarto.GroupLayer.GetLayer(System.Int32)">
@brief  获取图层
@param  [in] toIndex   图层索引
@return LayerPtr  图层

</member>
        <member name="M:SysCarto.GroupLayer.GetLayerCount">
@brief  获取图层数量
@return int 图层数量

</member>
        <member name="M:SysCarto.GroupLayer.MoveLayer(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief  移动图层
@param  [in] ptrLayer  图层对象
@param  [in] toIndex   图层索引
@return void

</member>
        <member name="M:SysCarto.GroupLayer.Delete(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  删除图层
@param [in] ptrLayer  图层对象
@return void

</member>
        <member name="M:SysCarto.GroupLayer.DeleteLayer(System.Int32)">
@brief  添加图层
@param [in] ptrLayer  图层对象
@param [in] index     索引编号
@return void

</member>
        <member name="M:SysCarto.GroupLayer.AddLayer(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
@brief  添加图层
@param [in] ptrLayer  图层对象
@param [in] index     索引编号
@return void

</member>
        <member name="M:SysCarto.GroupLayer.AddLayer(SysUtility._ptr_t&lt;SysCarto.Layer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  添加图层
@param [in] ptrLayer  图层对象
@return void

</member>
        <member name="M:SysCarto.GroupLayer.GetExtent">
@brief 获取范围
@return  SysGeometry::EnvelopePtr 包络线范围

</member>
        <member name="M:SysCarto.GroupLayer.Dispose">
@brief 析构函数

</member>
        <member name="M:SysCarto.GroupLayer.#ctor">
@brief 构造函数

</member>
        <member name="F:SysCarto.Layer.m_pCacheModel">
@brief 线程缓存模型

</member>
        <member name="F:SysCarto.Layer.m_bRequireRefresh">
@brief 是否刷新视图

</member>
        <member name="F:SysCarto.Layer.m_ptrSRef">
@brief 图层空间参考

</member>
        <member name="F:SysCarto.Layer.m_ptrAreaOfInterestEnv">
@brief 可见区域

</member>
        <member name="F:SysCarto.Layer.m_dMinimumScale">
@brief 最小比例尺

</member>
        <member name="F:SysCarto.Layer.m_dMaximumScale">
@brief 最大比例尺

</member>
        <member name="F:SysCarto.Layer.m_bIsVisible">
@brief 图层是否可见

</member>
        <member name="F:SysCarto.Layer.m_bIsValid">
@brief 是否是有效图层

</member>
        <member name="F:SysCarto.Layer.m_strDesc">
@brief 图层描述信息

</member>
        <member name="F:SysCarto.Layer.m_layerType">
@brief 图层类型

</member>
        <member name="F:SysCarto.Layer.m_strDataSourcePath">
@brief 数据路径

</member>
        <member name="F:SysCarto.Layer.m_strName">
@brief 图层名称

</member>
        <member name="F:SysCarto.Layer.m_strID">
@brief  图层ID

</member>
        <member name="M:SysCarto.Layer.CopyTo(SysCarto.Layer*)">
@brief 拷贝到Layer
@param [in] Layer* Layer对象

</member>
        <member name="M:SysCarto.Layer.GetOffset(System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 获取渲染位移。
@return void

</member>
        <member name="M:SysCarto.Layer.SetOffset(System.Double,System.Double)">
@brief 设置渲染位移。只影响图层的渲染位置。单位与map可见范围的单位相同
@return void

</member>
        <member name="M:SysCarto.Layer.Refresh">
@brief  刷新图层
@return void 

</member>
        <member name="M:SysCarto.Layer.Clone">
@brief 克隆
@return LayerPtr 克隆对象

</member>
        <member name="M:SysCarto.Layer.RaisePropertyChanged">
@brief 触发属性变化事件
@return void 
@remark 当属性变化时，调用此方法触发属性变化事件

</member>
        <member name="M:SysCarto.Layer.IsRequireRefresh">
@brief 是否需要刷新视图
@return  bool  是否刷洗

</member>
        <member name="M:SysCarto.Layer.Draw(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUI.LayerDrawPhaseType,SysUtility._ptr_t&lt;SysUI.TrackerCancel&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制图层
@param [in] painter 绘图设备对象
@param [in] ptrTransform 显示转换对象
@param [in] dpType 绘图类型
@param [in] ptrTrackerCancel  取消轨迹
@return  void

</member>
        <member name="M:SysCarto.Layer.GetSpatialReference">
@brief 获得图层空间参考
@return SysGeometry::SpatialReferencePtr 空间参考对象

</member>
        <member name="M:SysCarto.Layer.SetMinimumScale(System.Double)">
@brief 设置图层可见最小比例尺
@param[in] double scale  最小比例尺
@return void

</member>
        <member name="M:SysCarto.Layer.GetMinimumScale">
@brief 获得图层可见最小比例尺
@return  double 最小比例尺

</member>
        <member name="M:SysCarto.Layer.SetMaximumScale(System.Double)">
@brief 设置图层可见最大比例尺
@param[in] double scale 最大比例尺
@return  void

</member>
        <member name="M:SysCarto.Layer.GetMaximumScale">
@brief  获得图层可见最大比例尺
@return double 最大比例尺

</member>
        <member name="M:SysCarto.Layer.SetAreaOfInterest(SysUtility._ptr_t&lt;SysGeometry.Envelope&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置可见区域
@param[in] SysGeometry::EnvelopePtr ptrEnv  包络线范围
@return  void

</member>
        <member name="M:SysCarto.Layer.GetExtent">
@brief 获得图层范围
@return  SysGeometry::EnvelopePtr 图层范围  

</member>
        <member name="M:SysCarto.Layer.SetVisibility(System.Boolean)">
@brief 设置图层可见性
@param[in] bool visible 是否可见
@return void

</member>
        <member name="M:SysCarto.Layer.GetVisibility">
@brief 获取图层可见性
@return  bool  是否可见

</member>
        <member name="M:SysCarto.Layer.IsValid">
@brief 是否是有效图层
@return  bool  是否有效

</member>
        <member name="M:SysCarto.Layer.GetLayerType">
@brief 获取图层类型
@return  LayerType 图层类型

</member>
        <member name="M:SysCarto.Layer.SetDescription(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置图层描述信息
@param [in] strDesc 图层描述信息
@return void

</member>
        <member name="M:SysCarto.Layer.GetDescription">
@brief 获得图层描述信息
@return QString 图层描述信息

</member>
        <member name="M:SysCarto.Layer.GetDataSourcePath">
@brief 获得数据路径
@return QString 数据路径

</member>
        <member name="M:SysCarto.Layer.GetName">
@brief 获得图层名称 
@return  QString 图层名称

</member>
        <member name="M:SysCarto.Layer.GetID">
@brief 获得图层ID
@return  QString  图层ID

</member>
        <member name="M:SysCarto.Layer.Dispose">
@brief 析构函数

</member>
        <member name="M:SysCarto.Layer.#ctor">
@brief 构造函数

</member>
        <member name="T:SysCarto.MultiLayer">
@brief 声明多数据集图层为当前类的友元类


@class MultiLayer
@brief 多图层

</member>
        <member name="T:SysCarto.GroupLayer">
@brief 声明图层组图层为当前类的友元类


@class GroupLayer
@brief  组图层

</member>
        <member name="T:SysCarto.AnimationLayer">
@brief 声明动画图层为当前类的友元类

</member>
        <member name="T:SysCarto.LayerConstructInfo">
@brief 声明图层创建类为当前类的友元类

</member>
        <member name="T:SysCarto.Map">
@brief 声明地图类为当前类的友元类


@brief 类的前置声明和智能指针定义


@class Map
@brief 地图

</member>
        <member name="T:SysCarto.LayerSerializer">
@brief 声明图层序列化类为当前类的友元类

</member>
        <member name="T:SysCarto.ViewState">
@class  ViewState
@brief  视图状态  枚举

</member>
        <member name="F:ViewStateRenderCompleted">
@brief  渲染完成

</member>
        <member name="F:ViewStateDataLoaded">
@brief  数据加载完成

</member>
        <member name="F:ViewStateNone">
@brief  无

</member>
        <member name="T:SysCarto.LayerCacheModelType">
@class  LayerCacheModelType
@brief  图层缓存类型

</member>
        <member name="F:LayerCacheModelType_LabelCacheModel">
@brief  注记缓存模型

</member>
        <member name="F:LayerCacheModelType_ImageTileModel">
@brief  瓦片图像缓存模型

</member>
        <member name="F:LayerCacheModelType_ImageModel">
@brief  普通图像缓存模型

</member>
        <member name="F:LayerCacheModelType_Unkown">
@brief  普通图像缓存模型

</member>
        <member name="T:SysCarto.LayerType">
@class  LayerType
@brief  图层类型 枚举

</member>
        <member name="F:LayerTypeAnimationLayer">
@brief  动画图层类型

</member>
        <member name="F:LayerTypeTiledLayer">
@brief  瓦片图层类型

</member>
        <member name="F:LayerTypeMultiLayer">
@brief  多图层类型

</member>
        <member name="F:LayerTypeGroupLayer">
@brief  组图层类型

</member>
        <member name="F:LayerTypeGraphicsLayer">
@brief  图形图层类型

</member>
        <member name="F:LayerTypeFeatureLayer">
@brief  矢量要素图层类型

</member>
        <member name="F:LayerTypeRasterLayer">
@brief  栅格图层类型

</member>
        <member name="F:LayerTypeUnknown">
@brief  未知类型

</member>
        <member name="F:SysCarto.ILayerEvents.PropertyChanged">
@brief  属性改变信号

</member>
        <member name="F:SysCarto.ILayerEvents.RenderChanged">
@brief  渲染改变信号

</member>
        <member name="F:SysCarto.ILayerEvents.VisibilityChanged">
@brief  可见性改变信号

</member>
        <member name="T:SysCarto.ILayerEvents">
@class ILayerEvents
@brief  图层事件

</member>
        <member name="T:SysCarto.Layer">
@brief   类的前置声明


@brief 类的前置声明和智能指针对象


@class Layer
@brief 图层基类

</member>
        <member name="T:SysUI.LayerDrawPhaseType">
@class DrawPhaseType
	* @brief 绘图类型

</member>
        <member name="F:DPSelection">
@brief  选择集

</member>
        <member name="F:DPAnnotation">
@brief  标注

</member>
        <member name="F:DPGeography">
@brief  Geo图形

</member>
        <member name="F:SysDataSource.Feature.m_pFeatureClass">
@brief 要素类对象指针

</member>
        <member name="F:SysDataSource.Feature.m_vecField">
@brief 字段集合

</member>
        <member name="F:SysDataSource.Feature.m_ptrGeometry">
@brief 几何对象

</member>
        <member name="F:SysDataSource.Feature.m_ptrFields">
@brief 字段

</member>
        <member name="F:SysDataSource.Feature.m_nFID">
@brief FID值

</member>
        <member name="M:SysDataSource.Feature.GetFeatureClass">
@brief 获取要素类
@return FeatureClass* 要素类对象指针

</member>
        <member name="M:SysDataSource.Feature.Clone">
@brief 克隆
@return FeaturePtr 克隆成果

</member>
        <member name="M:SysDataSource.Feature.GetFields">
@brief 获取字段定义
@return  FieldsPtr 字段对象指针

</member>
        <member name="M:SysDataSource.Feature.IsValueNull(System.Int32)">
@brief 字段是否为空
@param [in] nIndex 字段索引
@return bool  是否为空

</member>
        <member name="M:SysDataSource.Feature.GetValueAsString(System.Int32)">
@brief 获取字段值的字符串
@param [in] nIndex 索引
@return  QString  字符串

</member>
        <member name="M:SysDataSource.Feature.GetValue(System.Int32)">
@brief 获取字段值
@param [in] nIndex 索引
@return QVariant 字段值

</member>
        <member name="M:SysDataSource.Feature.GetValue(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 获取字段值
@param [in] strFieldName 字段名
@return QVariant 字段值

</member>
        <member name="M:SysDataSource.Feature.SetValue(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,QVariant!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置字段值
@param [in] strFieldName 字段名称
@param [in] field 值
@return void

</member>
        <member name="M:SysDataSource.Feature.SetValue(System.Int32,QVariant!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置字段值
@param [in] nIndex 字段索引
@param [in] field 值
@return void

</member>
        <member name="M:SysDataSource.Feature.SetFID(System.Int64)">
@brief 设置FID
@param [in] nFID
@return void

</member>
        <member name="M:SysDataSource.Feature.GetFID">
@brief 获取FID
@return  qlonglong 获取FID

</member>
        <member name="M:SysDataSource.Feature.GetFieldType(System.Int32)">
@brief 获取字段类型
@param [in] nIndex 索引
@return FieldType 字段类型

</member>
        <member name="M:SysDataSource.Feature.GetFieldName(System.Int32)">
@brief 获取字段名
@param [in] nIndex 索引号
@return QString字段名

</member>
        <member name="M:SysDataSource.Feature.GetFieldIndex(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 获取字段索引
@param [in] strName 字段名
@return  int字段索引

</member>
        <member name="M:SysDataSource.Feature.GetFieldCount">
@brief 获取字段数量
@return int 字段数量

</member>
        <member name="M:SysDataSource.Feature.GetGeometry">
@brief 获取几何对象Geometry
@return   几何对象Geometry

</member>
        <member name="M:SysDataSource.Feature.SetGeometry(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置几何对象Geometry
@param [in] ptrGeometry 几何对象
@return void

</member>
        <member name="M:SysDataSource.Feature.Dispose">
@brief 析构函数

</member>
        <member name="M:SysDataSource.Feature.#ctor(SysUtility._ptr_t&lt;SysDataSource.Fields&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 构造函数

</member>
        <member name="T:SysDataSource.Feature">
@class Feature
	* @brief 矢量类

</member>
        <member name="T:SysDataSource.FeatureClass">
@brief 类的前置声明和智能指针定义


@brief 定义友元类

</member>
        <member name="D:SysDataSource.FieldsPtr">
@brief 字段集类 智能指针

</member>
        <member name="F:SysDataSource.Fields.m_bFieldIgnored">
@brief  是否忽略字段

</member>
        <member name="F:SysDataSource.Fields.m_bGeometryIgnored">
@brief  是否忽略Geometry 

</member>
        <member name="F:SysDataSource.Fields.m_vecField">
@brief  字段集合

</member>
        <member name="M:SysDataSource.Fields.SetPrecision(System.Int32,System.Int32)">
@brief  设置精度
@param [in] nIndex 索引号
@param [in] nPrecision 精度
@return void

</member>
        <member name="M:SysDataSource.Fields.GetPrecision(System.Int32)">
@brief  获取精度
@param [in] nIndex 索引号
@return int 精度

</member>
        <member name="M:SysDataSource.Fields.SetWidth(System.Int32,System.Int32)">
@brief  设置宽度
@param [in] nIndex 索引号
@param [in] nWidth 宽度
@return void 

</member>
        <member name="M:SysDataSource.Fields.GetWidth(System.Int32)">
@brief  获取宽度
@param [in] nIndex 索引号
@return int 宽度

</member>
        <member name="M:SysDataSource.Fields.IsFieldIgnored">
@brief  是否忽略字段
@return bool 是否忽略

</member>
        <member name="M:SysDataSource.Fields.IsGeometryIgnored">
@brief 是否忽略Geometry 
@return bool 是否忽略

</member>
        <member name="M:SysDataSource.Fields.DeleteField(System.Int32)">
@brief 删除字段 
@param [in] nIndex 字段索引
@return bool 是否成功

</member>
        <member name="M:SysDataSource.Fields.DeleteField(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 删除字段
@param [in] strName 字段名称
@return bool 是否成功

</member>
        <member name="M:SysDataSource.Fields.AddField(SysUtility._ptr_t&lt;SysDataSource.Field&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 添加字段
@param [in] ptrField 字段
@return bool 是否成功

</member>
        <member name="M:SysDataSource.Fields.AddField(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysDataSource.FieldType,System.Int32,System.Int32)">
@brief 添加字段
@param [in] strName 字段名称
@param [in] eType 字段类型
@param [in] nWidth 字段长度，以字节为单位
@param [in] nPrecision 字段精度
@return bool 是否成功

</member>
        <member name="M:SysDataSource.Fields.GetFieldIndex(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 获取字段索引号
@param [in] strName 字段名称
@return int 字段索引号

</member>
        <member name="M:SysDataSource.Fields.GetFieldCount">
@brief 获取字段数
@return int 字段数

</member>
        <member name="M:SysDataSource.Fields.GetFieldName(System.Int32)">
@brief 获取字段名称
@param [in] nIndex 索引
@return  QString 字段名称

</member>
        <member name="M:SysDataSource.Fields.GetFieldType(System.Int32)">
@brief 获取字段类型
@param [in] nIndex 索引
@return FieldType 字段类型

</member>
        <member name="M:SysDataSource.Fields.DeleteField(SysUtility._ptr_t&lt;SysDataSource.Field&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 删除字段
@param [in] nIndex 字段对象
@return void

</member>
        <member name="M:SysDataSource.Fields.GetField(System.Int32)">
@brief 根据索引获取字段对象
@param [in] nIndex 索引
@return FieldPtr 字段对象

</member>
        <member name="M:SysDataSource.Fields.Dispose">
@brief 析构函数

</member>
        <member name="M:SysDataSource.Fields.#ctor">
@brief 构造函数

</member>
        <member name="T:SysDataSource.FeatureDataset">
@brief  要素数据集

</member>
        <member name="T:SysDataSource.Fields">
@class Fields
	* @brief  字段集类

</member>
        <member name="F:SysDataSource.Field.m_nPrecision">
@brief 精度

</member>
        <member name="F:SysDataSource.Field.m_nWidth">
@brief 宽度

</member>
        <member name="F:SysDataSource.Field.m_enumFieldType">
@brief 字段类型  枚举变量

</member>
        <member name="F:SysDataSource.Field.m_DefaultValue">
@brief 默认值

</member>
        <member name="F:SysDataSource.Field.m_strAliasName">
@brief 别名

</member>
        <member name="F:SysDataSource.Field.m_strName">
@brief 名字

</member>
        <member name="M:SysDataSource.Field.Clone">
@brief 克隆
@return  FieldPtr 克隆结果 字段对象指针

</member>
        <member name="M:SysDataSource.Field.SetPrecision(System.Int32)">
@brief 设置精度
@param [in] nPrecision 精度
@return void

</member>
        <member name="M:SysDataSource.Field.GetPrecision">
@brief 获取精度
@return  int 精度

</member>
        <member name="M:SysDataSource.Field.SetWidth(System.Int32)">
@brief 设置宽度
@param [in] nWidth 宽度
@return void

</member>
        <member name="M:SysDataSource.Field.GetWidth">
@brief 获取宽度
@return  int 宽度

</member>
        <member name="M:SysDataSource.Field.SetFieldType(SysDataSource.FieldType)">
@brief 设置字段类型
@param [in] type 字段类型
@return void

</member>
        <member name="M:SysDataSource.Field.GetFieldType">
@brief 获取字段类型
@return FieldType  字段类型

</member>
        <member name="M:SysDataSource.Field.SetDefaultValue(QVariant!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置默认值
@param [in] value  默认值
@return void 

</member>
        <member name="M:SysDataSource.Field.GetDefaultValue">
@brief 获取默认值
@return QVariant  默认值

</member>
        <member name="M:SysDataSource.Field.SetAliasName(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置别名
@param [in] strAliasName 字段别名
@return void

</member>
        <member name="M:SysDataSource.Field.GetAliasName">
@brief 获取别名
@return QString 字段别名

</member>
        <member name="M:SysDataSource.Field.SetName(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置名称
@param [in] strAliasName 字段别名
@return void

</member>
        <member name="M:SysDataSource.Field.GetName">
@brief 获取名称
@return QString 名称

</member>
        <member name="M:SysDataSource.Field.Dispose">
@brief 析构函数

</member>
        <member name="M:SysDataSource.Field.#ctor(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysDataSource.FieldType,System.Int32,System.Int32)">
@brief 有参构造函数
@param [in] strName 名称
@param [in] eType   类型
@param [in] nWidth  宽度
@param [in] nPrecision 精度

</member>
        <member name="T:SysDataSource.Field">
@brief 类的前置声明和智能指针定义


@class Field
	* @brief 字段类

</member>
        <member name="T:SysDataSource.DadaSampleType">
@class DadaSampleType
	* @brief  数据样式类型 枚举

</member>
        <member name="D:SysCarto.FrameElementBasePtr">
@brief 框架元素基类  智能指针对象

</member>
        <member name="M:SysCarto.FrameElementBase.CopyTo(SysCarto.FrameElementBase*)">
@brief 拷贝到pFrameElementBase
@param [in] FrameElementBase* pFrameElementBase 框架元素基类对象
@return void

</member>
        <member name="M:SysCarto.FrameElementBase.DrawShadow(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制阴影
@param [in] painter 绘图面板
@param [in] ptrTrasform 显示转换对象
@return void

</member>
        <member name="M:SysCarto.FrameElementBase.DrawBackground(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制打印页面背景 
@param [in] painter 绘图面板
@param [in] ptrTrasform 显示转换对象
@return void

</member>
        <member name="M:SysCarto.FrameElementBase.DrawBorder(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制页面边框 
@param [in] painter 绘图面板
@param [in] ptrTrasform 显示转换对象
@return void

</member>
        <member name="M:SysCarto.FrameElementBase.DrawFrame(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制Frame
@param [in] painter 绘图面板
@param [in] ptrTrasform 显示转换对象
@return void

</member>
        <member name="M:SysCarto.FrameElementBase.QueryFrameBounds(SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 获取框架边界
@param [in] ptrTrasform 显示转换对象
@return SysGeometry::EnvelopePtr   包络线范围对象

</member>
        <member name="M:SysCarto.FrameElementBase.Draw(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysUI.TrackerCancel&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制
@param [in] paiter 绘图面板
@param [in] ptrTrasform 显示转换对象
@param [in] ptrTracker 取消追踪对象
@return void

</member>
        <member name="M:SysCarto.FrameElementBase.Dispose">
@brief 析构函数

</member>
        <member name="M:SysCarto.FrameElementBase.#ctor">
@brief 构造函数

</member>
        <member name="T:SysCarto.FrameElementBase">
@class FrameElementBase
@brief  框架元素基类

</member>
        <member name="F:SysCarto.Element.m_bLocked">
@brief  是否加锁变量

</member>
        <member name="F:SysCarto.Element.m_bFixedSize">
@brief  是否按原比例大小变量

</member>
        <member name="F:SysCarto.Element.m_AnchorPoint">
@brief  锚点

</member>
        <member name="F:SysCarto.Element.m_bRatioed">
@brief  是否按纵横比缩放变量

</member>
        <member name="F:SysCarto.Element.m_CusomerProperty">
@brief  用户属性

</member>
        <member name="F:SysCarto.Element.m_ptrGeometry">
@brief  几何对象

</member>
        <member name="F:SysCarto.Element.m_ElementType">
@brief  元素类型

</member>
        <member name="F:SysCarto.Element.m_bVisible">
@brief  是否可视化变量

</member>
        <member name="F:SysCarto.Element.m_bCanRotate">
@brief  是否可以旋转变量

</member>
        <member name="F:SysCarto.Element.m_strName">
@brief  名称

</member>
        <member name="F:SysCarto.Element.m_strID">
@brief  ID

</member>
        <member name="M:SysCarto.Element.Dispose">
@brief 析构函数

</member>
        <member name="M:SysCarto.Element.#ctor">
@brief 构造函数

</member>
        <member name="M:SysCarto.Element.CopyTo(SysCarto.Element*)">
@brief 拷贝到Element
@param [in] Element* ptrElement Element对象

</member>
        <member name="M:SysCarto.Element.Clone">
@brief 克隆
@return ElementPtr 克隆对象

</member>
        <member name="M:SysCarto.Element.GetAnchorPoint">
@brief 获取锚点
@return 

</member>
        <member name="M:SysCarto.Element.SetAnchorPoint(SysCarto.pieAnchorPointEnum)">
@brief 设置锚点
@param [in] pos 
@return 

</member>
        <member name="M:SysCarto.Element.SetLocked(System.Boolean)">
@brief 设置是否被锁定
@param [in] bLocked  是否被锁定
@return void

</member>
        <member name="M:SysCarto.Element.IsLocked">
@brief 是否被锁定。被锁定之后无法被选中。
@return bool 是否被锁定

</member>
        <member name="M:SysCarto.Element.GetFixedSize">
@brief 获取原比例大小
@return bool 是否成功

</member>
        <member name="M:SysCarto.Element.SetFixedAspectRatio(System.Boolean)">
@brief 设置是否按原比例缩放 
@param [in] bRatioed 是否设置
@return void 

</member>
        <member name="M:SysCarto.Element.GetFixedAspectRatio">
@brief 获取是否按原比例缩放 
@return bool 是否成功

</member>
        <member name="M:SysCarto.Element.Scale(SysUtility._ptr_t&lt;SysGeometry.Point&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
@brief 缩放
@param [in] PointPtr originPoint 参照点
@param [in] double sx x方向缩放
@param [in] double sy y方向缩放
@return bool 是否成功

</member>
        <member name="M:SysCarto.Element.Rotate(SysUtility._ptr_t&lt;SysGeometry.Point&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
@brief 旋转
@param [in] PointPtr originPoint 参照点
@param [in] double rotationAngle 旋转角度
@return bool 是否成功

</member>
        <member name="M:SysCarto.Element.Move(System.Double,System.Double)">
@brief 移动
@param [in] double dx x方向的偏移
@param [in] double dy y方向的偏移
@return bool 是否成功

</member>
        <member name="M:SysCarto.Element.QueryBounds(SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  查询边界
@param [in] ptrTrasform  显示转换对象
@return  SysGeometry::EnvelopePtr  包络线对象

</member>
        <member name="M:SysCarto.Element.Draw(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysUI.TrackerCancel&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  绘制
@param [in] painter  绘图设备
@param [in] ptrTrasform  显示转换对象
@param [in] ptrTracker   取消转换
@return  void

</member>
        <member name="M:SysCarto.Element.HitTest(System.Double,System.Double,System.Double)">
@brief 点击测试
@param [in]  x  X坐标值
@param [in]  y  Y坐标值
@param [in]  tolerance  偏差量
@return bool  是否成功

</member>
        <member name="M:SysCarto.Element.SetVisibility(System.Boolean)">
@brief  设置可见
@param [in] bVisible 是否设置可见
@return void

</member>
        <member name="M:SysCarto.Element.IsVisible">
@brief 是否可见
@return bool 是 true, 否 false

</member>
        <member name="M:SysCarto.Element.GetExtent">
@brief 获取范围
@return SysGeometry::EnvelopePtr 范围

</member>
        <member name="M:SysCarto.Element.SetGeometry(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  设置几何类型
@param [in] ptrGeometry 几何类型
@return void

</member>
        <member name="M:SysCarto.Element.GetGeometry">
@brief 获取几何类型
@return SysGeometry::GeometryPtr  几何类型

</member>
        <member name="M:SysCarto.Element.SetCusomerProperty(QVariant!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  设置用户属性
@param [in] prop 万能数据类型(QT内置数据类型）
@return void

</member>
        <member name="M:SysCarto.Element.GetCustomerProperty">
@brief 获取用户属性
@return QVariant 用户属性

</member>
        <member name="M:SysCarto.Element.CanRotate">
@brief 是否可以旋转
@return bool 是true,否 false

</member>
        <member name="M:SysCarto.Element.GetElementType">
@brief 获取元素类型
@return ElementType 元素类型

</member>
        <member name="M:SysCarto.Element.SetName(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  设置名字
@param [in] name 名字
@return void

</member>
        <member name="M:SysCarto.Element.GetName">
@brief 获取名字
@return QString 名字

</member>
        <member name="M:SysCarto.Element.GetID">
@brief 获取ID
@return QString ID

</member>
        <member name="T:SysCarto.IGraphicsContainer">
@brief 声明友元类


@class IGraphicsContainer
@brief 图元容器接口

</member>
        <member name="T:SysCarto.Element">
@brief 类的前置声明和智能指针定义


@class Element
@brief 元素


@brief   类的前置声明和智能指针定义

</member>
        <member name="T:SysCarto.ElementType">
@class  ElementType
@brief  元素类型 枚举

</member>
        <member name="F:ElementScrew">
@brief 螺旋形

</member>
        <member name="F:ElementLineArrow">
@brief 线箭头

</member>
        <member name="F:ElementArrow">
@brief 箭头

</member>
        <member name="F:ElementCurve">
@brief 曲线

</member>
        <member name="F:ElementMapSurroundFrame">
@brief 圆

</member>
        <member name="F:ElementMapFrame">
@brief 地图框架

</member>
        <member name="F:ElementGroup">
@brief 组

</member>
        <member name="F:ElementText">
@brief 文本

</member>
        <member name="F:ElementFrame">
@brief 框架

</member>
        <member name="F:ElementPicture">
@brief 图片

</member>
        <member name="F:ElementRectangle">
@brief 矩形

</member>
        <member name="F:ElementCircle">
@brief 圆

</member>
        <member name="F:ElementEllipse">
@brief 椭圆

</member>
        <member name="F:ElementPolygon">
@brief 面

</member>
        <member name="F:ElementPolyline">
@brief 线

</member>
        <member name="F:ElementMarker">
@brief 点

</member>
        <member name="F:ElementUnknown">
@brief 无类型

</member>
        <member name="D:SysUI.TrackerCancelPtr">
@brief 取消追踪器类智能指针

</member>
        <member name="F:SysUI.TrackerCancel.m_mutex">
@brief 互斥锁

</member>
        <member name="F:SysUI.TrackerCancel.m_State">
@brief 状态

</member>
        <member name="M:SysUI.TrackerCancel.Reset">
@brief 重置
@return

</member>
        <member name="M:SysUI.TrackerCancel.IsCanced">
@brief 是否已经取消
@return

</member>
        <member name="M:SysUI.TrackerCancel.Cancel">
@brief 取消
@return

</member>
        <member name="M:SysUI.TrackerCancel.Dispose">
@brief 析构函数
@return

</member>
        <member name="M:SysUI.TrackerCancel.#ctor">
@brief 构造函数

</member>
        <member name="T:SysUI.TrackerCancel">
@class TrackerCancel
	* @brief  取消追踪器类

</member>
        <member name="D:SysCarto.RulerSettingsPtr">
@brief  标尺类   智能指针

</member>
        <member name="F:SysCarto.RulerSettings.m_nDeflateWid">
@brief 标尺缩小宽度

</member>
        <member name="F:SysCarto.RulerSettings.m_nRulerWid">
@brief 标尺的宽度

</member>
        <member name="M:SysCarto.RulerSettings.GetDeflateWid">
@brief 获取缩小宽度
@return int 缩小宽度

</member>
        <member name="M:SysCarto.RulerSettings.GetWidth">
@brief 获取宽度
@return int 宽度

</member>
        <member name="M:SysCarto.RulerSettings.Dispose">
@brief 析构函数

</member>
        <member name="M:SysCarto.RulerSettings.#ctor">
@brief 构造函数

</member>
        <member name="T:SysCarto.RulerSettings">
@class RulerSettings
@brief 标尺类

</member>
        <member name="F:SysCarto.SnapGrid.m_bVisible">
@brief 是否可视化

</member>
        <member name="F:SysCarto.SnapGrid.m_dSpacingV">
@brief 垂直间隔

</member>
        <member name="F:SysCarto.SnapGrid.m_dSpacingH">
@brief 水平间隔

</member>
        <member name="M:SysCarto.SnapGrid.SetVisility(System.Boolean)">
@brief 设置可视化
@param [in] visble 可视化
@return  void

</member>
        <member name="M:SysCarto.SnapGrid.IsVisible">
@brief 是否可视化
@return  bool  是否可视化

</member>
        <member name="M:SysCarto.SnapGrid.SetVerticalSpacing(System.Double)">
@brief 设置垂直间隔
@param [in] space 间隔
@return  void

</member>
        <member name="M:SysCarto.SnapGrid.GetVerticalSpacing">
@brief 获取垂直间隔
@return  double  垂直间隔

</member>
        <member name="M:SysCarto.SnapGrid.SetHorizontalSpacing(System.Double)">
@brief 设置水平间隔
@param[in] space 间隔
@return  void

</member>
        <member name="M:SysCarto.SnapGrid.GetHorizontalSpacing">
@brief 获取水平间隔
@return  double  水平间隔

</member>
        <member name="M:SysCarto.SnapGrid.Dispose">
@brief 析构函数

</member>
        <member name="M:SysCarto.SnapGrid.#ctor">
@brief 构造函数

</member>
        <member name="T:SysCarto.SnapGrid">
@class SnapGrid
@brief 捕捉网格线

</member>
        <member name="D:SysCarto.PagePtr">
@brief  页面  智能指针对象

</member>
        <member name="F:SysCarto.Page.m_ptrPaper">
@brief 页面

</member>
        <member name="F:SysCarto.Page.m_units">
@brief 单元

</member>
        <member name="F:SysCarto.Page.m_nOrientation">
@brief 方向

</member>
        <member name="M:SysCarto.Page.GetPageEnvelope">
@brief 获取页面包络线
@return SysGeometry::EnvelopePtr  页面包络线

</member>
        <member name="M:SysCarto.Page.Clone">
@brief 克隆
@return  Page* 新克隆的对象指针

</member>
        <member name="M:SysCarto.Page.GetPaper">
@brief 获取纸张
@return  PaperPtr 纸张对象

</member>
        <member name="M:SysCarto.Page.Draw(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制
@param [in] painter  绘制面板
@param [in] ptrTransform  显示转换对象
@return void

</member>
        <member name="M:SysCarto.Page.DrawPrintableArea(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制打印可视区域 
@param [in] painter  绘制面板
@param [in] ptrTransform  显示转换对象
@return void

</member>
        <member name="M:SysCarto.Page.DrawPaper(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制纸张
@param [in] painter  绘制面板
@param [in] ptrTransform  显示转换对象
@return void

</member>
        <member name="M:SysCarto.Page.DrawBorder(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制边界
@param [in] painter  绘制面板
@param [in] ptrTransform  显示转换对象
@return void

</member>
        <member name="M:SysCarto.Page.DrawBackground(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制背景
@param [in] painter  绘制面板
@param [in] ptrTransform  显示转换对象
@return void

</member>
        <member name="M:SysCarto.Page.SetUnits(SysUI.pieUnits)">
@brief 设置单元
@param [in] SysUI::pieUnits  单元
@return void

</member>
        <member name="M:SysCarto.Page.GetUnits">
@brief 获取单元
@return  SysUI::pieUnits  单元

</member>
        <member name="M:SysCarto.Page.SetStretchGraphicsWithPage(System.Boolean)">
@brief 设置制图对象是否随页面拉伸
@param [in] bStretch  是否拉伸
@return void

</member>
        <member name="M:SysCarto.Page.IsStretchGraphicsWithPage">
@brief 获取制图对象是否随页面拉伸 
@return bool 是否随页面拉伸 

</member>
        <member name="M:SysCarto.Page.QuerySize(System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 查询获取大小
@param [in out] dWidth   宽度
@param [in out] dHeight  高度
@return void

</member>
        <member name="M:SysCarto.Page.PutCustomSize(System.Double,System.Double)">
@brief 赋予定制的大小
@param [in] dWidth   宽度
@param [in] dHeight  高度
@return void

</member>
        <member name="M:SysCarto.Page.GetPrinterPageCount(SysCarto.IPrinter*)">
@brief 获取获取打印页数
@param [in] IPrinter* pPrinter  打印对象
@return int 打印页数

</member>
        <member name="M:SysCarto.Page.GetPrintableBounds">
@brief 获取打印页面外接多边形 
@return  SysGeometry::EnvelopePtr  外接多边形

</member>
        <member name="M:SysCarto.Page.SetOrientation(System.Int16)">
@brief 设置方向值
@param [in] ori  方向值 (1 纵向 2 横向)
@return void

</member>
        <member name="M:SysCarto.Page.GetOrientation">
@brief 获取方向
@return short  方向值 (1 纵向 2 横向)

</member>
        <member name="M:SysCarto.Page.SetPrintableAreaVisible(System.Boolean)">
@brief 设置打印页面是否显示边界
@param [in] bVisible 是否显示边界
@return void

</member>
        <member name="M:SysCarto.Page.IsPrintableAreaVisible">
@brief 获取打印页面是否显示边界 
@return bool  是否显示边界

</member>
        <member name="M:SysCarto.Page.GetPageBounds(SysCarto.IPrinter*,System.Int16,System.Double,System.Double)">
@brief 获取页面边界
@param [in] paiter 打印对象
@param [in] currentPage 当前页面
@param [in] dOverlap   重叠值
@param [in] dResolution  分辨率
@return SysGeometry::EnvelopePtr 包络线范围

</member>
        <member name="M:SysCarto.Page.GetDeviceBounds(SysCarto.IPrinter*,System.Int16,System.Double,System.Double)">
@brief 获取设备边界
@param [in] paiter 打印对象 
@param [in] currentPage 当前页面
@param [in] dOverlap   重叠值
@param [in] dResolution  分辨率
@return SysGeometry::EnvelopePtr 包络线范围

</member>
        <member name="M:SysCarto.Page.SetFormID(SysCarto.PageFormID)">
@brief 获取页面尺寸编号
@param [in] formID 页面尺寸编号
@return void

</member>
        <member name="M:SysCarto.Page.GetFormID">
@brief 获取页面尺寸编号
@return  PageFormID  纸张尺寸编号

</member>
        <member name="M:SysCarto.Page.Dispose">
@brief 析构函数

</member>
        <member name="M:SysCarto.Page.#ctor">
@brief 构造函数

</member>
        <member name="T:SysCarto.Page">
@class Page
@brief 页面

</member>
        <member name="F:SysCarto.IFrameProperties.m_ptrShadow">
@brief 阴影对象

</member>
        <member name="F:SysCarto.IFrameProperties.m_ptrBorder">
@brief 边界对象

</member>
        <member name="F:SysCarto.IFrameProperties.m_ptrBackground">
@brief 背景对象

</member>
        <member name="M:SysCarto.IFrameProperties.#ctor">
@brief 构造函数

</member>
        <member name="M:SysCarto.IFrameProperties.CopyTo(SysCarto.IFrameProperties*)">
@brief 拷贝到IFrameProperties
@param [in] IFrameProperties* pFrameProperties 框架属性
@return void

</member>
        <member name="M:SysCarto.IFrameProperties.SetShadow(SysUtility._ptr_t&lt;SysCarto.IShadow&gt;!System.Runtime.CompilerServices.IsConst)">
@brief  设置阴影
@param [in] ptrShadow  阴影对象
@return void

</member>
        <member name="M:SysCarto.IFrameProperties.GetShadow">
@brief  获取阴影
@return IShadowPtr  阴影

</member>
        <member name="M:SysCarto.IFrameProperties.SetBorder(SysUtility._ptr_t&lt;SysCarto.IBorder&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  设置边界
@param [in] ptrBorder  边界
@return void

</member>
        <member name="M:SysCarto.IFrameProperties.GetBorder">
@brief  获取边界
@return IBorderPtr 边界对象

</member>
        <member name="M:SysCarto.IFrameProperties.SetBackGround(SysUtility._ptr_t&lt;SysCarto.IBackground&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  设置背景
@param [in] ptrBackground  背景
@return void 

</member>
        <member name="M:SysCarto.IFrameProperties.GetBackground">
@brief  析构函数
@return IBackgroundPtr 背景对象

</member>
        <member name="M:SysCarto.IFrameProperties.Dispose">
@brief 析构函数

</member>
        <member name="T:SysCarto.IFrameProperties">
@class  IFrameProperties
@brief  框架属性

</member>
        <member name="F:SysCarto.IShadow.m_dGapY">
@brief Y轴间距

</member>
        <member name="F:SysCarto.IShadow.m_dGapX">
@brief X轴间距

</member>
        <member name="F:SysCarto.IShadow.m_strName">
@brief 名字

</member>
        <member name="M:SysCarto.IShadow.Dispose">
@brief 析构函数

</member>
        <member name="M:SysCarto.IShadow.#ctor">
@brief 构造函数

</member>
        <member name="M:SysCarto.IShadow.Clone">
@brief 克隆
@return  IShadowPtr 阴影类对象

</member>
        <member name="M:SysCarto.IShadow.Draw(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制
@param [in] paiter 绘图面板
@param [in] ptrTrasform 显示转换对象
@param [in] ptrGeo   几何对象
@return void

</member>
        <member name="M:SysCarto.IShadow.QueryBounds(SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 获取包络线范围
@param [in]  ptrTransform  显示转换对象
@param [in]  ptrQueryGeo   查询几何对象
@return  SysGeometry::EnvelopePtr  包络线范围

</member>
        <member name="M:SysCarto.IShadow.GetGeometry(SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 获取几何对象
@param [in]  ptrTransform  显示转换对象
@param [in]  ptrShape  几何对象形状
@return  SysGeometry::GeometryPtr  几何对象

</member>
        <member name="M:SysCarto.IShadow.SetYGap(System.Double)">
@brief 设置Y轴间距值
@param [in] dValue   Y轴间距值
@return void

</member>
        <member name="M:SysCarto.IShadow.GetYGap">
@brief 获取Y轴间距值
@return  double Y轴间距值

</member>
        <member name="M:SysCarto.IShadow.SetXGap(System.Double)">
@brief 设置X轴间距值
@param [in] dValue   X轴间距值
@return void

</member>
        <member name="M:SysCarto.IShadow.GetXGap">
@brief 获取X轴间距值
@return  double X轴间距值

</member>
        <member name="M:SysCarto.IShadow.SetName(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置名字
@param [in] strName  名字
@return void

</member>
        <member name="M:SysCarto.IShadow.GetName">
@brief 获取名字
@return  QString 名字

</member>
        <member name="T:SysCarto.IShadow">
@brief 类的前置声明和智能指针定义


@class  IShadow
@brief  阴影类

</member>
        <member name="F:SysCarto.IBorder.m_dGapY">
@brief Y轴的间距

</member>
        <member name="F:SysCarto.IBorder.m_dGapX">
@brief X轴的间距

</member>
        <member name="F:SysCarto.IBorder.m_strName">
@brief 名称

</member>
        <member name="M:SysCarto.IBorder.#ctor">
@brief 构造函数

</member>
        <member name="M:SysCarto.IBorder.Clone">
@brief 克隆
@return IBorderPtr 克隆边界类对象

</member>
        <member name="M:SysCarto.IBorder.Draw(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制
@param [in] painter   绘图设备
@param [in] ptrTrans  显示转换对象
@param [in] ptrGeo    几何对象
@return void

</member>
        <member name="M:SysCarto.IBorder.QueryBounds(SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief   获取主题边界范围
@param [in] ptrTransform 显示转换对象
@param [in] ptrShape     几何对象
@return  SysGeometry::EnvelopePtr   边界范围

</member>
        <member name="M:SysCarto.IBorder.GetGeometry(SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief   获取用于绘制边界的Geometry
@param [in] ptrTransform 显示转换对象
@param [in] ptrShape     几何对象
@return  SysGeometry::GeometryPtr    用于绘制边界的Geometry

</member>
        <member name="M:SysCarto.IBorder.SetYGap(System.Double)">
@brief  设置Y轴的间距
@param [in] gap  Y轴的间距
@return void

</member>
        <member name="M:SysCarto.IBorder.GetYGap">
@brief   获取Y轴的间距
@return  double  X轴的间距

</member>
        <member name="M:SysCarto.IBorder.SetXGap(System.Double)">
@brief  设置X轴的间距
@param [in] gap  X轴的间距
@return void

</member>
        <member name="M:SysCarto.IBorder.GetXGap">
@brief   获取X轴的间距
@return  double  X轴的间距

</member>
        <member name="M:SysCarto.IBorder.SetName(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  设置名字
@param [in] strName 名字
@return void

</member>
        <member name="M:SysCarto.IBorder.GetName">
@brief  获取名字
@return QString 名字

</member>
        <member name="M:SysCarto.IBorder.Dispose">
@brief 析构函数

</member>
        <member name="T:SysCarto.IBorder">
@brief 类的前置声明和智能指针定义


@class IBorder
@brief 边界类

</member>
        <member name="F:SysCarto.IPageEvents.PageUnitsChanged">
@brief  页面单元变化信号 

</member>
        <member name="F:SysCarto.IPageEvents.PageSizeChanged">
@brief  页面大小变化信号 

</member>
        <member name="F:SysCarto.IPageEvents.PageMarginsChanged">
@brief  页面边缘变化信号 

</member>
        <member name="F:SysCarto.IPageEvents.PageColorChanged">
@brief  页面颜色变化信号 

</member>
        <member name="T:SysCarto.IPageEvents">
@class IPageEvents
@brief   页面事件

</member>
        <member name="F:SysCarto.IPrinter.m_units">
@brief pie单元对象

</member>
        <member name="F:SysCarto.IPrinter.m_strSpoolFileName">
@brief 线轴文件名

</member>
        <member name="F:SysCarto.IPrinter.m_dResolution">
@brief 分辨率

</member>
        <member name="F:SysCarto.IPrinter.m_strPrintFileName">
@brief 打印文件名称

</member>
        <member name="F:SysCarto.IPrinter.m_pPaper">
@brief 页面纸张

</member>
        <member name="F:SysCarto.IPrinter.m_strFilter">
@brief 文件过滤器

</member>
        <member name="F:SysCarto.IPrinter.m_strFileExtension">
@brief 文件附录

</member>
        <member name="F:SysCarto.IPrinter.m_strDriverName">
@brief 驱动名称

</member>
        <member name="F:SysCarto.IPrinter.m_strName">
@brief 名称

</member>
        <member name="M:SysCarto.IPrinter.CopyTo(SysCarto.IPrinter*)">
@brief 拷贝到IPrinter
@param[in] IPrinter* IPrinter对象指针

</member>
        <member name="M:SysCarto.IPrinter.#ctor">
@brief 构造函数

</member>
        <member name="M:SysCarto.IPrinter.Clone">
@brief 克隆
@return IPrinter* 克隆对象指针

</member>
        <member name="M:SysCarto.IPrinter.VerifyDriverSettings">
@brief 检验驱动设置
@return  bool 是否正确  是 true,否 false

</member>
        <member name="M:SysCarto.IPrinter.Units">
@brief 获取pie单元
@return  SysUI::pieUnits pie单元对象

</member>
        <member name="M:SysCarto.IPrinter.StartPrinting(SysUtility._ptr_t&lt;SysGeometry.Envelope&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 开始打印
@param [in] ptrPixelBounds 包络线范围
@return  void

</member>
        <member name="M:SysCarto.IPrinter.SetSpoolFileName(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置线轴文件名
@param [in] strName 线轴文件名
@return  void

</member>
        <member name="M:SysCarto.IPrinter.GetSpoolFileName">
@brief 获取线轴文件名
@return  QString  线轴文件名

</member>
        <member name="M:SysCarto.IPrinter.SetResolution(System.Double)">
@brief 设置分辨率
@param [in] dRes 分辨率
@return  void

</member>
        <member name="M:SysCarto.IPrinter.GetResolution">
@brief 获取分辨率
@return  double  分辨率

</member>
        <member name="M:SysCarto.IPrinter.QueryPaperSize(System.Double*,System.Double*)">
@brief 查询获取页面纸张大小
@param [in out] dWidth  宽度
@param [in out] dHeight 高度
@return  void

</member>
        <member name="M:SysCarto.IPrinter.SetPrintFileName(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置打印文件名称
@param [in] strFileName 文件名称
@return  void

</member>
        <member name="M:SysCarto.IPrinter.GetPrintFileName">
@brief 获取打印文件名称
@return  QString 文件名称

</member>
        <member name="M:SysCarto.IPrinter.PrintableBounds">
@brief 有效打印范围
@return  SysGeometry::EnvelopePtr  包络线范围

</member>
        <member name="M:SysCarto.IPrinter.SetPaper(SysCarto.Paper*)">
@brief 设置页面纸张
@param [in] pPaper 页面纸张
@return  void 

</member>
        <member name="M:SysCarto.IPrinter.GetPaper">
@brief 获取页面纸张
@return  Paper* 页面纸张

</member>
        <member name="M:SysCarto.IPrinter.FinishPrinting">
@brief 完成打印
@return  void  

</member>
        <member name="M:SysCarto.IPrinter.Filter">
@brief 获取文件过滤器
@return  QString  过滤文件

</member>
        <member name="M:SysCarto.IPrinter.FileExtension">
@brief 获取文件附录
@return  QString  文件附录

</member>
        <member name="M:SysCarto.IPrinter.DriverName">
@brief 获取驱动名字
@return  QString  驱动名字

</member>
        <member name="M:SysCarto.IPrinter.GetName">
@brief 获取名字
@return  QString  名字

</member>
        <member name="M:SysCarto.IPrinter.DoesDriverSupportPrinter(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 工作驱动支持的打印机
@param [in] strPrinterName 打印机名称
@return bool  是否支持，是 true ,否 false

</member>
        <member name="M:SysCarto.IPrinter.Dispose">
@brief 析构函数

</member>
        <member name="T:SysCarto.IPrinter">
@class  IPrinter
@brief  打印机

</member>
        <member name="F:SysCarto.Paper.m_units">
@brief pie单元对象

</member>
        <member name="F:SysCarto.Paper.m_enumFormID">
@brief 纸张尺寸编号

</member>
        <member name="F:SysCarto.Paper.m_dHeight">
@brief 高度

</member>
        <member name="F:SysCarto.Paper.m_dWidth">
@brief 宽度

</member>
        <member name="F:SysCarto.Paper.m_vecFormInfo">
@brief 表格信息集合

</member>
        <member name="M:SysCarto.Paper.InitFormInfo">
@brief 初始化表格信息
@return  void

</member>
        <member name="M:SysCarto.Paper.GetFormCount">
@brief 获取表格数量
@return  int 表格数量

</member>
        <member name="M:SysCarto.Paper.GetCustomSize(System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 获取定制大小
@param [in out] dWidth  宽度
@param [in out] dHeight 高度
@return  void

</member>
        <member name="M:SysCarto.Paper.SetCustomSize(System.Double,System.Double)">
@brief 设置定制大小
@param [in] dWidth  宽度
@param [in] dHeight 高度
@return  void

</member>
        <member name="M:SysCarto.Paper.GetFormInfo(SysCarto.PageFormID,SysCarto.FormInfo*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 获取表格信息
@param [in] formID  纸张尺寸编号
@param [in] fromInfo  表格信息
@return bool 是否成功

</member>
        <member name="M:SysCarto.Paper.Clone">
@brief 克隆
@return  PaperPtr 新克隆的对象

</member>
        <member name="M:SysCarto.Paper.SetUnits(SysUI.pieUnits)">
@brief 设置单元
@param [in] units  单元
@return void

</member>
        <member name="M:SysCarto.Paper.GetUnits">
@brief 获取单元
@return SysUI::pieUnits 单元

</member>
        <member name="M:SysCarto.Paper.QueryPaperSize(System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  查询获取纸张尺寸大小
@param [in out] dWidth  纸张尺寸宽度
@param [in out] dHeight 纸张尺寸高度
@return void

</member>
        <member name="M:SysCarto.Paper.SetFormID(SysCarto.PageFormID)">
@brief 设置纸张尺寸编号
@param [in] formID 纸张尺寸编号
@return  void

</member>
        <member name="M:SysCarto.Paper.GetFormID">
@brief  获取纸张尺寸编号
@return PageFormID   纸张尺寸编号

</member>
        <member name="M:SysCarto.Paper.Dispose">
@brief 析构函数

</member>
        <member name="M:SysCarto.Paper.#ctor(SysCarto.PageFormID)">
@brief  构造函数
@param [in] formID   纸张尺寸编号

</member>
        <member name="T:SysCarto.Paper">
@brief  类的前置声明和智能指针定义


@class  Paper
@brief  纸张

</member>
        <member name="M:SysCarto.FormInfo.#ctor">
@brief  构造函数

</member>
        <member name="M:SysCarto.FormInfo.#ctor(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
@brief  构造函数
@param [in] id  纸张尺寸编号
@param [in] str 文本信息
@param [in] dWid 宽度
@param [in] dHei 高度

</member>
        <member name="T:SysCarto.FormInfo">
@brief  FormInfo 表格信息结构体

</member>
        <member name="M:SysUI.Units.GetAreaUnitsDesc(SysUI.pieAreaUnits)">
@brief 获取区域制图单位描述
@param [in] units  制图单位
@return QString 制图单位的描述信息

</member>
        <member name="M:SysUI.Units.ConvertAreaUnits(System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUI.pieAreaUnits,SysUI.pieAreaUnits)">
@brief 转化区域制图单位
@param [in] dInValue 输入值
@param [in out] dOutValue 输出值
@param [in] unitsIn   单位输入值
@param [in] dOutValue 单位输出值
@return   成功 true, 失败 false

</member>
        <member name="M:SysUI.Units.GetUnitsDesc(SysUI.pieUnits)">
@brief 获取制图单位描述
@param [in] units  制图单位
@return QString 制图单位的描述信息

</member>
        <member name="M:SysUI.Units.ConvertUnits(System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUI.pieUnits,SysUI.pieUnits)">
@brief 转化制图单位
@param [in] dInValue 输入值
@param [in out] dOutValue 输出值
@param [in] unitsIn   单位输入值
@param [in] dOutValue 单位输出值
@return   成功 true, 失败 false

</member>
        <member name="T:SysUI.Units">
@class  Units
@brief  制图单位类

</member>
        <member name="T:SysUI.pieAreaUnits">
@class pieAreaUnits
	* @brief PIE中面积单位

</member>
        <member name="F:AreaUnitsAreaUnitsLast">
@brief 区域上最后一个单元

</member>
        <member name="F:AreaUnitsDecimalSquareDegrees">
@brief 平方度（十进制）

</member>
        <member name="F:AreaUnitsSquareKilometers">
@brief 平方千米（平方公里）

</member>
        <member name="F:AreaUnitsHectares">
@brief 公顷

</member>
        <member name="F:AreaUnitsAres">
@brief 平方公亩

</member>
        <member name="F:AreaUnitsSquareMeters">
@brief 平方米

</member>
        <member name="F:AreaUnitsSquareDecimeters">
@brief 平方分米

</member>
        <member name="F:AreaUnitsSquareCentimeters">
@brief 平方厘米

</member>
        <member name="F:AreaUnitsSquareMillimeters">
@brief 平方毫米

</member>
        <member name="F:AreaUnitsSquareMiles">
@brief 英里

</member>
        <member name="F:AreaUnitsAcres">
@brief 平方英亩

</member>
        <member name="F:AreaUnitsSquareYards">
@brief 平方码

</member>
        <member name="F:AreaUnitsSquareFeet">
@brief 平方英尺

</member>
        <member name="F:AreaUnitsSquareInches">
@brief 平方英寸

</member>
        <member name="F:AreaUnitsUnknown">
@brief 未知

</member>
        <member name="T:SysCarto.PageFormID">
@class  PageFormID
@brief  页面尺寸编号 枚举

</member>
        <member name="F:PageFormSameAsPrinter">
@brief  与打印器相同

</member>
        <member name="F:PageFormCustom">
@brief  自定义

</member>
        <member name="F:PageFormA0">
@brief  A0

</member>
        <member name="F:PageFormA1">
@brief  A1

</member>
        <member name="F:PageFormA2">
@brief  A2

</member>
        <member name="F:PageFormA3">
@brief  A3

</member>
        <member name="F:PageFormA4">
@brief  A4

</member>
        <member name="F:PageFormA5">
@brief  A5

</member>
        <member name="F:PageFormE">
@brief  ANSI E

</member>
        <member name="F:PageFormD">
@brief  ANSI D

</member>
        <member name="F:PageFormC">
@brief  ANSI C

</member>
        <member name="F:PageFormTabloid">
@brief  便笺

</member>
        <member name="F:PageFormLegal">
@brief  法律专用纸

</member>
        <member name="F:PageFormLetter">
@brief  信纸

</member>
        <member name="F:SysCarto.IBackground.m_dGapY">
@brief Y轴的间距

</member>
        <member name="F:SysCarto.IBackground.m_dGapX">
@brief X轴的间距

</member>
        <member name="F:SysCarto.IBackground.m_strName">
@brief 名称

</member>
        <member name="M:SysCarto.IBackground.Dispose">
@brief 析构函数

</member>
        <member name="M:SysCarto.IBackground.#ctor">
@brief 构造函数

</member>
        <member name="M:SysCarto.IBackground.Clone">
@brief 克隆
@return IBackgroundPtr 克隆背景类对象

</member>
        <member name="M:SysCarto.IBackground.Draw(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 绘制
@param [in] painter   绘图设备
@param [in] ptrTrans  显示转换对象
@param [in] ptrGeo    几何对象
@return void

</member>
        <member name="M:SysCarto.IBackground.QueryBounds(SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief   获取主题背景边界范围 
@param [in] ptrTransform 显示转换对象
@param [in] ptrShape     几何对象
@return  SysGeometry::EnvelopePtr   背景边界范围 

</member>
        <member name="M:SysCarto.IBackground.GetGeometry(SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief   获取用于绘制背景的Geometry 
@param [in] ptrTransform 显示转换对象
@param [in] ptrShape     几何对象
@return  SysGeometry::GeometryPtr    用于绘制背景的Geometry 

</member>
        <member name="M:SysCarto.IBackground.SetYGap(System.Double)">
@brief  设置Y轴的间距
@param [in] gap  Y轴的间距
@return void

</member>
        <member name="M:SysCarto.IBackground.GetYGap">
@brief   获取Y轴的间距
@return  double  X轴的间距

</member>
        <member name="M:SysCarto.IBackground.SetXGap(System.Double)">
@brief  设置X轴的间距
@param [in] gap  X轴的间距
@return void

</member>
        <member name="M:SysCarto.IBackground.GetXGap">
@brief   获取X轴的间距
@return  double  X轴的间距

</member>
        <member name="M:SysCarto.IBackground.SetName(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  设置名字
@param [in] strName 名字
@return void 

</member>
        <member name="M:SysCarto.IBackground.GetName">
@brief  获取名字
@return QString 名字

</member>
        <member name="T:SysCarto.IBackground">
@brief 类的前置声明和智能指针定义


@class IBackground
@brief 背景类

</member>
        <member name="M:SysCarto.SnapGuides.Dispose">
@brief 析构函数

</member>
        <member name="M:SysCarto.SnapGuides.#ctor">
@brief 构造函数

</member>
        <member name="T:SysCarto.SnapGuides">
@class SnapGuides
@brief 捕捉参考线

</member>
        <member name="D:SysDisplay.SimpleLineSymbolPtr">
@brief 简单线符号类 智能指针对象

</member>
        <member name="F:SysDisplay.SimpleLineSymbol.m_Style">
@brief 线样式

</member>
        <member name="M:SysDisplay.SimpleLineSymbol.SetStyle(SysDisplay.SimpleLineStyle)">
@brief 设置简单线样式
@param[in] SimpleLineStyle style 简单线样式
@return void

</member>
        <member name="M:SysDisplay.SimpleLineSymbol.GetStyle">
@brief 获得简单线样式
@return SimpleLineStyle 简单线样式

</member>
        <member name="M:SysDisplay.SimpleLineSymbol.Dispose">
@brief 析构函数
@param[in] void
@return

</member>
        <member name="M:SysDisplay.SimpleLineSymbol.#ctor">
@brief 构造函数
@param[in] void
@return

</member>
        <member name="T:SysDisplay.SimpleLineSymbol">
@class SimpleLineSymbol
	* @brief 简单线符号类 

</member>
        <member name="D:SysDisplay.LineSymbolPtr">
@brief  线样式 智能指针对象

</member>
        <member name="F:SysDisplay.LineSymbol.m_Pen">
@brief 画笔

</member>
        <member name="F:SysDisplay.LineSymbol.m_MiterLimit">
@brief 限制长度

</member>
        <member name="F:SysDisplay.LineSymbol.m_JoinStyle">
@brief 折点连接样式

</member>
        <member name="F:SysDisplay.LineSymbol.m_CapStyle">
@brief 线帽样式

</member>
        <member name="F:SysDisplay.LineSymbol.m_Width">
@brief 线宽度

</member>
        <member name="F:SysDisplay.LineSymbol.m_Offset">
@brief 偏移

</member>
        <member name="F:SysDisplay.LineSymbol.m_Color">
@brief 线颜色

</member>
        <member name="M:SysDisplay.LineSymbol.Dispose">
@brief 析造函数
@return

</member>
        <member name="M:SysDisplay.LineSymbol.#ctor">
@brief 构造函数
@return

</member>
        <member name="M:SysDisplay.LineSymbol.SetMiterLimit(System.Double)">
@brief 设置MiterLimit
@param[in] double miterLimit MiterLimit
@return void

</member>
        <member name="M:SysDisplay.LineSymbol.GetMiterLimit">
@brief 获得MiterLimit
@return double MiterLimit

</member>
        <member name="M:SysDisplay.LineSymbol.SetJoinStyle(SysDisplay.LineJoinStyle)">
@brief 设置连接样式
@param[in] LineJoinStyle join 连接样式
@return void

</member>
        <member name="M:SysDisplay.LineSymbol.GetJoinStyle">
@brief 获得连接样式
@return LineJoinStyle 连接样式

</member>
        <member name="M:SysDisplay.LineSymbol.SetCapStyle(SysDisplay.LineCapStyle)">
@brief 设置线帽样式
@param[in] LineCapStyle cap 线帽样式
@return void

</member>
        <member name="M:SysDisplay.LineSymbol.GetCapStyle">
@brief 得到线帽样式
@return LineCapStyle 线帽样式

</member>
        <member name="M:SysDisplay.LineSymbol.SetColor(QColor)">
@brief  设置颜色
@param[in] QColor color
@return void

</member>
        <member name="M:SysDisplay.LineSymbol.GetColor">
@brief  获取颜色
@return QColor

</member>
        <member name="M:SysDisplay.LineSymbol.SetWidth(System.Double)">
@brief  设置宽度
@param[in] double width
@return void

</member>
        <member name="M:SysDisplay.LineSymbol.GetWidth">
@brief  获取宽度
@return double

</member>
        <member name="M:SysDisplay.LineSymbol.SetOffset(System.Double)">
@brief 设置偏移量
@param[in] double offset  偏移量
@return void

</member>
        <member name="M:SysDisplay.LineSymbol.GetOffset">
@brief  获取偏移量
@return double 偏移量

</member>
        <member name="T:SysDisplay.LineSymbol">
@class LineSymbol
	* @brief  线样式

</member>
        <member name="D:SysGeometry.PolylinePtr">
@brief 单线段 智能指针对象

</member>
        <member name="M:SysGeometry.Polyline.GetPointByDistance(System.Double)">
@brief 通过距离获得点
@param[in] double distance
@returnPointPtr

</member>
        <member name="M:SysGeometry.Polyline.IsClosed">
@brief 是否闭合
@return bool 是否闭合

</member>
        <member name="M:SysGeometry.Polyline.GetEndPoint">
@brief 获得终止点
@return PointPtr 终止点

</member>
        <member name="M:SysGeometry.Polyline.GetStartPoint">
@brief 获得起始点
@return PointPtr 起始点

</member>
        <member name="M:SysGeometry.Polyline.GetLength">
@brief 获得长度
@return double 长度

</member>
        <member name="M:SysGeometry.Polyline.Clone">
@brief 克隆
@return GeometryPtr 克隆成果

</member>
        <member name="M:SysGeometry.Polyline.Equals(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 是否相等
@param[in] const GeometryPtr ptrGeo 空间几何图形对象
@return bool 是否相等

</member>
        <member name="M:SysGeometry.Polyline.Scale(SysUtility._ptr_t&lt;SysGeometry.Point&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
@brief 缩放
@param[in] PointPtr originPoint 参照点
@param[in] double sx x方向缩放
@param[in] double sy y方向缩放
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Polyline.Rotate(SysUtility._ptr_t&lt;SysGeometry.Point&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
@brief 旋转
@param[in] PointPtr originPoint 参照点
@param[in] double rotationAngle 旋转角度
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Polyline.Move(System.Double,System.Double)">
@brief 移动
@param[in] double dx x方向的偏移
@param[in] double dy y方向的偏移
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Polyline.Transform(SysUtility._ptr_t&lt;SysGeometry.CoordinateTransformation&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 投影转换（会忽略原来的空间参考）
@param[in] CoordinateTransformationPtr ptrCT 坐标转换对象
@return bool 是否转换成功

</member>
        <member name="M:SysGeometry.Polyline.Centroid">
@brief 获得质点
@return GeometryPtr 质点

</member>
        <member name="M:SysGeometry.Polyline.GetEnvelope">
@brief 获得空间范围
@return GeometryPtr 空间范围

</member>
        <member name="M:SysGeometry.Polyline.IsValid">
@brief 是否是有效的
@return bool 是否是有效的

</member>
        <member name="M:SysGeometry.Polyline.IsSimple">
@brief 是否是简单几何形状
@return bool 是否是简单几何形状

</member>
        <member name="M:SysGeometry.Polyline.IsEmpty">
@brief 是否为空
@return bool 是否为空

</member>
        <member name="M:SysGeometry.Polyline.SetEmpty">
@brief 设置为空
@return bool

</member>
        <member name="M:SysGeometry.Polyline.Dispose">
@brief 析构函数
@return

</member>
        <member name="M:SysGeometry.Polyline.#ctor">
@brief 构造函数
@return

</member>
        <member name="T:SysGeometry.Polyline">
@class Polyline
	* @brief 单线段

</member>
        <member name="D:SysGeometry.PointCollectionPtr">
@brief 点集合对象 智能指针对象

</member>
        <member name="M:SysGeometry.PointCollection.IsValidIndex(System.Int32,System.Boolean)">
@brief Index是否有效
@param[in] int index 编号
@param[in] bool bInsert 是否是插入
@return bool 是否有效

</member>
        <member name="F:SysGeometry.PointCollection.m_vecPoint">
@brief 点集合

</member>
        <member name="M:SysGeometry.PointCollection.ClearPoints">
@brief 清除点
@return bool 是否成功

</member>
        <member name="M:SysGeometry.PointCollection.RemovePoint(System.Int32)">
@brief 通过索引删除点
@param[in] int index 编号
@return bool 是否成功

</member>
        <member name="M:SysGeometry.PointCollection.GetZ(System.Int32)">
@brief 通过索引获得点的Z坐标值
@param[in] int index 索引编号
@return double 编号为index的点的Z坐标值

</member>
        <member name="M:SysGeometry.PointCollection.GetY(System.Int32)">
@brief 通过索引获得点的Y坐标值
@param[in] int index 索引编号
@return double 编号为index的点的Y坐标值

</member>
        <member name="M:SysGeometry.PointCollection.GetX(System.Int32)">
@brief 通过索引获得点的X坐标值
@param[in] int index 索引编号
@return double 编号为index的点的X坐标值

</member>
        <member name="M:SysGeometry.PointCollection.GetPoint(System.Int32)">
@brief 通过索引获得点
@param[in] int index 编号
@return PointPtr 点

</member>
        <member name="M:SysGeometry.PointCollection.InsertPoint(System.Int32,SysUtility._ptr_t&lt;SysGeometry.Point&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 通过索引插入点
@param[in] int index 编号
@param[in] PointPtr point 点
@return bool 是否成功

</member>
        <member name="M:SysGeometry.PointCollection.GetPoints(System.Int32,System.Double*,System.Double*,System.Double*)">
@brief 获取点集数组
@param[in] int count 需要获取点集的数量
@param[in] double* px  X坐标点值的数组
@param[in] double* py  Y坐标点值的数组
@param[in] double* pz  Z坐标点值的数组
@return bool 是否成功

</member>
        <member name="M:SysGeometry.PointCollection.SetPoints(System.Int32,System.Double*,System.Double*,System.Double*)">
@brief 给PointCollection中点赋值
@param[in] int count 点的数量
@param[in] double* px  X坐标点值的数组
@param[in] double* py  Y坐标点值的数组
@param[in] double* pz  Z坐标点值的数组
@return bool 是否成功

</member>
        <member name="M:SysGeometry.PointCollection.SetPoints(System.Int32,System.Double*,System.Double*)">
@brief 给PointCollection中点赋值
@param[in] int count 点的数量
@param[in] double* px  X坐标点值的数组
@param[in] double* py  Y坐标点值的数组
@return bool 是否成功

</member>
        <member name="M:SysGeometry.PointCollection.AddPoint(System.Double,System.Double,System.Double)">
@brief 添加点
@param[in] double x X
@param[in] double y Y
@param[in] double z Z
@return bool 是否成功

</member>
        <member name="M:SysGeometry.PointCollection.AddPoint(System.Double,System.Double)">
@brief 添加点
@param[in] double x X
@param[in] double y Y
@return bool 是否成功

</member>
        <member name="M:SysGeometry.PointCollection.AddPoint(SysUtility._ptr_t&lt;SysGeometry.Point&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 添加点
@param[in] PointPtr point 点
@return bool 是否成功

</member>
        <member name="M:SysGeometry.PointCollection.GetPointCount">
@brief 获得点数目
@return int 得点数目

</member>
        <member name="M:SysGeometry.PointCollection.Dispose">
@brief 析构函数
@return

</member>
        <member name="M:SysGeometry.PointCollection.#ctor">
@brief 构造函数
@return

</member>
        <member name="T:SysGeometry.PointCollection">
@class PointCollection
	* @brief 点集合对象


@brief 类的前期声明和智能指针的定义

</member>
        <member name="T:SysGeometry.RawPoint">
@brief 点的初始化结构体

</member>
        <member name="D:SysGeometry.CurvePtr">
@brief 曲线的智能指针对象

</member>
        <member name="M:SysGeometry.Curve.GetPointByDistance(System.Double)">
@brief 通过距离获得点
@param[in] double distance
@returnPointPtr

</member>
        <member name="M:SysGeometry.Curve.IsClosed">
@brief 是否闭合
@return bool 是否闭合

</member>
        <member name="M:SysGeometry.Curve.GetEndPoint">
@brief 获得终止点
@return PointPtr 终止点

</member>
        <member name="M:SysGeometry.Curve.GetStartPoint">
@brief 获得起始点
@return PointPtr 起始点

</member>
        <member name="M:SysGeometry.Curve.GetLength">
@brief 获得长度
@return double 长度

</member>
        <member name="M:SysGeometry.Curve.Dispose">
@brief 析构函数
@return

</member>
        <member name="M:SysGeometry.Curve.#ctor">
@brief 构造函数
@return

</member>
        <member name="T:SysGeometry.Curve">
@class Curve
	* @brief 曲线对象

</member>
        <member name="F:SysDisplay.Symbol.m_SymbolType">
@brief 符号类型

</member>
        <member name="M:SysDisplay.Symbol.Dispose">
@brief 析构函数
@return

</member>
        <member name="M:SysDisplay.Symbol.#ctor">
@brief 构造函数
@return

</member>
        <member name="M:SysDisplay.Symbol.QueryBoundary(SysUtility._ptr_t&lt;SysDisplay.DisplayTransformation&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 查询符号外接多边形
@param [in] ptrDisplayTransformation
@param [in] ptrGeometry
@return 符号外接多边形对象

</member>
        <member name="M:SysDisplay.Symbol.Clone">
@brief 克隆
@return SymbolPtr 克隆对象

</member>
        <member name="M:SysDisplay.Symbol.GetType">
@brief 获得符号类型
@return SymbolType 符号类型

</member>
        <member name="T:SysDisplay.Symbol">
@class Symbol
	* @brief 符号

</member>
        <member name="T:SysDisplay.TextAlignment">
@class TextAlignment
	* @brief  文本对齐方式

</member>
        <member name="F:AlignCenter">
@brief 居中对齐

</member>
        <member name="F:AlignRight">
@brief 右对齐

</member>
        <member name="F:AlignLeft">
@brief 左对齐

</member>
        <member name="T:SysDisplay.TextBackgroundType">
@class TextBackgroundType
	* @brief  文本背景类型

</member>
        <member name="F:TBTBalloonCallout">
@brief 气球

</member>
        <member name="T:SysDisplay.TextDirection">
@class TextDirection
	* @brief  文本方向

</member>
        <member name="F:TDVertical">
@brief 纵向

</member>
        <member name="F:TDAngle">
@brief 按角度

</member>
        <member name="F:TDHorizontal">
@brief 横向

</member>
        <member name="T:SysDisplay.TextCase">
@class TextCase
	* @brief  文本大小写

</member>
        <member name="F:TCSmallCaps">
@brief 小型大写

</member>
        <member name="F:TCAllCaps">
@brief 全部大写

</member>
        <member name="F:TCLowercase">
@brief 全部小写

</member>
        <member name="F:TCNormal">
@brief 常规

</member>
        <member name="T:SysDisplay.TextPositionStyle">
@class TextPosition
	* @brief  文本位置样式

</member>
        <member name="F:TPSubscript">
@brief 下标

</member>
        <member name="F:TPSuperscript">
@brief 上标

</member>
        <member name="F:TPNormal">
@brief 常规

</member>
        <member name="T:SysDisplay.BalloonCalloutStyle">
@class BalloonCalloutStyle
	* @brief  气球注释样式

</member>
        <member name="F:BCSOval">
@brief 椭圆

</member>
        <member name="F:BCSRoundedRectangle">
@brief 圆角矩形

</member>
        <member name="F:BCSRectangle">
@brief 矩形

</member>
        <member name="T:SysDisplay.GradientFillStyle">
@class GradientFillStyle
	* @brief  渐变色填充样式

</member>
        <member name="F:GFSNull">
@brief 无填充

</member>
        <member name="F:GFSBuffered">
@brief 缓冲渐变填充

</member>
        <member name="F:GFSCircular">
@brief 圆形渐变填充

</member>
        <member name="F:GFSRectangular">
@brief 矩形渐变填充

</member>
        <member name="F:GFSLinear">
@brief 线性渐变填充

</member>
        <member name="T:SysDisplay.SimpleFillStyle">
@class SimpleFillStyle
	* @brief  简单填充样式

</member>
        <member name="F:SFSDense7Pattern">
@brief 方式7

</member>
        <member name="F:SFSDense6Pattern">
@brief 方式6

</member>
        <member name="F:SFSDense5Pattern">
@brief 方式5

</member>
        <member name="F:SFSDense4Pattern">
@brief 方式4

</member>
        <member name="F:SFSDense3Pattern">
@brief 方式3

</member>
        <member name="F:SFSDense2Pattern">
@brief 方式2

</member>
        <member name="F:SFSDense1Pattern">
@brief 方式1

</member>
        <member name="F:SFSDiagonalCross">
@brief xxxxxxxxxxxxxxxxxxxx

</member>
        <member name="F:SFSCross">
@brief +++++++++++++++++++

</member>
        <member name="F:SFSBackwardDiagonal">
@brief ////////////////////

</member>
        <member name="F:SFSForwardDiagonal">
@brief \\\\\\\\\\\\\\\\\\\

</member>
        <member name="F:SFSVertical">
@brief ||||||||||||||||||

</member>
        <member name="F:SFSHorizontal">
@brief ------------------

</member>
        <member name="F:SFSNull">
@brief 无填充

</member>
        <member name="F:SFSSolid">
@brief 实体填充

</member>
        <member name="T:SysDisplay.LineCapStyle">
@class LineCapStyle
	* @brief 线帽样式

</member>
        <member name="F:LCSSquare">
@brief 矩形线帽样式包含最后的点

</member>
        <member name="F:LCSRound">
@brief 圆角线帽样式

</member>
        <member name="F:LCSButt">
@brief 矩形线帽样式不包含最后点

</member>
        <member name="T:SysDisplay.LineJoinStyle">
@class LineJoinStyle
	* @brief 线连接样式

</member>
        <member name="F:LJSBevel">
@brief 平角转折

</member>
        <member name="F:LJSRound">
@brief 圆角转折

</member>
        <member name="F:LJSMitre">
@brief 直接相交转折点

</member>
        <member name="T:SysDisplay.SimpleLineStyle">
@enum SimpleLineStyle
	* @brief 简单线样式

</member>
        <member name="F:SLSNull">
@brief 无

</member>
        <member name="F:SLSDashDotDot">
@brief _.._.._.

</member>
        <member name="F:SLSDashDot">
@brief _._._._.

</member>
        <member name="F:SLSDot">
@brief ............

</member>
        <member name="F:SLSDash">
@brief -----------

</member>
        <member name="F:SLSSolid">
@brief 实线

</member>
        <member name="T:SysDisplay.SimpleMarkerStyle">
@enum SimpleMarkerStyle
	* @brief 简单点样式

</member>
        <member name="F:SMSDiamond">
@brief 菱形

</member>
        <member name="F:SMSX">
@brief X叉

</member>
        <member name="F:SMSCross">
@brief 十字叉

</member>
        <member name="F:SMSSquare">
@brief 正方形

</member>
        <member name="F:SMSCircle">
@brief 圆形

</member>
        <member name="T:SysDisplay.SymbolType">
@enum SymbolType
	* @brief 样式符号类型

</member>
        <member name="F:SymbolFormattedTextSymbol">
@brief 格式化文本样式

</member>
        <member name="F:SymbolTextSymbol">
@brief 文本样式

</member>
        <member name="F:SymbolMultiLayerFillSymbol">
@brief 多层填充样式

</member>
        <member name="F:SymbolLineFillSymbol">
@brief 线符号填充样式

</member>
        <member name="F:SymbolMarkerFillSymbol">
@brief 点符号填充样式

</member>
        <member name="F:SymbolPictureFillSymbol">
@brief 图片填充样式

</member>
        <member name="F:SymbolGradientFillSymbol">
@brief 渐变填充样式

</member>
        <member name="F:SymbolSimpleFillSymbol">
@brief 简单填充样式

</member>
        <member name="F:SymbolMultiLayerLineSymbol">
@brief 多层线样式

</member>
        <member name="F:SymbolMarkerLineSymbol">
@brief 点符号线样式

</member>
        <member name="F:SymbolPictureLineSymbol">
@brief 图片线样式

</member>
        <member name="F:SymbolCartographicLineSymbol">
@brief 制图线样式

</member>
        <member name="F:SymbolSimpleLineSymbol">
@brief 简单线样式

</member>
        <member name="F:SymbolMultiLayerMarkerSymbol">
@brief 多层点样式

</member>
        <member name="F:SymbolPictureMarkerSymbol">
@brief 图片点样式

</member>
        <member name="F:SymbolCharacterMarkerSymbol">
@brief 字体点样式

</member>
        <member name="F:SymbolArrowMarkerSymbol">
@brief 箭头点样式

</member>
        <member name="F:SymbolSimpleMarkerSymbol">
@brief 简单点样式

</member>
        <member name="F:SymbolUnknownSymbol">
@brief 未知符号

</member>
        <member name="F:SysDisplay.DisplayTransformation.m_units">
@brief 单位

</member>
        <member name="F:SysDisplay.DisplayTransformation.m_Bounds">
@brief 全图地图范围

</member>
        <member name="F:SysDisplay.DisplayTransformation.m_FittedBounds">
@brief 地图定制范围

</member>
        <member name="F:SysDisplay.DisplayTransformation.m_VisibleBounds">
@brief 地图显示范围

</member>
        <member name="F:SysDisplay.DisplayTransformation.m_pDevice">
@brief 绘图设备对象指针

</member>
        <member name="F:SysDisplay.DisplayTransformation.m_DeviceFrame">
@brief 设备框架范围

</member>
        <member name="F:SysDisplay.DisplayTransformation.m_ptrSpatialReference">
@brief 地图的空间参考

</member>
        <member name="F:SysDisplay.DisplayTransformation.m_dPageScale">
@brief 制图比例

</member>
        <member name="F:SysDisplay.DisplayTransformation.m_MapScale">
@brief 当前地图比例尺

</member>
        <member name="F:SysDisplay.DisplayTransformation.m_DPI">
@brief 当前屏幕的DPI

</member>
        <member name="F:SysDisplay.DisplayTransformation.m_DistanceOfMapUnitPerDeviceUnit_Y">
@brief 每设备单位的地图距离Y

</member>
        <member name="F:SysDisplay.DisplayTransformation.m_DistanceOfMapUnitPerDeviceUnit_X">
@brief 每设备单位的地图距离X

</member>
        <member name="F:SysDisplay.DisplayTransformation.m_DistanceOfDeviceUnitPerMapUnit_Y">
@brief 每地图单位的设备距离Y

</member>
        <member name="F:SysDisplay.DisplayTransformation.m_DistanceOfDeviceUnitPerMapUnit_X">
@brief 每地图单位的设备距离X

</member>
        <member name="M:SysDisplay.DisplayTransformation.CalculateVisibleExtent">
@brief 根据屏幕范围重新计算可视范围
@return

</member>
        <member name="M:SysDisplay.DisplayTransformation.Clone">
@brief 克隆
@return DisplayTransformationPtr 克隆成果 显示转换对象指针

</member>
        <member name="M:SysDisplay.DisplayTransformation.SetPaintDevice(QPaintDevice*)">
@brief  设置绘图设备
@param [in] QPaintDevice* pDevice 绘图设备指针对象
@return  void

</member>
        <member name="M:SysDisplay.DisplayTransformation.GetPaintDevice">
@brief  获取绘图设备
@return  QPaintDevice* 绘图设备指针

</member>
        <member name="M:SysDisplay.DisplayTransformation.SetUnits(SysUI.pieUnits)">
@brief 设置单位值
@param[in] SysUI::pieUnits units 单位值
@return  void

</member>
        <member name="M:SysDisplay.DisplayTransformation.GetUnits">
@brief 获取单位值
@return SysUI::pieUnits  单位值

</member>
        <member name="M:SysDisplay.DisplayTransformation.ToMapPoints(System.Int32,System.Double*,System.Double*,System.Double*,System.Double*)">
@brief 从地图点转化为设备点
@param[in] int count	    点个数		
@param[in] double* deveiceX	设备点X集合
@param[in] double* deviceY	设备点Y集合
@param[out] double* mapX	地图点X集合
@param[out] double* mapY	地图点Y集合
@return bool 转换是否成功

</member>
        <member name="M:SysDisplay.DisplayTransformation.ToMapPoint(QPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 从设备点转化为地图点
@param[in] QPoint point 设备点
@return PointPtr 地图点

</member>
        <member name="M:SysDisplay.DisplayTransformation.ToMapPoint(System.Int32,System.Int32)">
@brief 从设备点转化为地图点
@param[in] int x 设备X
@param[in] int y 设备Y
@return PointPtr 地图点

</member>
        <member name="M:SysDisplay.DisplayTransformation.FromMapPoints(System.Int32,System.Double*,System.Double*,System.Double*,System.Double*)">
@brief 从地图点转化为设备点
@param[in] int count	    点个数
@param[in] double* mapX	地图点X集合
@param[in] double* mapY	地图点Y集合
@param[out] double* deveiceX	设备点X集合
@param[out] double* deviceY	设备点Y集合
@return bool 转换是否成功

</member>
        <member name="M:SysDisplay.DisplayTransformation.FromMapPoint(SysUtility._ptr_t&lt;SysGeometry.Point&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 从地图点转化为设备点
@param[in] SysGeometry::PointPtr ptrPoint 地图点
@return QPoint 设备点

</member>
        <member name="M:SysDisplay.DisplayTransformation.FromMapPoint(System.Double,System.Double)">
@brief 从地图点转化为设备点
@param[in] double 地图点X
@param[in] double 地图点Y
@return QPoint 设备点

</member>
        <member name="M:SysDisplay.DisplayTransformation.GetZoomResolution">
@brief  获取缩放设备每像素的图上距离
@param[in] bool 是否成功

</member>
        <member name="M:SysDisplay.DisplayTransformation.SetZoomResolution(System.Boolean)">
@brief  设置缩放设备每像素的图上距离
@param[in] bool bValue 是否为真
@return void

</member>
        <member name="M:SysDisplay.DisplayTransformation.ZoomToPageScale(System.Double)">
@brief  缩放制图比例
@param[in] double mapscale 制图比例
@return void

</member>
        <member name="M:SysDisplay.DisplayTransformation.SetPageScale(System.Double)">
@brief 设置制图比例
@param[in] double mapscale 制图比例
@return void

</member>
        <member name="M:SysDisplay.DisplayTransformation.GetPageScale">
@brief 获得制图比例尺
@return 制图比例尺

</member>
        <member name="M:SysDisplay.DisplayTransformation.SetMapScale(System.Double)">
@brief 设置地图比例尺
@param[in] double mapscale 地图比例尺
@return

</member>
        <member name="M:SysDisplay.DisplayTransformation.GetMapScale">
@brief 获得地图比例尺
@return 地图比例尺

</member>
        <member name="M:SysDisplay.DisplayTransformation.SetDpi(System.Int32)">
@brief 设置屏幕的DPI
@param[in] int dpi X
@return

</member>
        <member name="M:SysDisplay.DisplayTransformation.GetDpi">
@brief 获得屏幕的DPI
@return 屏幕DPI

</member>
        <member name="M:SysDisplay.DisplayTransformation.GetResolution">
@brief 获得设备每像素的图上距离
@return 每像素的图上距离

</member>
        <member name="M:SysDisplay.DisplayTransformation.GetExportFrame">
@brief 获得输出范围
@return QRect 输出框架

</member>
        <member name="M:SysDisplay.DisplayTransformation.GetDeviceFrame">
@brief 获得设备范围
@return QRect 设备框架

</member>
        <member name="M:SysDisplay.DisplayTransformation.SetDeviceFrame(QRect!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置设备框架
@param[in] QRect deviceFrame 设备框架
@return bool 是否成功

</member>
        <member name="M:SysDisplay.DisplayTransformation.GetFittedBounds">
 @brief FittedBounds 设置VisibleBounds后，要根据DeviceFrame的宽高比进行修改，修正后的值，保存在FittedBounds。
		 用户输入的原始值，保存在VisibleBounds
 @return  SysGeometry::EnvelopePtr  Envelope包络范围对象

</member>
        <member name="M:SysDisplay.DisplayTransformation.GetVisibleBounds">
@brief 获得可视范围
@return virtualSysGeometry::EnvelopePtr 可视范围

</member>
        <member name="M:SysDisplay.DisplayTransformation.IsOutValidExtent(SysUtility._ptr_t&lt;SysGeometry.Envelope&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 判断范围是否是有效范围
@param[in] SysGeometry::EnvelopePtr ptrEnv 范围
@return bool 是否有效

</member>
        <member name="M:SysDisplay.DisplayTransformation.SetVisibleBounds(SysUtility._ptr_t&lt;SysGeometry.Envelope&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置可视范围
@param[in] SysGeometry::EnvelopePtr ptrVisibleBounds 可视范围
@return bool 是否成功

</member>
        <member name="M:SysDisplay.DisplayTransformation.GetBounds">
@brief 获得全图范围
@return SysGeometry::EnvelopePtr 全图范围

</member>
        <member name="M:SysDisplay.DisplayTransformation.SetBounds(SysUtility._ptr_t&lt;SysGeometry.Envelope&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置全图范围
@param[in] SysGeometry::EnvelopePtr ptrBounds 全图范围
@return bool 是否成功

</member>
        <member name="M:SysDisplay.DisplayTransformation.GetSpatialReference">
@brief 获得空间参考
@return SysGeometry::SpatialReferencePtr 空间参考

</member>
        <member name="M:SysDisplay.DisplayTransformation.SetSpatialReference(SysUtility._ptr_t&lt;SysGeometry.SpatialReference&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置空间参考
@param[in] SysGeometry::SpatialReferencePtr ptrSReference 空间参考
@return bool 是否成功

</member>
        <member name="M:SysDisplay.DisplayTransformation.Dispose">
@brief 析构函数
@return

</member>
        <member name="M:SysDisplay.DisplayTransformation.#ctor">
@brief 构造函数
@return

</member>
        <member name="F:SysDisplay.ITransformEvents.VisibleBoundsUpdated">
@brief 可视地图范围事件
@param[out] DisplayTransformation* 变化后的DisplayTransformation
@param[out] bool 范围是否变化

</member>
        <member name="F:SysDisplay.ITransformEvents.UnitsUpdated">
@brief 单位更新事件
@param[out] DisplayTransformation* 变化后的DisplayTransformation

</member>
        <member name="F:SysDisplay.ITransformEvents.RotationUpdated">
@brief 地图旋转变化事件
@param[out] DisplayTransformation* 变化后的DisplayTransformation

</member>
        <member name="F:SysDisplay.ITransformEvents.ResolutionUpdated">
@brief 分辨率变化事件
@param[out] DisplayTransformation* 变化后的DisplayTransformation

</member>
        <member name="F:SysDisplay.ITransformEvents.DeviceFrameUpdated">
@brief 设备范围变化事件
@param[out] DisplayTransformation* 变化后的DisplayTransformation

</member>
        <member name="F:SysDisplay.ITransformEvents.BoundsUpdated">
@brief 地图范围变化事件
@param[out] DisplayTransformation* 变化后的DisplayTransformation

</member>
        <member name="T:SysDisplay.ITransformEvents">
@class ITransformEvents
@brief 变化事件类

</member>
        <member name="T:SysDisplay.DisplayTransformation">
@brief 类的前置声明


@brief 类的前置声明和智能指针定义
@return


@class DisplayTransformation
	* @brief 显示转换

</member>
        <member name="F:SysGeometry.Point.m_Z">
@brief Z

</member>
        <member name="F:SysGeometry.Point.m_Y">
@brief Y

</member>
        <member name="F:SysGeometry.Point.m_X">
@brief X

</member>
        <member name="M:SysGeometry.Point.Equals(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 是否相等
@param[in] const GeometryPtr ptrGeo 空间几何图形对象
@return bool 是否相等

</member>
        <member name="M:SysGeometry.Point.Clone">
@brief 克隆
@return GeometryPtr 克隆成果

</member>
        <member name="M:SysGeometry.Point.Scale(SysUtility._ptr_t&lt;SysGeometry.Point&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
@brief 缩放
@param[in] PointPtr originPoint 参照点
@param[in] double sx x方向缩放
@param[in] double sy y方向缩放
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Point.Rotate(SysUtility._ptr_t&lt;SysGeometry.Point&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
@brief 旋转
@param[in] PointPtr originPoint 参照点
@param[in] double rotationAngle 旋转角度
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Point.Move(System.Double,System.Double)">
@brief 移动
@param[in] double dx x方向的偏移
@param[in] double dy y方向的偏移
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Point.Transform(SysUtility._ptr_t&lt;SysGeometry.CoordinateTransformation&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 投影转换（会忽略原来的空间参考）
@param[in] CoordinateTransformationPtr ptrCT 坐标转换对象
@return bool 是否转换成功

</member>
        <member name="M:SysGeometry.Point.Centroid">
@brief 获得质点
@return GeometryPtr 质点

</member>
        <member name="M:SysGeometry.Point.GetEnvelope">
@brief 获得空间范围
@return GeometryPtr 空间范围

</member>
        <member name="M:SysGeometry.Point.IsValid">
@brief 是否是有效的
@return bool 是否是有效的

</member>
        <member name="M:SysGeometry.Point.IsSimple">
@brief 是否是简单几何形状
@return bool 是否是简单几何形状

</member>
        <member name="M:SysGeometry.Point.IsEmpty">
@brief 是否为空
@return bool 是否为空

</member>
        <member name="M:SysGeometry.Point.SetEmpty">
@brief 设置为空
@return bool

</member>
        <member name="M:SysGeometry.Point.PutCoords(System.Double,System.Double,System.Double)">
@brief 设置坐标值
@param[in] double x X坐标值
@param[in] double y Y坐标值
@param[in] double z Z坐标值
@return void

</member>
        <member name="M:SysGeometry.Point.SetZ(System.Double)">
@brief 设置Z的值
@param[in] double z Z坐标值
@return void

</member>
        <member name="M:SysGeometry.Point.SetY(System.Double)">
@brief 设置Y的值
@param[in] double y Y坐标值
@return void

</member>
        <member name="M:SysGeometry.Point.SetX(System.Double)">
@brief 设置X的值
@param[in] double x X坐标值
@return void

</member>
        <member name="M:SysGeometry.Point.GetZ">
@brief 获得Z的值
@return double

</member>
        <member name="M:SysGeometry.Point.GetY">
@brief 获得Y的值
@return double

</member>
        <member name="M:SysGeometry.Point.GetX">
@brief 获得X的值
@return double

</member>
        <member name="M:SysGeometry.Point.Dispose">
@brief 析构函数
@return

</member>
        <member name="M:SysGeometry.Point.#ctor(System.Double,System.Double,System.Double)">
@brief 构造函数
@param[in] double x X
@param[in] double y Y
@param[in] double z Z
@return

</member>
        <member name="M:SysGeometry.Point.#ctor">
@brief 构造函数
@return

</member>
        <member name="F:SysGeometry.Envelope.m_MaxY">
@brief 最大的Y

</member>
        <member name="F:SysGeometry.Envelope.m_MaxX">
@brief 最大的X

</member>
        <member name="F:SysGeometry.Envelope.m_MinY">
@brief 最小的Y

</member>
        <member name="F:SysGeometry.Envelope.m_MinX">
@brief 最小的X

</member>
        <member name="M:SysGeometry.Envelope.Buffer(System.Double)">
@brief 缓冲区查询
@param[in] double tolerance 缓冲距离，正数表示向外，负数表示向里
@return GeometryPtr 缓冲区

</member>
        <member name="M:SysGeometry.Envelope.SymDifference(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 计算当前几何体和给定几何体的对称差集
@param[in] const GeometryPtr ptrGeo 给定的几何体
@return GeometryPtr 对称差集

</member>
        <member name="M:SysGeometry.Envelope.Difference(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 计算当前几何体和给定几何体的差集
@param[in] const GeometryPtr ptrGeo 给定的几何体
@return GeometryPtr 差集

</member>
        <member name="M:SysGeometry.Envelope.Union(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 计算当前几何体和给定几何体的并集
@param[in] const GeometryPtr ptrGeo 给定的几何体
@return GeometryPtr 并集

</member>
        <member name="M:SysGeometry.Envelope.Intersection(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 计算当前几何体和给定几何体的交集
@param[in] const GeometryPtr ptrGeo 给定的几何体
@return GeometryPtr 交集

</member>
        <member name="M:SysGeometry.Envelope.ConvexHull">
@brief 计算当前几何形状的凸多边形
@return GeometryPtr 当前几何形状的凸多边形

</member>
        <member name="M:SysGeometry.Envelope.Boundary">
@brief 计算当前几何体的边界
@return GeometryPtr 当前几何体的边界

</member>
        <member name="M:SysGeometry.Envelope.Polygonize">
@brief 将一系列的边界构成一个多边形，只针对MultiLineString有效
@return GeometryPtr 构成的多边形，如果失败返回空

</member>
        <member name="M:SysGeometry.Envelope.SimplifyPreserveTopology(System.Double)">
@brief 保持拓扑关系的情况下对当前几何体进行简化
@param[in] double tolerance 简化过程中的距离容差
@return GeometryPtr 几何图形对象

</member>
        <member name="M:SysGeometry.Envelope.Simplify(System.Double)">
@brief 对当前几何体进行简化使得拓扑正确
@param[in] double tolerance 简化过程中的距离容差
@return GeometryPtr 几何图形对象

</member>
        <member name="M:SysGeometry.Envelope.Scale(SysUtility._ptr_t&lt;SysGeometry.Point&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
@brief 缩放
@param[in] PointPtr originPoint 参照点
@param[in] double sx x方向缩放
@param[in] double sy y方向缩放
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Envelope.Rotate(SysUtility._ptr_t&lt;SysGeometry.Point&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
@brief 旋转
@param[in] PointPtr originPoint 参照点
@param[in] double rotationAngle 旋转角度
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Envelope.Move(System.Double,System.Double)">
@brief 移动
@param[in] double dx x方向的偏移
@param[in] double dy y方向的偏移
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Envelope.Overlaps(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 是否重叠
@param[in] const GeometryPtr ptrGeo 空间几何图形对象
@return bool 是否重叠

</member>
        <member name="M:SysGeometry.Envelope.Contains(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 是否包含
@param[in] const GeometryPtr ptrGeo 空间几何图形对象
@return bool 是否包含

</member>
        <member name="M:SysGeometry.Envelope.Within(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 是否在其内部
@param[in] const GeometryPtr ptrGeo 空间几何图形对象
@return bool 是否在其内部

</member>
        <member name="M:SysGeometry.Envelope.Crosses(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 是否穿越
@param[in] const GeometryPtr ptrGeo 空间几何图形对象
@return bool 是否穿越

</member>
        <member name="M:SysGeometry.Envelope.Touches(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 是否相接
@param[in] const GeometryPtr ptrGeo 空间几何图形对象
@return bool 是否相接

</member>
        <member name="M:SysGeometry.Envelope.Disjoint(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 是否相离
@param[in] const GeometryPtr ptrGeo 空间几何图形对象
@return bool 是否相离

</member>
        <member name="M:SysGeometry.Envelope.Equals(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 是否相等
@param[in] const GeometryPtr ptrGeo 空间几何图形对象
@return bool 是否相等

</member>
        <member name="M:SysGeometry.Envelope.Intersects(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 是否相交
@param[in] const GeometryPtr ptrGeo 空间几何图形对象
@return bool 是否相交

</member>
        <member name="M:SysGeometry.Envelope.GetArea">
@brief 获得面积
@return double

</member>
        <member name="M:SysGeometry.Envelope.GetLength">
@brief 获得长度
@return double 长度

</member>
        <member name="M:SysGeometry.Envelope.Clone">
@brief 克隆
@return GeometryPtr 克隆成果

</member>
        <member name="M:SysGeometry.Envelope.Transform(SysUtility._ptr_t&lt;SysGeometry.CoordinateTransformation&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 投影转换（会忽略原来的空间参考）
@param[in] CoordinateTransformationPtr ptrCT 坐标转换对象
@return bool 是否转换成功

</member>
        <member name="M:SysGeometry.Envelope.Centroid">
@brief 获得质点
@return GeometryPtr 质点

</member>
        <member name="M:SysGeometry.Envelope.GetEnvelope">
@brief 获得空间范围
@return GeometryPtr 空间范围

</member>
        <member name="M:SysGeometry.Envelope.IsValid">
@brief 是否是有效的
@return bool 是否是有效的

</member>
        <member name="M:SysGeometry.Envelope.IsSimple">
@brief 是否是简单几何形状
@return bool 是否是简单几何形状

</member>
        <member name="M:SysGeometry.Envelope.IsEmpty">
@brief 是否为空
@return bool 是否为空

</member>
        <member name="M:SysGeometry.Envelope.SetEmpty">
@brief 设置为空
@return bool

</member>
        <member name="M:SysGeometry.Envelope.Normalize">
@brief 规范化（重新配置最大和最小的X和Y） 
@return void

</member>
        <member name="M:SysGeometry.Envelope.CenterAt(SysUtility._ptr_t&lt;SysGeometry.Point&gt;)">
@brief 重新设置中心点
@param[in] PointPtr ptrPoint 中心点
@return void

</member>
        <member name="M:SysGeometry.Envelope.CenterAt(System.Double,System.Double)">
@brief 重新设置中心点
@param[in] double dx 中心点X
@param[in] double dy 中心点Y
@return void

</member>
        <member name="M:SysGeometry.Envelope.Expand(System.Double,System.Double,System.Boolean)">
@brief 缩放范围
@param[in] double dx X方向的缩放参数
@param[in] double dy Y方向的缩放参数
@param[in] bool asRatio 是否按照比例缩放
@return void

</member>
        <member name="M:SysGeometry.Envelope.PutCoords(System.Double,System.Double,System.Double,System.Double)">
@brief 设置四至坐标
@param[in] double xMin 左下角的X
@param[in] double yMin 左下角的Y
@param[in] double xMax 右下角的X
@param[in] double yMax 右下角的Y
@return void

</member>
        <member name="M:SysGeometry.Envelope.SetYMax(System.Double)">
@brief 设置右上角Y坐标
@param[in] double yMax 右上角Y坐标
@return void

</member>
        <member name="M:SysGeometry.Envelope.GetYMax">
@brief 获得右上角Y坐标
@return double

</member>
        <member name="M:SysGeometry.Envelope.SetXMax(System.Double)">
@brief 设置右上角X坐标
@param[in] double xMax 右上角X坐标
@return void

</member>
        <member name="M:SysGeometry.Envelope.GetXMax">
@brief 获得右上角X坐标
@return double

</member>
        <member name="M:SysGeometry.Envelope.SetYMin(System.Double)">
@brief 设置左下角Y坐标
@param[in] double yMin 左下角Y坐标
@return void

</member>
        <member name="M:SysGeometry.Envelope.GetYMin">
@brief 获得左下角Y坐标
@return double

</member>
        <member name="M:SysGeometry.Envelope.SetXMin(System.Double)">
@brief 设置左下角X坐标
@param[in] double xMin 左下角X坐标
@return void

</member>
        <member name="M:SysGeometry.Envelope.GetXMin">
@brief 获得左下角X坐标
@return double

</member>
        <member name="M:SysGeometry.Envelope.GetHeight">
@brief 获得高度
@return double

</member>
        <member name="M:SysGeometry.Envelope.GetWidth">
@brief 获得宽度
@return double

</member>
        <member name="M:SysGeometry.Envelope.Dispose">
@brief 析构函数
@param[in] void
@return

</member>
        <member name="M:SysGeometry.Envelope.#ctor(SysUtility._ptr_t&lt;SysGeometry.Point&gt;,SysUtility._ptr_t&lt;SysGeometry.Point&gt;)">
@brief 构造函数
@param[in] PointPtr ptrPoint1 边界点1
@param[in] PointPtr ptrPoint2 边界点2
@return

</member>
        <member name="M:SysGeometry.Envelope.#ctor(System.Double,System.Double,System.Double,System.Double)">
@brief 构造函数
@param[in] double xMin 左下角的X
@param[in] double yMin 左下角的Y
@param[in] double xMax 右上角的X
@param[in] double yMax 右上角的Y
@return

</member>
        <member name="M:SysGeometry.Envelope.#ctor">
@brief 构造函数
@param[in] void
@return

</member>
        <member name="F:SysGeometry.Geometry.m_ptrSpatialReference">
@brief 空间参考

</member>
        <member name="F:SysGeometry.Geometry.m_GeometryType">
@brief 几何对象类型

</member>
        <member name="F:SysGeometry.Geometry.m_Dimension">
@brief 几何体的维度

</member>
        <member name="M:SysGeometry.Geometry.GetArea">
@brief 获得面积
@returndouble

</member>
        <member name="M:SysGeometry.Geometry.GetLength">
@brief 获得长度
@return double 长度

</member>
        <member name="M:SysGeometry.Geometry.Clone">
@brief 克隆
@return GeometryPtr 克隆成果

</member>
        <member name="M:SysGeometry.Geometry.Scale(SysUtility._ptr_t&lt;SysGeometry.Point&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
@brief 缩放
@param[in] PointPtr originPoint 参照点
@param[in] double sx x方向缩放
@param[in] double sy y方向缩放
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Geometry.Rotate(SysUtility._ptr_t&lt;SysGeometry.Point&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
@brief 旋转
@param[in] PointPtr originPoint 参照点
@param[in] double rotationAngle 旋转角度
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Geometry.Move(System.Double,System.Double)">
@brief 移动
@param[in] double dx x方向的偏移
@param[in] double dy y方向的偏移
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Geometry.Transform(SysUtility._ptr_t&lt;SysGeometry.CoordinateTransformation&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 投影转换（会忽略原来的空间参考）
@param[in] CoordinateTransformationPtr ptrCT 坐标转换对象
@return bool 是否转换成功

</member>
        <member name="M:SysGeometry.Geometry.Transform(SysUtility._ptr_t&lt;SysGeometry.SpatialReference&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 投影转换
@param[in] SpatialReferencePtr ptrSR_Target 目标空间参考
@return bool 是否转换成功

</member>
        <member name="M:SysGeometry.Geometry.Centroid">
@brief 获得质点
@return GeometryPtr 质点

</member>
        <member name="M:SysGeometry.Geometry.GetEnvelope">
@brief 获得空间范围
@return GeometryPtr 空间范围

</member>
        <member name="M:SysGeometry.Geometry.IsValid">
@brief 是否是有效的
@return bool 是否是有效的

</member>
        <member name="M:SysGeometry.Geometry.IsSimple">
@brief 是否是简单几何形状
@return bool 是否是简单几何形状

</member>
        <member name="M:SysGeometry.Geometry.IsEmpty">
@brief 是否为空
@return bool 是否为空

</member>
        <member name="M:SysGeometry.Geometry.SetEmpty">
@brief 设置为空
@return bool 是否设置成功

</member>
        <member name="M:SysGeometry.Geometry.SetSpatialReference(SysUtility._ptr_t&lt;SysGeometry.SpatialReference&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 设置空间参考（如果存在直接覆盖，不是转换）
@param[in] SpatialReferencePtr ptrSR 空间参考
@return bool 是否设置成功

</member>
        <member name="M:SysGeometry.Geometry.GetSpatialReference">
@brief 获得空间参考
@return SpatialReferencePtr 空间参考

</member>
        <member name="M:SysGeometry.Geometry.GetGeometryType">
@brief 获得几何体的类型
@return GeometryType 几何体的类型

</member>
        <member name="M:SysGeometry.Geometry.GetDimension">
@brief 获得几何体的维度
@return int 几何体的维度

</member>
        <member name="M:SysGeometry.Geometry.Dispose">
@brief 析构函数
@return

</member>
        <member name="M:SysGeometry.Geometry.#ctor">
@brief 构造函数
@return

</member>
        <member name="T:SysGeometry.Envelope">
@brief 类的前置声明和智能指针的定义


@class Envelope
	* @brief 包络线对象

</member>
        <member name="T:SysGeometry.GeometryHitPartType">
@class GeometryHitPartType
	* @brief 几何图形类型 枚举

</member>
        <member name="F:GeometryPartEndpoint">
@brief Hit结尾点

</member>
        <member name="F:GeometryPartCentroid">
@brief Hit中心点

</member>
        <member name="F:GeometryPartMidpoint">
@brief Hit中点

</member>
        <member name="F:GeometryPartBoundary">
@brief Hit边

</member>
        <member name="F:GeometryPartVertex">
@brief Hit节点

</member>
        <member name="F:GeometryPartNone">
@brief 无Hit

</member>
        <member name="M:SysGeometry.SpatialTopological.Buffer(System.Double)">
@brief 缓冲区查询
@param[in] double tolerance 缓冲距离，正数表示向外，负数表示向里
@return GeometryPtr 缓冲区

</member>
        <member name="M:SysGeometry.SpatialTopological.SymDifference(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 计算当前几何体和给定几何体的对称差集
@param[in] const GeometryPtr ptrGeo 给定的几何体
@return GeometryPtr 对称差集

</member>
        <member name="M:SysGeometry.SpatialTopological.Difference(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 计算当前几何体和给定几何体的差集
@param[in] const GeometryPtr ptrGeo 给定的几何体
@return GeometryPtr 差集

</member>
        <member name="M:SysGeometry.SpatialTopological.Union(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 计算当前几何体和给定几何体的并集
@param[in] const GeometryPtr ptrGeo 给定的几何体
@return GeometryPtr 并集

</member>
        <member name="M:SysGeometry.SpatialTopological.Intersection(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 计算当前几何体和给定几何体的交集
@param[in] const GeometryPtr ptrGeo 给定的几何体
@return GeometryPtr 交集

</member>
        <member name="M:SysGeometry.SpatialTopological.ConvexHull">
@brief 计算当前几何形状的凸多边形
@return GeometryPtr 当前几何形状的凸多边形

</member>
        <member name="M:SysGeometry.SpatialTopological.Boundary">
@brief 计算当前几何体的边界
@return GeometryPtr 当前几何体的边界

</member>
        <member name="M:SysGeometry.SpatialTopological.Polygonize">
@brief 将一系列的边界构成一个多边形，只针对MultiLineString有效
@return GeometryPtr 构成的多边形，如果失败返回空

</member>
        <member name="M:SysGeometry.SpatialTopological.SimplifyPreserveTopology(System.Double)">
@brief 保持拓扑关系的情况下对当前几何体进行简化
@param[in] double tolerance 简化过程中的距离容差
@return GeometryPtr 几何图形对象

</member>
        <member name="M:SysGeometry.SpatialTopological.Simplify(System.Double)">
@brief 对当前几何体进行简化使得拓扑简化
@param[in] double tolerance 简化过程中的距离容差
@return GeometryPtr 几何图形对象

</member>
        <member name="M:SysGeometry.SpatialTopological.Dispose">
@brief 析构函数
@return

</member>
        <member name="M:SysGeometry.SpatialTopological.#ctor">
@brief 构造函数
@return

</member>
        <member name="T:SysGeometry.SpatialTopological">
@class SpatialTopological
	* @brief 空间拓扑类

</member>
        <member name="M:SysGeometry.SpatialRelation.Overlaps(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 是否重叠
@param[in] const GeometryPtr ptrGeo 空间几何图形对象
@return bool 是否重叠

</member>
        <member name="M:SysGeometry.SpatialRelation.Contains(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 是否包含
@param[in] const GeometryPtr ptrGeo 空间几何图形对象
@return bool 是否包含

</member>
        <member name="M:SysGeometry.SpatialRelation.Within(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 是否在其内部
@param[in] const GeometryPtr ptrGeo 空间几何图形对象
@return bool 是否在其内部

</member>
        <member name="M:SysGeometry.SpatialRelation.Crosses(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 是否穿越
@param[in] const GeometryPtr ptrGeo 空间几何图形对象
@return bool 是否穿越

</member>
        <member name="M:SysGeometry.SpatialRelation.Touches(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 是否相接
@param[in] const GeometryPtr ptrGeo 空间几何图形对象
@return bool 是否相接

</member>
        <member name="M:SysGeometry.SpatialRelation.Disjoint(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 是否相离
@param[in] const GeometryPtr ptrGeo 空间几何图形对象
@return bool 是否相离

</member>
        <member name="M:SysGeometry.SpatialRelation.Equals(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 是否相等
@param[in] const GeometryPtr ptrGeo 空间几何图形对象
@return bool 是否相等

</member>
        <member name="M:SysGeometry.SpatialRelation.Intersects(SysUtility._ptr_t&lt;SysGeometry.Geometry&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 是否相交
@param[in] const GeometryPtr ptrGeo 空间几何图形对象
@return bool 是否相交

</member>
        <member name="M:SysGeometry.SpatialRelation.Dispose">
@brief 析构函数
@return

</member>
        <member name="M:SysGeometry.SpatialRelation.#ctor">
@brief 构造函数
@return

</member>
        <member name="T:SysGeometry.SpatialRelation">
@class SpatialRelation
	* @brief 空间关系类

</member>
        <member name="T:SysGeometry.Geometry">
@brief 类的前置声明和智能指针的定义


@brief 类的前置声明和智能指针的定义


@brief 类的前置声明和智能指针的定义


@class Geometry
@brief 几何对象

</member>
        <member name="M:SysGeometry.Transform2D.Scale(SysUtility._ptr_t&lt;SysGeometry.Point&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
@brief 缩放
@param[in] PointPtr originPoint 参照点
@param[in] double sx x方向缩放
@param[in] double sy y方向缩放
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Transform2D.Rotate(SysUtility._ptr_t&lt;SysGeometry.Point&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
@brief 旋转
@param[in] PointPtr originPoint 参照点
@param[in] double rotationAngle 旋转角度
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Transform2D.Move(System.Double,System.Double)">
@brief 移动
@param[in] double dx x方向的偏移
@param[in] double dy y方向的偏移
@return bool 是否成功

</member>
        <member name="M:SysGeometry.Transform2D.Dispose">
@brief 析构函数
@return

</member>
        <member name="M:SysGeometry.Transform2D.#ctor">
@brief 构造函数
@return

</member>
        <member name="T:SysGeometry.Transform2D">
@class Transform2D
	* @brief 二维变换

</member>
        <member name="T:SysGeometry.Point">
@brief 类的前期声明和智能指针的定义


@brief 类的前置声明和智能指针的定义


@class Point
	* @brief 点几何图形

</member>
        <member name="D:SysGeometry.CoordinateTransformationPtr">
@brief  坐标转换 智能指针对象

</member>
        <member name="F:SysGeometry.CoordinateTransformation.m_pOGRCoordinateTransformation">
@brief OGR的坐标转换对象

</member>
        <member name="F:SysGeometry.CoordinateTransformation.m_ptrSpatialReferenceTarget">
@brief 目标坐标系统

</member>
        <member name="F:SysGeometry.CoordinateTransformation.m_ptrSpatialReferenceSource">
@brief 源坐标系统

</member>
        <member name="M:SysGeometry.CoordinateTransformation.TransformEx(System.Int32,System.Double*,System.Double*,System.Double*,System.Int32*)">
@brief 坐标准换
@param[in] int count 要转换的点个数
@param[in] double* pX 要转换的点的X坐标数组
@param[in] double* pY 要转换的点的Y坐标数组
@param[in] double* pZ 要转换的点的Z坐标数组
@param[in] int* pSuccess 每个坐标是否转换成功的标记
@return bool 是否成功

</member>
        <member name="M:SysGeometry.CoordinateTransformation.Transform(System.Int32,System.Double*,System.Double*,System.Double*)">
@brief 坐标准换
@param[in] int count 要转换的点个数
@param[in] double* pX 要转换的点的X坐标数组
@param[in] double* pY 要转换的点的Y坐标数组
@param[in] double* pZ 要转换的点的Z坐标数组
@return bool 是否成功

</member>
        <member name="M:SysGeometry.CoordinateTransformation.GetTargetSpatialReference">
@brief 获得目标坐标系
@return SpatialReferencePtr 目标坐标系

</member>
        <member name="M:SysGeometry.CoordinateTransformation.GetSourceSpatialReference">
@brief 获得源坐标系
@return SpatialReferencePtr 源坐标系

</member>
        <member name="M:SysGeometry.CoordinateTransformation.Dispose">
@brief 析构函数
@return

</member>
        <member name="M:SysGeometry.CoordinateTransformation.#ctor(SysUtility._ptr_t&lt;SysGeometry.SpatialReference&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t&lt;SysGeometry.SpatialReference&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief  构造函数
@param[in] SpatialReferencePtr ptrSourceSpatialReference 源坐标系
@param[in] SpatialReferencePtr ptrTargetSpatialReference 目标坐标系
@return

</member>
        <member name="T:SysGeometry.CoordinateTransformation">
@class CoordinateTransformation
	* @brief 坐标转换对象

</member>
        <member name="M:SysGeometry.SpatialReference.Clone">
@brief Clone方法
@return SpatialReferencePtr 空间参考对象指针

</member>
        <member name="M:SysGeometry.SpatialReference.GetHandle">
@brief 返回OGRSpatialReference的指针
@return void* 指针句柄

</member>
        <member name="M:SysGeometry.SpatialReference.MorphFromESRI">
@brief MorphFromESRI 从ESRI字符串转化为OGC的WKT字符串
@return bool 是否成功

</member>
        <member name="M:SysGeometry.SpatialReference.MorphToESRI">
@brief MorphToESRI 从OGC的WKT字符串转化为ESRI的WKT字符串
@return bool 是否成功

</member>
        <member name="M:SysGeometry.SpatialReference.ImportFromESRI(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 从ESRI字符串导入
@param[in] QString strValue ESRI字符串
@return bool 是否成功

</member>
        <member name="M:SysGeometry.SpatialReference.ImportFromEPSG(System.Int32)">
@brief 从EPSG编码导入
@param[in] EPSG编码
@return bool 是否成功

</member>
        <member name="M:SysGeometry.SpatialReference.ExportToProj4">
@brief 导出为Proj4字符串
@return QString Proj4字符串

</member>
        <member name="M:SysGeometry.SpatialReference.ImportFromProj4(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 从Proj4字符串导入
@param[in] QString strValue Proj4字符串
@return bool 是否成功

</member>
        <member name="M:SysGeometry.SpatialReference.ExportToPrettyWkt">
@brief ExportToPrettyWkt 导出为格式化后的WKT字符串
@return QString 格式化后的WKT字符串

</member>
        <member name="M:SysGeometry.SpatialReference.ExportToWkt">
@brief ExportToWkt 导出为WKT字符串
@return QString WKT字符串

</member>
        <member name="M:SysGeometry.SpatialReference.ImportFromUserInput(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*)">
@brief 从Proj4字符串导入
@param[in] QString strProj Proj字符串
@return bool 是否成功

</member>
        <member name="M:SysGeometry.SpatialReference.ImportFromWkt(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*)">
@brief 从WKT字符串导入
@param[in] QString strWkT WKT字符串
@return bool 是否成功

</member>
        <member name="M:SysGeometry.SpatialReference.ImportFromWkt(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 从WKT字符串导入
@param[in] QString strWkT WKT字符串
@return bool 是否成功

</member>
        <member name="M:SysGeometry.SpatialReference.SetRemarks(QString)">
@brief 设置备注信息
@param[in] QString remarks 备注信息
@return

</member>
        <member name="M:SysGeometry.SpatialReference.GetRemarks">
@brief 获得备注信息
@return QString 备注信息

</member>
        <member name="M:SysGeometry.SpatialReference.GetType">
@brief 获取类型
@return SpatialReferenceType 坐标系类型

</member>
        <member name="M:SysGeometry.SpatialReference.SetAlias(QString)">
@brief 设置别名
@param[in] QString alias 别名
@return void

</member>
        <member name="M:SysGeometry.SpatialReference.GetAlias">
@brief 获取别名
@return QString 别名

</member>
        <member name="M:SysGeometry.SpatialReference.SetName(QString)">
@brief 设置名称
@param[in] QString name 名称
@return void

</member>
        <member name="M:SysGeometry.SpatialReference.GetName">
@brief 获得名字
@return QString 名称

</member>
        <member name="M:SysGeometry.SpatialReference.GetFactoryCode">
@brief 获得编码
@return int 编码

</member>
        <member name="M:SysGeometry.SpatialReference.Dispose">
@brief 析构函数
@return

</member>
        <member name="F:SysGeometry.SpatialReference.m_SpatialReferenceType">
@brief 成员变量 空间参考类型

</member>
        <member name="M:SysGeometry.SpatialReference.#ctor">
@brief 构造函数
@return

</member>
        <member name="D:SysGeometry.SpatialReferencePtr">
@brief 智能指针对象

</member>
        <member name="T:SysGeometry.SpatialReference">
@brief 类的前置声明


@class SpatialReference
	* @brief 空间参考接口

</member>
        <member name="T:SysGeometry.SpatialReferenceType">
@class SpatialReferenceType
	* @brief 空间参考类型

</member>
        <member name="F:ProjectedCS">
@brief 投影坐标系

</member>
        <member name="F:GeographicCS">
@brief 地理坐标系

</member>
        <member name="F:UnknownCS">
@brief 未知坐标系

</member>
        <member name="T:SysGeometry.GeometryType">
@enum  GeometryType
	* @brief  几何图形类型 枚举

</member>
        <member name="F:GeometryBSplineCurve">
@brief 平滑B样条曲线

</member>
        <member name="F:GeometryScrewLine">
@brief 螺线

</member>
        <member name="F:GeometrySplineCurve">
@brief 样条曲线

</member>
        <member name="F:GeometryGeometryCollection">
@brief 图形集合

</member>
        <member name="F:GeometryEllipse">
@brief 多面

</member>
        <member name="F:GeometryEnvelope">
@brief Envelope

</member>
        <member name="F:GeometryMultiPolygon">
@brief 多面

</member>
        <member name="F:GeometryPolygon">
@brief 面

</member>
        <member name="F:GeometryRing">
@brief 环

</member>
        <member name="F:GeometryMultiPolyline">
@brief 多线

</member>
        <member name="F:GeometryArc">
@brief 弧

</member>
        <member name="F:GeometryPolyline">
@brief 线

</member>
        <member name="F:GeometryMultiPoint">
@brief 多点

</member>
        <member name="F:GeometryPoint">
@brief 点

</member>
        <member name="F:GeometryUnknown">
@brief 无类型

</member>
        <member name="T:SysUI.pieUnits">
@class pieUnits
	* @brief PIE中长度单位

</member>
        <member name="F:UnitsCount">
@brief 单位数量

</member>
        <member name="F:UnitsDecimeters">
@brief 分米

</member>
        <member name="F:UnitsDecimalDegrees">
@brief 度（十进制）

</member>
        <member name="F:UnitsKilometers">
@brief 千米

</member>
        <member name="F:UnitsMeters">
@brief 米

</member>
        <member name="F:UnitsCentimeters">
@brief 厘米

</member>
        <member name="F:UnitsMillimeters">
@brief 毫米

</member>
        <member name="F:UnitsNauticalMiles">
@brief 海里

</member>
        <member name="F:UnitsMiles">
@brief 英里

</member>
        <member name="F:UnitsYards">
@brief 码

</member>
        <member name="F:UnitsFeet">
@brief 英尺

</member>
        <member name="F:UnitsPoints">
@brief 点

</member>
        <member name="F:UnitsInches">
@brief 英寸

</member>
        <member name="F:UnitsUnknown">
@brief 未知

</member>
        <member name="D:SysUI.CMDPluginModulePtr">
@brief 命令插件管理器智能指针

</member>
        <member name="M:SysUI.CMDPluginModule.#ctor">
@brief  构造函数

</member>
        <member name="M:SysUI.CMDPluginModule.CreateLibCommand(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 根据名称创建命令插件对象
@param [in] strLibName 库名称,strCmd 命令插件名称 , strParam 默认参数
@return ICommandPtr 命令插件对象

</member>
        <member name="M:SysUI.CMDPluginModule.CreateCommand(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@brief 根据字符命令创建命令插件对象
@param [in] strCmd 命令插件名称 , strParam 默认参数
@return ICommandPtr 命令插件对象

</member>
        <member name="M:SysUI.CMDPluginModule.Dispose">
@brief  析构函数

</member>
        <member name="T:SysUI.CMDPluginModule">
@class CMDPluginModule
	* @brief 命令插件管理器

</member>
        <member name="M:PIE.Controls.BringToFrontElementsCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.BringToFrontElementsCommand">
            <summary>
置于顶层
</summary>
        </member>
        <member name="M:PIE.Controls.DrawPictureElementCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.DrawPictureElementCommand">
            <summary>
绘制图片元素
</summary>
        </member>
        <member name="M:PIE.Controls.HTHTImageCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.HTHTImageCommand">
            <summary>
宏图影像图
</summary>
        </member>
        <member name="M:PIE.Controls.MarkClearCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.MarkClearCommand">
            <summary>
清空标绘
</summary>
        </member>
        <member name="M:PIE.Controls.SendBackwardElementsCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.SendBackwardElementsCommand">
            <summary>
下移一层
</summary>
        </member>
        <member name="M:PIE.Controls.ConvertToGraphicsCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.ConvertToGraphicsCommand">
            <summary>
转化为图形
</summary>
        </member>
        <member name="M:PIE.Controls.DrawFreehandElementTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.DrawFreehandElementTool">
            <summary>
画自由线工具
</summary>
        </member>
        <member name="M:PIE.Controls.CenterAlignmentElementCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.CenterAlignmentElementCommand">
            <summary>
左右居中对齐
</summary>
        </member>
        <member name="M:PIE.Controls.PagePanTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.PagePanTool">
            <summary>
Page平移
</summary>
        </member>
        <member name="M:PIE.Controls.BingAnnotSatelliteCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.BingAnnotSatelliteCommand">
            <summary>
Bing注记卫星图
</summary>
        </member>
        <member name="M:PIE.Controls.DistributeVerticallyElementsCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.DistributeVerticallyElementsCommand">
            <summary>
垂直分布
</summary>
        </member>
        <member name="M:PIE.Controls.PageZoomOutTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.PageZoomOutTool">
            <summary>
Page拉框缩小
</summary>
        </member>
        <member name="M:PIE.Controls.GaoDeAnnotationCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.GaoDeAnnotationCommand">
            <summary>
高德注记图
</summary>
        </member>
        <member name="M:PIE.Controls.DrawArrowElementTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.DrawArrowElementTool">
            <summary>
绘制箭头元素
</summary>
        </member>
        <member name="M:PIE.Controls.DrawPolylineElementTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.DrawPolylineElementTool">
            <summary>
画线工具
</summary>
        </member>
        <member name="M:PIE.Controls.ResetBrightnessCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.ResetBrightnessCommand">
            <summary>
重置亮度
</summary>
        </member>
        <member name="M:PIE.Controls.FitHeighttoMarginsElementsCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.FitHeighttoMarginsElementsCommand">
            <summary>
调整高度为页边距大小
</summary>
        </member>
        <member name="M:PIE.Controls.DrawBalloonCalloutTextElementTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.DrawBalloonCalloutTextElementTool">
            <summary>
注释工具
</summary>
        </member>
        <member name="M:PIE.Controls.DeleteAllSelectCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.DeleteAllSelectCommand">
            <summary>
删除选择工具
</summary>
        </member>
        <member name="M:PIE.Controls.DrawCircleElementTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.DrawCircleElementTool">
            <summary>
画圆工具
</summary>
        </member>
        <member name="M:PIE.Controls.PageZoomToPreviousExtentCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.PageZoomToPreviousExtentCommand">
            <summary>
添加格网
</summary>
        </member>
        <member name="M:PIE.Controls.AddNorthArrowCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.AddNorthArrowCommand">
            <summary>
指北针
</summary>
        </member>
        <member name="M:PIE.Controls.GoogleRoadCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.GoogleRoadCommand">
            <summary>
谷歌路线图
</summary>
        </member>
        <member name="M:PIE.Controls.BingSatelliteCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.BingSatelliteCommand">
            <summary>
Bing路线图
</summary>
        </member>
        <member name="M:PIE.Controls.MapZoomInTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.MapZoomInTool">
            <summary>
MapZoomInTool对象
</summary>
        </member>
        <member name="M:PIE.Controls.SwipeLayerTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.SwipeLayerTool">
            <summary>
卷帘工具
</summary>
        </member>
        <member name="M:PIE.Controls.ResetTransparentCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.ResetTransparentCommand">
            <summary>
重置透明度
</summary>
        </member>
        <member name="M:PIE.Controls.DistributeHorizontallyElementsCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.DistributeHorizontallyElementsCommand">
            <summary>
水平分布
</summary>
        </member>
        <member name="M:PIE.Controls.DrawLineArrowElementTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.DrawLineArrowElementTool">
            <summary>
绘制箭头元素
</summary>
        </member>
        <member name="M:PIE.Controls.DrawTextElementTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.DrawTextElementTool">
            <summary>
绘制文本元素工具
</summary>
        </member>
        <member name="M:PIE.Controls.PageSettingCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.PageSettingCommand">
            <summary>
Page页设置
</summary>
        </member>
        <member name="M:PIE.Controls.DrawEllipseElementTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.DrawEllipseElementTool">
            <summary>
画椭圆工具
</summary>
        </member>
        <member name="M:PIE.Controls.ResetRasterRenderCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.ResetRasterRenderCommand">
            <summary>
重置渲染
</summary>
        </member>
        <member name="M:PIE.Controls.ResetContrastCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.ResetContrastCommand">
            <summary>
重置对比度
</summary>
        </member>
        <member name="M:PIE.Controls.BottomAlignmentElementCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.BottomAlignmentElementCommand">
            <summary>
底端对齐
</summary>
        </member>
        <member name="M:PIE.Controls.VerticalCenterAlignmentElementCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.VerticalCenterAlignmentElementCommand">
            <summary>
上下居中对齐
</summary>
        </member>
        <member name="M:PIE.Controls.ZoomToNativeCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.ZoomToNativeCommand">
            <summary>
1:1显示
</summary>
        </member>
        <member name="M:PIE.Controls.FitWidthtoMarginsElementsCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.FitWidthtoMarginsElementsCommand">
            <summary>
调整宽度为页边距大小
</summary>
        </member>
        <member name="M:PIE.Controls.PageZoomInTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.PageZoomInTool">
            <summary>
Page拉框放大
</summary>
        </member>
        <member name="M:PIE.Controls.PageZoomToOrigin.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.PageZoomToOrigin">
            <summary>
Page缩放至100%
</summary>
        </member>
        <member name="M:PIE.Controls.CopyElementCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.CopyElementCommand">
            <summary>
复制Element
</summary>
        </member>
        <member name="M:PIE.Controls.DrawPolygonElementTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.DrawPolygonElementTool">
            <summary>
画面工具
</summary>
        </member>
        <member name="M:PIE.Controls.CenterZoomOutCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.CenterZoomOutCommand">
            <summary>
中心缩小
</summary>
        </member>
        <member name="M:PIE.Controls.SendToBackElementsCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.SendToBackElementsCommand">
            <summary>
置于底层
</summary>
        </member>
        <member name="M:PIE.Controls.PasteElementCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.PasteElementCommand">
            <summary>
粘贴Element
</summary>
        </member>
        <member name="M:PIE.Controls.GoogleSatelliteCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.GoogleSatelliteCommand">
            <summary>
谷歌卫星图
</summary>
        </member>
        <member name="M:PIE.Controls.MagicReshapeFeatureTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.MagicReshapeFeatureTool">
            <summary>
整形
</summary>
        </member>
        <member name="M:PIE.Controls.DrawScrewElementTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.DrawScrewElementTool">
            <summary>
绘制点元素
</summary>
        </member>
        <member name="M:PIE.Controls.ZoomToNextExtentCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.ZoomToNextExtentCommand">
            <summary>
下一视图
</summary>
        </member>
        <member name="M:PIE.Controls.CenterZoomInCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.CenterZoomInCommand">
            <summary>
中心放大
</summary>
        </member>
        <member name="M:PIE.Controls.UnmakeGroupCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.UnmakeGroupCommand">
            <summary>
取消组合
</summary>
        </member>
        <member name="M:PIE.Controls.DrawPointElementTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.DrawPointElementTool">
            <summary>
绘制点元素
</summary>
        </member>
        <member name="M:PIE.Controls.AddGridCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.AddGridCommand">
            <summary>
添加格网
</summary>
        </member>
        <member name="M:PIE.Controls.MagicWandSetThresholdCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.MagicWandSetThresholdCommand">
            <summary>
魔术棒右键功能
</summary>
        </member>
        <member name="M:PIE.Controls.DrawRectElementTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.DrawRectElementTool">
            <summary>
画矩形工具
</summary>
        </member>
        <member name="M:PIE.Controls.MapZoomOutTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.MapZoomOutTool">
            <summary>
MapZoomOutTool对象
</summary>
        </member>
        <member name="M:PIE.Controls.SpectralPlotTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.SpectralPlotTool">
            <summary>
波谱坡面图分析
</summary>
        </member>
        <member name="M:PIE.Controls.MakeSameSizeElementsCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.MakeSameSizeElementsCommand">
            <summary>
设置相同大小
</summary>
        </member>
        <member name="M:PIE.Controls.BingMapsCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.BingMapsCommand">
            <summary>
Bing路线图
</summary>
        </member>
        <member name="M:PIE.Controls.DrawPictureElementTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.DrawPictureElementTool">
            <summary>
绘制图片元素
</summary>
        </member>
        <member name="M:PIE.Controls.CartoGraphy_ExportCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.CartoGraphy_ExportCommand">
            <summary>
导出地图
</summary>
        </member>
        <member name="M:PIE.Controls.PanTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.PanTool">
            <summary>
漫游
</summary>
        </member>
        <member name="M:PIE.Controls.ReverseBrightnessCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.ReverseBrightnessCommand">
            <summary>
亮度反转
</summary>
        </member>
        <member name="M:PIE.Controls.EditElementNodeTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.EditElementNodeTool">
            <summary>
元素节点编辑
</summary>
        </member>
        <member name="M:PIE.Controls.AddScaleTextCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.AddScaleTextCommand">
            <summary>
比例尺文本
</summary>
        </member>
        <member name="M:PIE.Controls.PageZoomToNextExtentCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.PageZoomToNextExtentCommand">
            <summary />
        </member>
        <member name="M:PIE.Controls.GaoDeRoadCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.GaoDeRoadCommand">
            <summary>
高德路线图
</summary>
        </member>
        <member name="M:PIE.Controls.RotateElementTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.RotateElementTool">
            <summary>
旋转元素
</summary>
        </member>
        <member name="M:PIE.Controls.AlignToMarginsElementCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.AlignToMarginsElementCommand">
            <summary>
对齐到边缘
</summary>
        </member>
        <member name="M:PIE.Controls.DrawCurveElementTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.DrawCurveElementTool">
            <summary>
画曲线工具
</summary>
        </member>
        <member name="M:PIE.Controls.FullExtentCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.FullExtentCommand">
            <summary>
FullExtentCommand对象
</summary>
        </member>
        <member name="M:PIE.Controls.LockDataFrameCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.LockDataFrameCommand">
            <summary>
锁定
</summary>
        </member>
        <member name="M:PIE.Controls.ExportElementsCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.ExportElementsCommand">
            <summary>
导出标绘
</summary>
        </member>
        <member name="M:PIE.Controls.RasterIdentifyTool.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.RasterIdentifyTool">
            <summary>
绘制点元素
</summary>
        </member>
        <member name="F:PIE.Controls.BaseToolEx.m_pCInstanceTool">
            <summary>
C++源生对象
</summary>
        </member>
        <member name="M:PIE.Controls.BaseToolEx.CreateInstanceInternal(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
创建实例
</summary>
            <param name="strLibName">Lib名称</param>
            <param name="strClassName">算法名称</param>
            <param name="strParames">参数</param>
            <returns>是否执行成功</returns>
        </member>
        <member name="M:PIE.Controls.BaseToolEx.CreateInstance(System.String,System.String,System.String)">
            <summary>
创建实例
</summary>
            <param name="strLibName">Lib名称</param>
            <param name="strClassName">算法名称</param>
            <param name="strParames">参数</param>
            <returns>是否执行成功</returns>
        </member>
        <member name="M:PIE.Controls.BaseToolEx.OnMouseMove(System.Object,System.Windows.Forms.MouseEventArgs)">
            <summary>
鼠标移动操作
</summary>
            <param name="sender">触发对象</param>
            <param name="e">鼠标事件参数</param>
        </member>
        <member name="M:PIE.Controls.BaseToolEx.OnMouseDown(System.Object,System.Windows.Forms.MouseEventArgs)">
            <summary>
鼠标按下操作
</summary>
            <param name="sender">触发对象</param>
            <param name="e">鼠标事件参数</param>
        </member>
        <member name="M:PIE.Controls.BaseToolEx.OnMouseUp(System.Object,System.Windows.Forms.MouseEventArgs)">
            <summary>
鼠标抬起操作
</summary>
            <param name="sender">触发对象</param>
            <param name="e">鼠标事件参数</param>
        </member>
        <member name="M:PIE.Controls.BaseToolEx.OnMouseEnter(System.Object,System.Windows.Forms.MouseEventArgs)">
            <summary>
鼠标进入操作
</summary>
            <param name="sender">触发对象</param>
            <param name="e">鼠标事件参数</param>
        </member>
        <member name="M:PIE.Controls.BaseToolEx.OnKeyUp(System.Object,System.Windows.Forms.KeyEventArgs)">
            <summary>
键盘按键抬起操作
</summary>
            <param name="sender">触发对象</param>
            <param name="e">键盘事件参数</param>
        </member>
        <member name="M:PIE.Controls.BaseToolEx.OnKeyDown(System.Object,System.Windows.Forms.KeyEventArgs)">
            <summary>
键盘按键按下操作
</summary>
            <param name="sender">触发对象</param>
            <param name="e">键盘事件参数</param>
        </member>
        <member name="M:PIE.Controls.BaseToolEx.OnDblClick">
            <summary>
双击
</summary>
        </member>
        <member name="M:PIE.Controls.BaseToolEx.OnContextMenu(System.Int32,System.Int32)">
            <summary>
右键菜单弹出
</summary>
            <param name="x">点击点X</param>
            <param name="y">点击点Y</param>
            <returns>是否成功</returns>
            <summary>
右键菜单弹出
</summary>
            <param name="x">点击点X</param>
            <param name="y">点击点Y</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:PIE.Controls.BaseToolEx.Deactivate">
            <summary>
取消按钮的激活
</summary>
            <returns>是否成功</returns>
        </member>
        <member name="P:PIE.Controls.BaseToolEx.Cursor">
            <summary>
获取光标
</summary>
        </member>
        <member name="M:PIE.Controls.BaseToolEx.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.BaseToolEx">
            <summary>
BaseToolEx对象
</summary>
        </member>
        <member name="D:SysUI.IToolPtr">
@brief 工具插件智能指针

</member>
        <member name="M:SysUI.ITool.OnWheelEvent(QWheelEvent*)">
@brief 鼠标滚轮操作
@param[in] event 鼠标事件参数
@return 是否响应

</member>
        <member name="M:SysUI.ITool.OnLeaveEvent(QEvent*)">
@brief 焦点离开操作
@param [in] event 事件参数
@return

</member>
        <member name="M:SysUI.ITool.OnEnterEvent(QEvent*)">
@brief 焦点进入操作
@param [in] event 事件参数

</member>
        <member name="M:SysUI.ITool.JustMouseMove(QMouseEvent*)">
@brief 鼠标移动操作
@param[in] event 鼠标事件参数
@remark 无鼠标按键时才触发

</member>
        <member name="M:SysUI.ITool.OnMouseUp(QMouseEvent*)">
@brief 鼠标抬起操作
@param[in] event 鼠标事件参数

</member>
        <member name="M:SysUI.ITool.OnMouseMove(QMouseEvent*)">
@brief 鼠标移动操作
@param[in] event 鼠标事件参数
@remark 需要有按键操作

</member>
        <member name="M:SysUI.ITool.OnMouseDown(QMouseEvent*)">
@brief 鼠标按下操作
@param[in] event 鼠标事件参数

</member>
        <member name="M:SysUI.ITool.OnKeyUp(QKeyEvent*)">
@brief 键盘按键抬起操作
@param[in] event 键盘事件参数

</member>
        <member name="M:SysUI.ITool.OnKeyDown(QKeyEvent*)">
@brief 键盘按键按下操作
@param[in] event 键盘事件参数

</member>
        <member name="M:SysUI.ITool.OnDblClick(QMouseEvent*)">
@brief 鼠标双击操作
@param[in] event 鼠标事件参数

</member>
        <member name="M:SysUI.ITool.OnContextMenu(QContextMenuEvent*)">
@brief 菜单操作
@param[in] event 菜单事件参数
@return  成功 true, 失败 false

</member>
        <member name="M:SysUI.ITool.Deactivate">
@brief 取消激活
@return  成功 true,失败 false

</member>
        <member name="M:SysUI.ITool.Activate">
@brief 激活工具
@return 成功 true, 失败 false

</member>
        <member name="M:SysUI.ITool.GetCursor">
@brief 获取光标
@return 光标对象

</member>
        <member name="T:SysUI.ITool">
@class ITool
	* @brief 工具插件接口

</member>
        <member name="M:PIE.Controls.GoogleAnnotationCommand.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.GoogleAnnotationCommand">
            <summary>
谷歌注记图
</summary>
        </member>
        <member name="F:PIE.Controls.BaseCommandEx.m_pCInstance">
            <summary>
C++源生对象
</summary>
        </member>
        <member name="M:PIE.Controls.BaseCommandEx.#ctor(SysUtility._ptr_t&lt;SysUI.ICommand&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
构造函数
</summary>
        </member>
        <member name="M:PIE.Controls.BaseCommandEx.CreateInstanceInternal(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
创建实例
</summary>
            <param name="strLibName">Lib名称</param>
            <param name="strClassName">算法名称</param>
            <param name="strParames">参数</param>
            <returns>是否执行成功</returns>
        </member>
        <member name="M:PIE.Controls.BaseCommandEx.CreateInstance(System.String,System.String,System.String)">
            <summary>
创建实例
</summary>
            <param name="strLibName">Lib名称</param>
            <param name="strClassName">算法名称</param>
            <param name="strParames">参数</param>
            <returns>是否执行成功</returns>
            <summary>
创建实例
</summary>
            <param name="strLibName">Lib名称</param>
            <param name="strClassName">算法名称</param>
            <param name="strParames">参数</param>
            <returns>是否执行成功</returns>
        </member>
        <member name="F:PIE.Controls.BaseCommandEx.m_CommandType">
            <summary>
CommandType对象
</summary>
        </member>
        <member name="F:PIE.Controls.BaseCommandEx.m_HookHelper">
            <summary>
HookHelper对象
</summary>
        </member>
        <member name="F:PIE.Controls.BaseCommandEx.m_Hook">
            <summary>
Hook对象
</summary>
        </member>
        <member name="M:PIE.Controls.BaseCommandEx.GetHandle">
            <summary>
获得C++源生对象指针
</summary>
        </member>
        <member name="M:PIE.Controls.BaseCommandEx.OnClick">
            <summary>
单击事件
</summary>
        </member>
        <member name="M:PIE.Controls.BaseCommandEx.OnCreate(System.Object)">
            <summary>
创建插件对象
</summary>
            <param name="hook">hook</param>
        </member>
        <member name="P:PIE.Controls.BaseCommandEx.Image">
            <summary>
获取按钮图片
</summary>
        </member>
        <member name="P:PIE.Controls.BaseCommandEx.Checked">
            <summary>
获取是否选中
</summary>
        </member>
        <member name="P:PIE.Controls.BaseCommandEx.Enabled">
            <summary>
获取类型名称
</summary>
        </member>
        <member name="P:PIE.Controls.BaseCommandEx.TypeName">
            <summary>
获取类型名称
</summary>
        </member>
        <member name="P:PIE.Controls.BaseCommandEx.Type">
            <summary>
获取Command的Type
</summary>
        </member>
        <member name="P:PIE.Controls.BaseCommandEx.ToolTip">
            <summary>
获取提示信息
</summary>
        </member>
        <member name="P:PIE.Controls.BaseCommandEx.Caption">
            <summary>
获取标题
</summary>
        </member>
        <member name="P:PIE.Controls.BaseCommandEx.Name">
            <summary>
获取名称
</summary>
        </member>
        <member name="M:PIE.Controls.BaseCommandEx.Finalize">
            <summary>
析构函数
</summary>
        </member>
        <member name="M:PIE.Controls.BaseCommandEx.Dispose">
            <summary>
析构函数
</summary>
        </member>
        <member name="M:PIE.Controls.BaseCommandEx.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="T:PIE.Controls.BaseCommandEx">
            <summary>
BaseCommandEx对象
</summary>
        </member>
        <member name="D:SysUI.ICommandPtr">
@brief 命令插件智能指针

</member>
        <member name="M:SysUI.ICommand.OnClick">
@brief 单击事件

</member>
        <member name="M:SysUI.ICommand.OnCreate(System.Void*)">
@brief 创建插件对象
@param[in]  hook

</member>
        <member name="M:SysUI.ICommand.IsChecked">
@brief 是否选中状态
@return true：选中；false：未选中。
@remark 此选项只在命令是工具插件时才使用，且同一时刻，最多一个Tool在选中状态。

</member>
        <member name="M:SysUI.ICommand.IsEnable">
@brief 命令是否可用
@return true：可用；false：不可用。

</member>
        <member name="M:SysUI.ICommand.GetTypeName">
@brief 获取类型名称
@return 类型名称

</member>
        <member name="M:SysUI.ICommand.GetToolTip">
@brief 获取提示信息
@return 提示信息

</member>
        <member name="M:SysUI.ICommand.GetCaption">
@brief 获取标题
@return 标题

</member>
        <member name="M:SysUI.ICommand.GetName">
@brief 获取名称
@return 命令名称

</member>
        <member name="T:SysUI.ICommand">
@class ICommand
	* @brief 命令插件接口

</member>
        <member name="M:SysUtility.CRef.Dispose">
@brief 析构函数 （虚函数）

</member>
        <member name="M:SysUtility.CRef.#ctor">
@brief 构造函数

</member>
        <member name="M:SysUtility.CRef.AddRef">
@brief 计数器独占地自增
@return unsigned long  返回计数器中对象的个数

</member>
        <member name="M:SysUtility.CRef.Release">
@brief 计数器独占地自减
@return unsigned long 返回计数器中对象的个数

</member>
        <member name="T:SysUtility.CRef">
@class CRef
	* @brief 管理引用计数器类

</member>
        <member name="F:PIE.Controls.LanguageManager.m_HasInstalled">
            <summary>
是否已经安装
</summary>
        </member>
        <member name="F:PIE.Controls.LanguageManager.m_ListTranslator">
            <summary>
等待删除的
</summary>
        </member>
        <member name="F:PIE.Controls.LanguageManager.m_Instance">
            <summary>
m_Instance
</summary>
        </member>
        <member name="M:PIE.Controls.LanguageManager.Finalize">
            <summary>
析构函数
</summary>
        </member>
        <member name="M:PIE.Controls.LanguageManager.Dispose">
            <summary>
析构函数
</summary>
        </member>
        <member name="M:PIE.Controls.LanguageManager.#ctor">
            <summary>
构造函数
</summary>
        </member>
        <member name="M:PIE.Controls.LanguageManager.InstallTranslator">
            <summary>
安装语言翻译器
</summary>
        </member>
        <member name="T:PIE.Controls.LanguageManager">
            <summary>
语言管理器
</summary>
        </member>
        <!-- 丢弃成员“M:SysGeometry.SpatialReference.IsSame(SysUtility._ptr_t<SysGeometry.SpatialReference>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysGeometry.SpatialReference.IsSameGeoCS(SysUtility._ptr_t<SysGeometry.SpatialReference>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysGeometry.SpatialTopological.UnionSub(SysUtility._ptr_t<SysGeometry.Geometry>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t<SysGeometry.Geometry>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysGeometry.Geometry.HitTest(SysGeometry.Point*,System.Double,SysGeometry.GeometryHitPartType,SysGeometry.Point*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysGeometry.Geometry.ConvertToSameSpatialReference(SysUtility._ptr_t<SysGeometry.Geometry>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t<SysGeometry.Geometry>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t<SysGeometry.Geometry>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysGeometry.Envelope.QueryCoords(System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysGeometry.Point.QueryCoords(System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysGeometry.Point.QueryCoords(System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysGeometry.Point.Distance(SysUtility._ptr_t<SysGeometry.Point>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysGeometry.Point.SqrDist(SysUtility._ptr_t<SysGeometry.Point>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysGeometry.Point.SqrDistToSegment(System.Double,System.Double,System.Double,System.Double,SysUtility._ptr_t<SysGeometry.Point>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysGeometry.Point.SqrDistToSegment(SysUtility._ptr_t<SysGeometry.Point>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t<SysGeometry.Point>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t<SysGeometry.Point>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysGeometry.Point.HitTest(SysGeometry.Point*,System.Double,SysGeometry.GeometryHitPartType,SysGeometry.Point*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysDisplay.DisplayTransformation.FromMapPoint(System.Double,System.Double,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysDisplay.DisplayTransformation.FromMapPoint(System.Double,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysDisplay.DisplayTransformation.ToMapPoint(System.Double,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysDisplay.DisplayTransformation.CalculateIntersectBounds(QRect!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysDisplay.DisplayTransformation.CalculateIntersectRect(QRect!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysDisplay.DisplayTransformation.CalculatePointBufferRect(SysUtility._ptr_t<SysGeometry.Point>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysDisplay.Symbol.Draw(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t<SysDisplay.DisplayTransformation>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t<SysGeometry.Geometry>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysGeometry.PointCollection.GetPoint(System.Int32,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysGeometry.PointCollection.SetPoint(System.Int32,System.Double,System.Double)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysGeometry.PointCollection.QueryCoords(System.Int32,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysGeometry.PointCollection.QueryCoords(System.Int32,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysGeometry.Polyline.HitTest(SysGeometry.Point*,System.Double,SysGeometry.GeometryHitPartType,SysGeometry.Point*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysDisplay.LineSymbol.Draw(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,QPainterPath!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysDisplay.LineSymbol.Draw(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t<SysDisplay.DisplayTransformation>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t<SysGeometry.Geometry>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysDisplay.LineSymbol.DrawCurve(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t<SysDisplay.DisplayTransformation>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t<SysGeometry.Curve>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysDisplay.SimpleLineSymbol.ImportFromJson(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysDisplay.SimpleLineSymbol.ImportFromJson(QJsonObject*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysDisplay.SimpleLineSymbol.ExportToJson(QString*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysCarto.SnapGrid.Draw(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t<SysDisplay.DisplayTransformation>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysCarto.Page*)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysCarto.Layer.SetName(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysCarto.MultiLayer.GetDataset”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysCarto.MultiLayer.GetLayers”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysCarto.IGraphicsContainer.GetAllElements”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysCarto.IGraphicsContainer.QueryElements(SysUtility._ptr_t<SysGeometry.Geometry>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysCarto.IGraphicsContainer.QueryElementsByPoint(SysUtility._ptr_t<SysDisplay.DisplayTransformation>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t<SysGeometry.Point>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysCarto.IGraphicsContainer.SelectedElements”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysCarto.ActiveView.SetTrackerCancel(SysUtility._ptr_t<SysUI.TrackerCancel>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“F:SysDataSource.ColorEntry.c1”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“F:SysDataSource.ColorEntry.c2”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“F:SysDataSource.ColorEntry.c3”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“F:SysDataSource.ColorEntry.c4”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysDataSource.RasterBand.GetNoDataValue(System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysDataSource.RasterBand.GetCategoryNames”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysDataSource.RasterBand.SetCategoryNames(QVector<QString>!System.Runtime.CompilerServices.IsConst)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysDataSource.RasterBand.GetBlockSize(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysDataSource.RasterDataset.GetPyramidSize(System.Int32,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysCarto.IRasterFilterProps.GetPreRasterFilterList”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysCarto.IRasterFilterProps.GetAfterRasterFilterPtrList”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysCarto.RasterRender.GetType”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysCarto.RasterLayer.GetDataset”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysCarto.RasterLayer.GetRenderer”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysCarto.Map.GetLayers”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysCarto.Map.GetAllLayer”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysCarto.Map.GetSubLayers(SysUtility._ptr_t<SysCarto.Layer>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysCarto.Map.GetSelectionFeatures”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysCarto.Map.GetLayerSelectionFeatures(SysUtility._ptr_t<SysCarto.Layer>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysDisplay.TextSymbol.Draw(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,QPointF*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysDisplay.TextSymbol.Draw(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t<SysDisplay.DisplayTransformation>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t<SysGeometry.Geometry>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysDisplay.TextSymbol.ImportFromJson(QString!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysDisplay.TextSymbol.ImportFromJson(QJsonObject*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysDisplay.TextSymbol.ExportToJson(QString*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysDisplay.MarkerSymbol.Draw(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysDisplay.MarkerSymbol.Draw(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t<SysDisplay.DisplayTransformation>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t<SysGeometry.Geometry>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysDisplay.MarkerSymbol.DrawPoint(QPainter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t<SysDisplay.DisplayTransformation>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,SysUtility._ptr_t<SysGeometry.Point>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysGeometry.MultiPolyline.HitTest(SysGeometry.Point*,System.Double,SysGeometry.GeometryHitPartType,SysGeometry.Point*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysGeometry.Ring.HitTest(SysGeometry.Point*,System.Double,SysGeometry.GeometryHitPartType,SysGeometry.Point*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysGeometry.Polygon.QueryCoords(System.Int32,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysGeometry.Polygon.QueryCoords(System.Int32,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysGeometry.Polygon.HitTest(SysGeometry.Point*,System.Double,SysGeometry.GeometryHitPartType,SysGeometry.Point*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)”的格式错误的 XML 文档注释。-->
        <!-- 丢弃成员“M:SysCarto.IPmdContents.GetCustomerProperty”的格式错误的 XML 文档注释。-->
    </members>
</doc>